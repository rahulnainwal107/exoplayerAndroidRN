diff --git a/node_modules/react-native-video/CHANGELOG.md b/node_modules/react-native-video/CHANGELOG.md
deleted file mode 100644
index 4b2a424..0000000
--- a/node_modules/react-native-video/CHANGELOG.md
+++ /dev/null
@@ -1,211 +0,0 @@
-## Changelog
-
-### Version 5.2.0
-
-- Fix for tvOS native audio menu language selector
-- Update ExoPlayer to allow pre-init and content clear [#2412] (https://github.com/react-native-video/react-native-video/pull/2412)
-- iOS rate is reset to 1.0 after play/pause [#2167] (https://github.com/react-native-video/react-native-video/pull/2167)
-- Upgrade ExoPlayer to 2.13.2 [#2317] (https://github.com/react-native-video/react-native-video/pull/2317)
-- Fix AudioFocus pausing video when attempting to play [#2311] (https://github.com/react-native-video/react-native-video/pull/2311)
-
-### Version 5.1.0-alpha9
-
-- Add ARM64 support for windows [#2137](https://github.com/react-native-community/react-native-video/pull/2137)
-- Fix deprecated API bug for windows [#2119](https://github.com/react-native-video/react-native-video/pull/2119)
-- Added `rate` property and autolinking support for windows [#2206](https://github.com/react-native-video/react-native-video/pull/2206)
-
-### Version 5.1.0-alpha8
-
-- Fixing ID3 Frame Error When Receiving EventMessage in TimedMetadata [#2116](https://github.com/react-native-community/react-native-video/pull/2116)
-
-### Version 5.1.0-alpha7
-
-- Basic support for DRM on iOS and Android [#1445](https://github.com/react-native-community/react-native-video/pull/1445)
-
-### Version 5.1.0-alpha6 
-
-- Fix iOS bug which would break size of views when video is displayed with controls on a non full-screen React view. [#1931](https://github.com/react-native-community/react-native-video/pull/1931)
-- Fix video dimensions being undefined when playing HLS in ios. [#1992](https://github.com/react-native-community/react-native-video/pull/1992)
-- Add support for audio mix with other apps for iOS. [#1978](https://github.com/react-native-community/react-native-video/pull/1978)
-- Properly implement pending seek for iOS. [#1994](https://github.com/react-native-community/react-native-video/pull/1994)
-- Added `preferredForwardBufferDuration` (iOS) - the duration the player should buffer media from the network ahead of the playhead to guard against playback disruption. (#1944)
-- Added `currentPlaybackTime` (Android ExoPlayer, iOS) - when playing an HLS live stream with a `EXT-X-PROGRAM-DATE-TIME` tag configured, then this property will contain the epoch value in msec. (#1944)
-- Added `trackId` (Android ExoPlayer) - Configure an identifier for the video stream to link the playback context to the events emitted. (#1944)
-- Added preventsDisplaySleepDuringVideoPlayback (#2019)
-- Reverted the JS fullscreening for Android. [#2013](https://github.com/react-native-community/react-native-video/pull/2013)
-- Set iOS request headers without needing to edit RCTVideo.m. [#2014](https://github.com/react-native-community/react-native-video/pull/2014)
-- Fix exoplayer aspect ratio update on source changes [#2053](https://github.com/react-native-community/react-native-video/pull/2053)
-
-### Version 5.1.0-alpha5
-
-- Add support for react-native Windows Cpp/WinRT [#1893]((https://github.com/react-native-community/react-native-video/pull/1893))
-
-### Version 5.1.0-alpha4
-
-- Fix android play/pause bug related to full-screen mode [#1916](https://github.com/react-native-community/react-native-video/pull/1916)
-
-### Version 5.1.0-alpha3
-
-- Improve Android Audio Focus [#1897](https://github.com/react-native-community/react-native-video/pull/1897)
-
-### Version 5.1.0-alpha2
-
-- Added support for full-screen functionality in Android Exoplayer [#1730](https://github.com/react-native-community/react-native-video/pull/1730)
-
-### Version 5.1.0-alpha1
-
-- Fixed Exoplayer doesn't work with mute=true (Android). [#1696](https://github.com/react-native-community/react-native-video/pull/1696)
-- Added support for automaticallyWaitsToMinimizeStalling property (iOS) [#1723](https://github.com/react-native-community/react-native-video/pull/1723)
-- Bump Exoplayer to 2.10.4, remove deprecated usages of Exoplayer methods (Android). [#1753](https://github.com/react-native-community/react-native-video/pull/1753)
-- Preserve Exoplayer BandwidthMeter instance across video plays, this should noticeably improve streaming bandwidth detection (Android).
-
-### Version 5.0.2
-
-- Fix crash when RCTVideo's superclass doesn't observe the keyPath 'frame' (iOS) [#1720](https://github.com/react-native-community/react-native-video/pull/1720)
-
-### Version 5.0.1
-
-- Fix AndroidX Support bad merge
-
-### Version 5.0.0 [Deprecated]
-
-- AndroidX Support
-
-### Version 4.4.4
-
-- Handle racing conditions when props are settled on Exoplayer
-
-### Version 4.4.3
-
-- Fix mute/unmute when controls are present (iOS) [#1654](https://github.com/react-native-community/react-native-video/pull/1654)
-- Fix Android videos being able to play with background music/audio from other apps.
-- Fixed memory leak on iOS when using `controls` [#1647](https://github.com/react-native-community/react-native-video/pull/1647)
-- (Android) Update gradle and target SDK [#1629](https://github.com/react-native-community/react-native-video/pull/1629)
-- Fix iOS stressed mount/unmount crash [#1646](https://github.com/react-native-community/react-native-video/pull/1646)
-
-### Version 4.4.2
-
-- Change compileOnly to implementation on gradle (for newer gradle versions and react-native 0.59 support) [#1592](https://github.com/react-native-community/react-native-video/pull/1592)
-- Replaced RCTBubblingEventBlock events by RCTDirectEventBlock to avoid event name collisions [#1625](https://github.com/react-native-community/react-native-video/pull/1625)
-- Added `onPlaybackRateChange` to README [#1578](https://github.com/react-native-community/react-native-video/pull/1578)
-- Added `onReadyForDisplay` to README [#1627](https://github.com/react-native-community/react-native-video/pull/1627)
-- Improved handling of poster image. Fixes bug with displaying video and poster simultaneously. [#1627](https://github.com/react-native-community/react-native-video/pull/1627)
-- Fix background audio stopping on iOS when using `controls` [#1614](https://github.com/react-native-community/react-native-video/pull/1614)
-
-### Version 4.4.1
-
-- Fix tvOS picture-in-picture compilation regression [#1518](https://github.com/react-native-community/react-native-video/pull/1518)
-- fullscreen rotation issues with iOS built-in controls [#1441](https://github.com/react-native-community/react-native-video/pull/1441)
-- Fix player freeze when playing audio files on ExoPlayer [#1529](https://github.com/react-native-community/react-native-video/pull/1529)
-
-### Version 4.4.0
-
-- Fix runtime warning by replacing `UIManager.RCTVideo` with `UIManager.getViewManagerConfig('RCTVideo')` (and ensuring backwards compat) [#1487](https://github.com/react-native-community/react-native-video/pull/1487)
-- Fix loading package resolved videos when using video-caching [#1438](https://github.com/react-native-community/react-native-video/pull/1438)
-- Fix "message sent to deallocated instance" crash on ios [#1482](https://github.com/react-native-community/react-native-video/pull/1482)
-- Display a warning when source is empty [#1478](https://github.com/react-native-community/react-native-video/pull/1478)
-- Don't crash on iOS for an empty source [#1246](https://github.com/react-native-community/react-native-video/pull/1246)
-- Recover from from transient internet failures when loading on ExoPlayer [#1448](https://github.com/react-native-community/react-native-video/pull/1448)
-- Add controls support for ExoPlayer [#1414](https://github.com/react-native-community/react-native-video/pull/1414)
-- Fix check for text tracks when iOS caching enabled [#1387](https://github.com/react-native-community/react-native-video/pull/1387)
-- Add support for Picture in Picture on iOS [#1325](https://github.com/react-native-community/react-native-video/pull/1325)
-- Fix UIManager undefined variable [#1488](https://github.com/react-native-community/react-native-video/pull/1488)
-
-### Version 4.3.0
-
-- Fix iOS video not displaying after switching source [#1395](https://github.com/react-native-community/react-native-video/pull/1395)
-- Add the filterEnabled flag, fixes iOS video start time regression [#1384](https://github.com/react-native-community/react-native-video/pull/1384)
-- Fix text not appearing in release builds of Android apps [#1373](https://github.com/react-native-community/react-native-video/pull/1373)
-- Update to ExoPlayer 2.9.3 [#1406](https://github.com/react-native-community/react-native-video/pull/1406)
-- Add video track selection & onBandwidthUpdate [#1199](https://github.com/react-native-community/react-native-video/pull/1199)
-- Recovery from transient internet failures and props to configure the custom retry count [#1448](https://github.com/react-native-community/react-native-video/pull/1448)
-
-### Version 4.2.0
-
-- Don't initialize filters on iOS unless a filter is set. This was causing a startup performance regression [#1360](https://github.com/react-native-community/react-native-video/pull/1360)
-- Support setting the maxBitRate [#1310](https://github.com/react-native-community/react-native-video/pull/1310)
-- Fix useTextureView not defaulting to true [#1383](https://github.com/react-native-community/react-native-video/pull/1383)
-- Fix crash on MediaPlayer w/ Android 4.4 & avoid memory leak [#1328](https://github.com/react-native-community/react-native-video/pull/1328)
-
-### Version 4.1.0
-
-- Generate onSeek on Android ExoPlayer & MediaPlayer after seek completes [#1351](https://github.com/react-native-community/react-native-video/pull/1351)
-- Remove unneeded onVideoSaved event [#1350](https://github.com/react-native-community/react-native-video/pull/1350)
-- Disable AirPlay if sidecar text tracks are enabled [#1304](https://github.com/react-native-community/react-native-video/pull/1304)
-- Add possibility to remove black screen while video is loading in Exoplayer [#1355](https://github.com/react-native-community/react-native-video/pull/1355)
-
-### Version 4.0.1
-
-- Add missing files to package.json [#1342](https://github.com/react-native-community/react-native-video/pull/1342)
-
-### Version 4.0.0
-
-- Partial support for timed metadata on Android MediaPlayer [#707](https://github.com/react-native-community/react-native-video/pull/707)
-- Support video caching for iOS [#955](https://github.com/react-native-community/react-native-video/pull/955)
-- Video caching cleanups [#1172](https://github.com/react-native-community/react-native-video/pull/1172)
-- Add ipod-library support [#926](https://github.com/react-native-community/react-native-video/pull/926/files)
-- Fix crash on ExoPlayer when there are no audio tracks [#1233](https://github.com/react-native-community/react-native-video/pull/1233)
-- Reduce package size [#1231](https://github.com/react-native-community/react-native-video/pull/1231)
-- Remove unnecessary import in TextTrackType [#1229](https://github.com/react-native-community/react-native-video/pull/1229)
-- Prevent flash between poster and video [#1167](https://github.com/react-native-community/react-native-video/pull/1167)
-- Support react-native-dom [#1253](https://github.com/react-native-community/react-native-video/pull/1253)
-- Update to ExoPlayer 2.8.2. Android SDK 26 now required [#1170](https://github.com/react-native-community/react-native-video/pull/1170)
-- Update to ExoPlayer 2.8.4 [#1266](https://github.com/react-native-community/react-native-video/pull/1266)
-- Add fullscreenOrientation option for iOS [#1215](https://github.com/react-native-community/react-native-video/pull/1215)
-- Update to ExoPlayer 2.9.0 [#1285](https://github.com/react-native-community/react-native-video/pull/1285)
-- Switch useTextureView to default to `true` [#1286](https://github.com/react-native-community/react-native-video/pull/1286)
-- Re-add fullscreenAutorotate prop [#1303](https://github.com/react-native-community/react-native-video/pull/1303)
-- Make seek throw a useful error for NaN values [#1283](https://github.com/react-native-community/react-native-video/pull/1283)
-- Video Filters and Save Video [#1306](https://github.com/react-native-community/react-native-video/pull/1306)
-- Fix: volume should not change on onAudioFocusChange event [#1327](https://github.com/react-native-community/react-native-video/pull/1327)
-- Update ExoPlayer to 2.9.1 and OkHTTP to 3.12.0 [#1338](https://github.com/react-native-community/react-native-video/pull/1338)
-
-### Version 3.2.0
-
-- Basic fullscreen support for Android MediaPlayer [#1138](https://github.com/react-native-community/react-native-video/pull/1138)
-- Simplify default Android SDK code [#1145](https://github.com/react-native-community/react-native-video/pull/1145) [#1146](https://github.com/react-native-community/react-native-video/pull/1146)
-- Various iOS sideloaded text track fixes [#1157](https://github.com/react-native-community/react-native-video/pull/1157)
-- Fix #1150 where assets with bundled assets don't work on iOS in release mode [#1162](https://github.com/react-native-community/react-native-video/pull/1162)
-- Support configuring the buffer on Android ExoPlayer [#1160](https://github.com/react-native-community/react-native-video/pull/1160)
-- Prevent sleep from sleeping while videos are playing on Android MediaPlayer [#1117](https://github.com/react-native-community/react-native-video/pull/1117)
-- Update NewtonSoft JSON to match react-native-windows version [#1169](https://github.com/react-native-community/react-native-video/pull/1169)
-
-### Version 3.1.0
-
-- Support sidecar text tracks on iOS [#1109](https://github.com/react-native-community/react-native-video/pull/1109)
-- Support onAudioBecomingNoisy on iOS [#1131](https://github.com/react-native-community/react-native-video/pull/1131)
-
-### Version 3.0
-
-- Inherit Android buildtools and SDK version from the root project [#1081](https://github.com/react-native-community/react-native-video/pull/1081)
-- Automatically play on ExoPlayer when the paused prop is not set [#1083](https://github.com/react-native-community/react-native-video/pull/1083)
-- Preserve Android MediaPlayer paused prop when backgrounding [#1082](https://github.com/react-native-community/react-native-video/pull/1082)
-- Support specifying headers on ExoPlayer as part of the source [#805](https://github.com/react-native-community/react-native-video/pull/805)
-- Prevent iOS onLoad event during seeking [#1088](https://github.com/react-native-community/react-native-video/pull/1088)
-- ExoPlayer playableDuration incorrect [#1089](https://github.com/react-native-community/react-native-video/pull/1089)
-
-### Version 2.3.1
-
-- Revert PR to inherit Android SDK versions from root project. Re-add in 3.0 [#1080](https://github.com/react-native-community/react-native-video/pull/1080)
-
-### Version 2.3.0
-
-- Support allowsExternalPlayback on iOS [#1057](https://github.com/react-native-community/react-native-video/pull/1057)
-- Inherit Android buildtools and SDK version from the root project [#999](https://github.com/react-native-community/react-native-video/pull/999)
-- Fix bug that caused ExoPlayer to start paused if playInBackground was set [#833](https://github.com/react-native-community/react-native-video/pull/833)
-- Fix crash if clearing an observer on iOS that was already cleared [#1075](https://github.com/react-native-community/react-native-video/pull/1075)
-- Add audioOnly prop for music files [#1039](https://github.com/react-native-community/react-native-video/pull/1039)
-- Support seeking with more exact tolerance on iOS [#1076](https://github.com/react-native-community/react-native-video/pull/1076)
-
-### Version 2.2.0
-
-- Text track selection support for iOS & ExoPlayer [#1049](https://github.com/react-native-community/react-native-video/pull/1049)
-- Support outputting to a TextureView on Android ExoPlayer [#1058](https://github.com/react-native-community/react-native-video/pull/1058)
-- Support changing the left/right balance on Android MediaPlayer [#1051](https://github.com/react-native-community/react-native-video/pull/1051)
-- Prevent multiple onEnd notifications on iOS [#832](https://github.com/react-native-community/react-native-video/pull/832)
-- Fix doing a partial swipe on iOS causing a black screen [#1048](https://github.com/react-native-community/react-native-video/pull/1048)
-- Fix crash when switching to a new source on iOS [#974](https://github.com/react-native-community/react-native-video/pull/974)
-- Add cookie support for ExoPlayer [#922](https://github.com/react-native-community/react-native-video/pull/922)
-- Remove ExoPlayer onMetadata that wasn't being used [#1040](https://github.com/react-native-community/react-native-video/pull/1040)
-- Fix bug where setting the progress interval on iOS didn't work [#800](https://github.com/react-native-community/react-native-video/pull/800)
-- Support setting the poster resize mode [#595](https://github.com/react-native-community/react-native-video/pull/595)
diff --git a/node_modules/react-native-video/DRMType.js b/node_modules/react-native-video/DRMType.js
index 473536b..d873bd6 100644
--- a/node_modules/react-native-video/DRMType.js
+++ b/node_modules/react-native-video/DRMType.js
@@ -2,5 +2,5 @@ export default {
     WIDEVINE: 'widevine',
     PLAYREADY: 'playready',
     CLEARKEY: 'clearkey',
-    FAIRPLAY: 'fairplay'
+    FAIRPLAY: 'fairplay',
 };
diff --git a/node_modules/react-native-video/LICENSE b/node_modules/react-native-video/LICENSE
index dc7f43c..297b2cb 100644
--- a/node_modules/react-native-video/LICENSE
+++ b/node_modules/react-native-video/LICENSE
@@ -1,5 +1,6 @@
 MIT License
 
+Copyright (c) 2016-2022 Project contributors
 Copyright (c) 2016 Brent Vatne, Baris Sencan
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
diff --git a/node_modules/react-native-video/README.md b/node_modules/react-native-video/README.md
index ab9715d..986312e 100644
--- a/node_modules/react-native-video/README.md
+++ b/node_modules/react-native-video/README.md
@@ -1,1488 +1,31 @@
-## react-native-video
+# react-native-video
 
-A `<Video>` component for react-native, as seen in
-[react-native-login](https://github.com/brentvatne/react-native-login)!
+> :warning: **Version 6 Alpha**: The following documentation may refer to features only available through the v6.0.0 alpha releases, [please see version 5.2.x](https://github.com/react-native-video/react-native-video/blob/v5.2.0/README.md) for the current documentation!
 
-Version 5.x recommends react-native >= 0.60.0 for Android 64bit builds and Android X support.
+## A `<Video>` component for react-native.
+Version 6.x recommends react-native >= 0.68.2. 
+<br>For older versions of react-native, [please use version 5.x](https://github.com/react-native-video/react-native-video/tree/v5.2.0).
 
-Version 4.x requires react-native >= 0.57.0
+### Version 6.0.0 breaking changes
 
-Version 3.x requires react-native >= 0.40.0
-
-### Version 5.0.0 breaking changes
-
-Version 5 introduces breaking changes on Android, please check carefully the steps described there: [Android Installation](#Android-installation)
-
-### Version 4.0.0 breaking changes
-Version 4.0.0 changes some behaviors and may require updates to your Gradle files.  See [Updating](#updating) for details.
-
-Version 4.0.0 now requires Android target SDK 26+ and Gradle 3 plugin in order to support ExoPlayer 2.9.0. Google is dropping support for apps using target SDKs older than 26 as of October 2018 and Gradle 2 as of January 2019. React Native 0.57 defaults to Gradle 3 & SDK 27.
-
-If you need to support an older React Native version, you should use react-native-video 3.2.1.
-
-### Version 3.0.0 breaking changes
-Version 3.0 features a number of changes to existing behavior. See [Updating](#updating) for changes.
-
-## Table of Contents
-
-* [Installation](#installation)
-  * [iOS](#ios-installation)
-  * [tvOS](#tvos-installation)
-  * [Android](#android-installation)
-  * [Windows](#windows-installation)
-  * [react-native-dom](#react-native-dom-installation)
-* [Usage](#usage)
-* [iOS App Transport Security](#ios-app-transport-security)
-* [Audio Mixing](#audio-mixing)
-* [Android Expansion File Usage](#android-expansion-file-usage)
-* [Updating](#updating)
-
-## Installation
+Version 6.0.0 is introducing dozens of breaking changes, mostly through updated dependecies and significant refactoring. While the API remains compatible, the significant internal changes require full testing with your app to ensure all functionality remains operational. Please view the [Changelog](CHANGELOG.md) for specific breaking changes.
 
+### Installing Version 6.0.0 Alphas
+Whilst we finalise version 6.0.0 you can install the latest alpha from npm
 Using npm:
-
-```shell
-npm install --save react-native-video
-```
-
-or using yarn:
-
-```shell
-yarn add react-native-video
-```
-
-Then follow the instructions for your platform to link react-native-video into your project:
-
-### iOS installation
-<details>
-  <summary>iOS details</summary>
-
-#### Standard Method
-
-**React Native 0.60 and above**
-
-Run `npx pod-install`. Linking is not required in React Native 0.60 and above.
-
-**React Native 0.59 and below**
-
-Run `react-native link react-native-video` to link the react-native-video library.
-
-#### Using CocoaPods (required to enable caching)
-
-Setup your Podfile like it is described in the [react-native documentation](https://facebook.github.io/react-native/docs/integration-with-existing-apps#configuring-cocoapods-dependencies). 
-
-Depending on your requirements you have to choose between the two possible subpodspecs:
-
-Video only:
-
-```diff
-  pod 'Folly', :podspec => '../node_modules/react-native/third-party-podspecs/Folly.podspec'
-+  `pod 'react-native-video', :path => '../node_modules/react-native-video/react-native-video.podspec'`
-end
-```
-
-Video with caching ([more info](docs/caching.md)):
-
-```diff
-  pod 'Folly', :podspec => '../node_modules/react-native/third-party-podspecs/Folly.podspec'
-+  `pod 'react-native-video/VideoCaching', :path => '../node_modules/react-native-video/react-native-video.podspec'`
-end
-```
-
-</details>
-
-### tvOS installation
-  <details>
-  <summary>tvOS details</summary>
-
-`react-native link react-native-video` doesn’t work properly with the tvOS target so we need to add the library manually.
-
-First select your project in Xcode.
-
-<img src="./docs/tvOS-step-1.jpg" width="40%">
-
-After that, select the tvOS target of your application and select « General » tab
-
-<img src="./docs/tvOS-step-2.jpg" width="40%">
-
-Scroll to « Linked Frameworks and Libraries » and tap on the + button
-
-<img src="./docs/tvOS-step-3.jpg" width="40%">
-
-Select RCTVideo-tvOS
-
-<img src="./docs/tvOS-step-4.jpg" width="40%">
-</details>
-
-### Android installation
-<details>
-  <summary>Android details</summary>
- 
-Linking is not required in React Native 0.60 and above.
-If your project is using React Native < 0.60, run `react-native link react-native-video` to link the react-native-video library.
-
-Or if you have trouble, make the following additions to the given files manually:
-
-#### **android/settings.gradle**
-
-The newer ExoPlayer library will work for most people.
-
-```gradle
-include ':react-native-video'
-project(':react-native-video').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-video/android-exoplayer')
-```
-
-If you need to use the old Android MediaPlayer based player, use the following instead:
-
-```gradle
-include ':react-native-video'
-project(':react-native-video').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-video/android')
-```
-
-#### **android/app/build.gradle**
-
-From version >= 5.0.0, you have to apply these changes:
-
-```diff
-dependencies {
-   ...
-    compile project(':react-native-video')
-+   implementation "androidx.appcompat:appcompat:1.0.0"
--   implementation "com.android.support:appcompat-v7:${rootProject.ext.supportLibVersion}"
-
-}
 ```
-
-#### **android/gradle.properties**
-
-Migrating to AndroidX (needs version >= 5.0.0):
-
-```gradle.properties
-android.useAndroidX=true
-android.enableJetifier=true
+npm install --save react-native-video@alpha
 ```
-
-#### **MainApplication.java**
-
-On top, where imports are:
-
-```java
-import com.brentvatne.react.ReactVideoPackage;
+using yarn:
 ```
-
-Add the `ReactVideoPackage` class to your list of exported packages.
-
-```java
-@Override
-protected List<ReactPackage> getPackages() {
-    return Arrays.asList(
-            new MainReactPackage(),
-            new ReactVideoPackage()
-    );
-}
+yarn add react-native-video@alpha
 ```
-</details>
-
-### Windows installation
-<details>
-  <summary>Windows RNW C++/WinRT details</summary>
-
-#### Autolinking
-
-**React Native Windows 0.63 and above**
-
-Autolinking should automatically add react-native-video to your app.
-
-#### Manual Linking
-
-**React Native Windows 0.62**
-
-Make the following additions to the given files manually:
-
-##### **windows\myapp.sln**
-
-Add the _ReactNativeVideoCPP_ project to your solution (eg. `windows\myapp.sln`):
-
-1. Open your solution in Visual Studio 2019
-2. Right-click Solution icon in Solution Explorer > Add > Existing Project...
-3. Select `node_modules\react-native-video\windows\ReactNativeVideoCPP\ReactNativeVideoCPP.vcxproj`
-
-##### **windows\myapp\myapp.vcxproj**
-
-Add a reference to _ReactNativeVideoCPP_ to your main application project (eg. `windows\myapp\myapp.vcxproj`):
-
-1. Open your solution in Visual Studio 2019
-2. Right-click main application project > Add > Reference...
-3. Check _ReactNativeVideoCPP_ from Solution Projects
-
-##### **pch.h**
-
-Add `#include "winrt/ReactNativeVideoCPP.h"`.
-
-##### **app.cpp**
-
-Add `PackageProviders().Append(winrt::ReactNativeVideoCPP::ReactPackageProvider());` before `InitializeComponent();`.
-
-**React Native Windows 0.61 and below**
-
-Follow the manual linking instuctions for React Native Windows 0.62 above, but substitute _ReactNativeVideoCPP61_ for _ReactNativeVideoCPP_.
-
-</details>
-
-### react-native-dom installation
-<details>
-  <summary>react-native-dom details</summary>
-
-Make the following additions to the given files manually:
-
-#### **dom/bootstrap.js**
-
-Import RCTVideoManager and add it to the list of nativeModules:
-
-```javascript
-import { RNDomInstance } from "react-native-dom";
-import { name as appName } from "../app.json";
-import RCTVideoManager from 'react-native-video/dom/RCTVideoManager'; // Add this
-
-// Path to RN Bundle Entrypoint ================================================
-const rnBundlePath = "./entry.bundle?platform=dom&dev=true";
-
-// React Native DOM Runtime Options =============================================
-const ReactNativeDomOptions = {
-  enableHotReload: false,
-  nativeModules: [RCTVideoManager] // Add this
-};
-```
-</details>
-
-## Usage
-
-```javascript
-// Load the module
-
-import Video from 'react-native-video';
-
-// Within your render function, assuming you have a file called
-// "background.mp4" in your project. You can include multiple videos
-// on a single screen if you like.
-
-<Video source={{uri: "background"}}   // Can be a URL or a local file.
-       ref={(ref) => {
-         this.player = ref
-       }}                                      // Store reference
-       onBuffer={this.onBuffer}                // Callback when remote video is buffering
-       onError={this.videoError}               // Callback when video cannot be loaded
-       style={styles.backgroundVideo} />
-
-// Later on in your styles..
-var styles = StyleSheet.create({
-  backgroundVideo: {
-    position: 'absolute',
-    top: 0,
-    left: 0,
-    bottom: 0,
-    right: 0,
-  },
-});
-```
-
-### Configurable props
-* [allowsExternalPlayback](#allowsexternalplayback)
-* [audioOnly](#audioonly)
-* [automaticallyWaitsToMinimizeStalling](#automaticallyWaitsToMinimizeStalling)
-* [bufferConfig](#bufferconfig)
-* [controls](#controls)
-* [currentPlaybackTime](#currentPlaybackTime)
-* [disableFocus](#disableFocus)
-* [filter](#filter)
-* [filterEnabled](#filterEnabled)
-* [fullscreen](#fullscreen)
-* [fullscreenAutorotate](#fullscreenautorotate)
-* [fullscreenOrientation](#fullscreenorientation)
-* [headers](#headers)
-* [hideShutterView](#hideshutterview)
-* [id](#id)
-* [ignoreSilentSwitch](#ignoresilentswitch)
-* [maxBitRate](#maxbitrate)
-* [minLoadRetryCount](#minLoadRetryCount)
-* [mixWithOthers](#mixWithOthers)
-* [muted](#muted)
-* [paused](#paused)
-* [pictureInPicture](#pictureinpicture)
-* [playInBackground](#playinbackground)
-* [playWhenInactive](#playwheninactive)
-* [poster](#poster)
-* [posterResizeMode](#posterresizemode)
-* [preferredForwardBufferDuration](#preferredForwardBufferDuration)
-* [preventsDisplaySleepDuringVideoPlayback](#preventsDisplaySleepDuringVideoPlayback)
-* [progressUpdateInterval](#progressupdateinterval)
-* [rate](#rate)
-* [repeat](#repeat)
-* [reportBandwidth](#reportbandwidth)
-* [resizeMode](#resizemode)
-* [selectedAudioTrack](#selectedaudiotrack)
-* [selectedTextTrack](#selectedtexttrack)
-* [selectedVideoTrack](#selectedvideotrack)
-* [source](#source)
-* [stereoPan](#stereopan)
-* [textTracks](#texttracks)
-* [trackId](#trackId)
-* [useTextureView](#usetextureview)
-* [volume](#volume)
-
-### Event props
-* [onAudioBecomingNoisy](#onaudiobecomingnoisy)
-* [onBandwidthUpdate](#onbandwidthupdate)
-* [onEnd](#onend)
-* [onExternalPlaybackChange](#onexternalplaybackchange)
-* [onFullscreenPlayerWillPresent](#onfullscreenplayerwillpresent)
-* [onFullscreenPlayerDidPresent](#onfullscreenplayerdidpresent)
-* [onFullscreenPlayerWillDismiss](#onfullscreenplayerwilldismiss)
-* [onFullscreenPlayerDidDismiss](#onfullscreenplayerdiddismiss)
-* [onLoad](#onload)
-* [onLoadStart](#onloadstart)
-* [onReadyForDisplay](#onreadyfordisplay)
-* [onPictureInPictureStatusChanged](#onpictureinpicturestatuschanged)
-* [onPlaybackRateChange](#onplaybackratechange)
-* [onProgress](#onprogress)
-* [onSeek](#onseek)
-* [onRestoreUserInterfaceForPictureInPictureStop](#onrestoreuserinterfaceforpictureinpicturestop)
-* [onTimedMetadata](#ontimedmetadata)
-
-### Methods
-* [dismissFullscreenPlayer](#dismissfullscreenplayer)
-* [presentFullscreenPlayer](#presentfullscreenplayer)
-* [save](#save)
-* [restoreUserInterfaceForPictureInPictureStop](#restoreuserinterfaceforpictureinpicturestop)
-* [seek](#seek)
-
-### Configurable props
-
-#### allowsExternalPlayback
-Indicates whether the player allows switching to external playback mode such as AirPlay or HDMI.
-* **true (default)** - allow switching to external playback mode
-* **false** -  Don't allow switching to external playback mode
-
-Platforms: iOS
-
-#### audioOnly
-Indicates whether the player should only play the audio track and instead of displaying the video track, show the poster instead.
-* **false (default)** - Display the video as normal
-* **true** - Show the poster and play the audio
-
-For this to work, the poster prop must be set.
-
-Platforms: all
-
-#### automaticallyWaitsToMinimizeStalling
-A Boolean value that indicates whether the player should automatically delay playback in order to minimize stalling. For clients linked against iOS 10.0 and later
-* **false** - Immediately starts playback
-* **true (default)** - Delays playback in order to minimize stalling
-
-Platforms: iOS
-
-#### bufferConfig
-Adjust the buffer settings. This prop takes an object with one or more of the properties listed below.
-
-Property | Type | Description
---- | --- | ---
-minBufferMs | number | The default minimum duration of media that the player will attempt to ensure is buffered at all times, in milliseconds.
-maxBufferMs | number | The default maximum duration of media that the player will attempt to buffer, in milliseconds.
-bufferForPlaybackMs | number | The default duration of media that must be buffered for playback to start or resume following a user action such as a seek, in milliseconds.
-bufferForPlaybackAfterRebufferMs | number | The default duration of media that must be buffered for playback to resume after a rebuffer, in milliseconds. A rebuffer is defined to be caused by buffer depletion rather than a user action.
-
-This prop should only be set when you are setting the source, changing it after the media is loaded will cause it to be reloaded.
-
-Example with default values:
-```
-bufferConfig={{
-  minBufferMs: 15000,
-  maxBufferMs: 50000,
-  bufferForPlaybackMs: 2500,
-  bufferForPlaybackAfterRebufferMs: 5000
-}}
-```
-
-Platforms: Android ExoPlayer
-
-#### currentPlaybackTime
-When playing an HLS live stream with a `EXT-X-PROGRAM-DATE-TIME` tag configured, then this property will contain the epoch value in msec.
-
-Platforms: Android ExoPlayer, iOS
-
-#### controls
-Determines whether to show player controls.
-* ** false (default)** - Don't show player controls
-* **true** - Show player controls
-
-Note on iOS, controls are always shown when in fullscreen mode.
-
-For Android MediaPlayer, you will need to build your own controls or use a package like [react-native-video-controls](https://github.com/itsnubix/react-native-video-controls) or [react-native-video-player](https://github.com/cornedor/react-native-video-player).
-
-Note on Android ExoPlayer, native controls are available by default. If needed, you can also add your controls or use a package like [react-native-video-controls].
-
-Platforms: Android ExoPlayer, iOS, react-native-dom
-
-#### disableFocus
-Determines whether video audio should override background music/audio in Android devices.
-* ** false (default)** - Override background audio/music
-* **true** - Let background audio/music from other apps play
-
-Platforms: Android Exoplayer
-
-### DRM
-To setup DRM please follow [this guide](./DRM.md)
-
-Platforms: Android Exoplayer, iOS
-
-#### filter
-Add video filter
-* **FilterType.NONE (default)** - No Filter
-* **FilterType.INVERT** - CIColorInvert
-* **FilterType.MONOCHROME** - CIColorMonochrome
-* **FilterType.POSTERIZE** - CIColorPosterize
-* **FilterType.FALSE** - CIFalseColor
-* **FilterType.MAXIMUMCOMPONENT** - CIMaximumComponent
-* **FilterType.MINIMUMCOMPONENT** - CIMinimumComponent
-* **FilterType.CHROME** - CIPhotoEffectChrome
-* **FilterType.FADE** - CIPhotoEffectFade
-* **FilterType.INSTANT** - CIPhotoEffectInstant
-* **FilterType.MONO** - CIPhotoEffectMono
-* **FilterType.NOIR** - CIPhotoEffectNoir
-* **FilterType.PROCESS** - CIPhotoEffectProcess
-* **FilterType.TONAL** - CIPhotoEffectTonal
-* **FilterType.TRANSFER** - CIPhotoEffectTransfer
-* **FilterType.SEPIA** - CISepiaTone
-
-For more details on these filters refer to the [iOS docs](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP30000136-SW55).
-
-Notes: 
-1. Using a filter can impact CPU usage. A workaround is to save the video with the filter and then load the saved video.
-2. Video filter is currently not supported on HLS playlists.
-3. `filterEnabled` must be set to `true`
-
-Platforms: iOS
-
-#### filterEnabled
-Enable video filter. 
-
-* **false (default)** - Don't enable filter
-* **true** - Enable filter
-
-Platforms: iOS
-
-#### fullscreen
-Controls whether the player enters fullscreen on play.
-* **false (default)** - Don't display the video in fullscreen
-* **true** - Display the video in fullscreen
-
-Platforms: iOS
-
-#### fullscreenAutorotate
-If a preferred [fullscreenOrientation](#fullscreenorientation) is set, causes the video to rotate to that orientation but permits rotation of the screen to orientation held by user. Defaults to TRUE.
-
-Platforms: iOS
-
-#### fullscreenOrientation
-
-* **all (default)** - 
-* **landscape**
-* **portrait**
-
-Platforms: iOS
-
-#### headers
-Pass headers to the HTTP client. Can be used for authorization. Headers must be a part of the source object.
-
-Example:
-```
-source={{
-  uri: "https://www.example.com/video.mp4",
-  headers: {
-    Authorization: 'bearer some-token-value',
-    'X-Custom-Header': 'some value'
-  }
-}}
-```
-
-Platforms: Android ExoPlayer
-
-#### hideShutterView
-Controls whether the ExoPlayer shutter view (black screen while loading) is enabled.
-
-* **false (default)** - Show shutter view 
-* **true** - Hide shutter view
-
-Platforms: Android ExoPlayer
-
-#### id
-Set the DOM id element so you can use document.getElementById on web platforms. Accepts string values.
-
-Example:
-```
-id="video"
-```
-
-Platforms: react-native-dom
-
-#### ignoreSilentSwitch
-Controls the iOS silent switch behavior
-* **"inherit" (default)** - Use the default AVPlayer behavior
-* **"ignore"** - Play audio even if the silent switch is set
-* **"obey"** - Don't play audio if the silent switch is set
-
-Platforms: iOS
-
-#### maxBitRate
-Sets the desired limit, in bits per second, of network bandwidth consumption when multiple video streams are available for a playlist.
-
-Default: 0. Don't limit the maxBitRate.
-
-Example:
-```
-maxBitRate={2000000} // 2 megabits
-```
-
-Platforms: Android ExoPlayer, iOS
-
-#### minLoadRetryCount
-Sets the minimum number of times to retry loading data before failing and reporting an error to the application. Useful to recover from transient internet failures.
-
-Default: 3. Retry 3 times.
-
-Example:
-```
-minLoadRetryCount={5} // retry 5 times
-```
-
-Platforms: Android ExoPlayer
-
-#### mixWithOthers
-Controls how Audio mix with other apps.
-* **"inherit" (default)** - Use the default AVPlayer behavior
-* **"mix"** - Audio from this video mixes with audio from other apps.
-* **"duck"** - Reduces the volume of other apps while audio from this video plays.
-
-Platforms: iOS
-
-#### muted
-Controls whether the audio is muted
-* **false (default)** - Don't mute audio
-* **true** - Mute audio
-
-Platforms: all
-
-#### paused
-Controls whether the media is paused
-* **false (default)** - Don't pause the media
-* **true** - Pause the media
-
-Platforms: all
-
-#### pictureInPicture
-Determine whether the media should played as picture in picture.
-* **false (default)** - Don't not play as picture in picture
-* **true** - Play the media as picture in picture
-
-Platforms: iOS
-
-#### playInBackground
-Determine whether the media should continue playing while the app is in the background. This allows customers to continue listening to the audio.
-* **false (default)** - Don't continue playing the media
-* **true** - Continue playing the media
-
-To use this feature on iOS, you must:
-* [Enable Background Audio](https://developer.apple.com/library/archive/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/AudioSessionBasics/AudioSessionBasics.html#//apple_ref/doc/uid/TP40007875-CH3-SW3) in your Xcode project
-* Set the ignoreSilentSwitch prop to "ignore"
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS
-
-#### playWhenInactive
-Determine whether the media should continue playing when notifications or the Control Center are in front of the video.
-* **false (default)** - Don't continue playing the media
-* **true** - Continue playing the media
-
-Platforms: iOS
-
-#### poster
-An image to display while the video is loading
-<br>Value: string with a URL for the poster, e.g. "https://baconmockup.com/300/200/"
-
-Platforms: all
-
-#### posterResizeMode
-Determines how to resize the poster image when the frame doesn't match the raw video dimensions.
-* **"contain" (default)** - Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width and height) of the image will be equal to or less than the corresponding dimension of the view (minus padding).
-* **"center"** - Center the image in the view along both dimensions. If the image is larger than the view, scale it down uniformly so that it is contained in the view.
-* **"cover"** - Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width and height) of the image will be equal to or larger than the corresponding dimension of the view (minus padding).
-* **"none"** - Don't apply resize
-* **"repeat"** - Repeat the image to cover the frame of the view. The image will keep its size and aspect ratio. (iOS only)
-* **"stretch"** - Scale width and height independently, This may change the aspect ratio of the src.
-
-Platforms: all
-
-#### preferredForwardBufferDuration
-The duration the player should buffer media from the network ahead of the playhead to guard against playback disruption. Sets the [preferredForwardBufferDuration](https://developer.apple.com/documentation/avfoundation/avplayeritem/1643630-preferredforwardbufferduration) instance property on AVPlayerItem.
-
-Default: 0
-
-Platforms: iOS
-
-#### preventsDisplaySleepDuringVideoPlayback
-Controls whether or not the display should be allowed to sleep while playing the video. Default is not to allow display to sleep.
-
-Default: true
-
-Platforms: iOS, Android
-
-#### progressUpdateInterval
-Delay in milliseconds between onProgress events in milliseconds.
-
-Default: 250.0
-
-Platforms: all
-
-### rate
-Speed at which the media should play. 
-* **0.0** - Pauses the video
-* **1.0** - Play at normal speed
-* **Other values** - Slow down or speed up playback
-
-Platforms: all
-
-Note: For Android MediaPlayer, rate is only supported on Android 6.0 and higher devices.
-
-#### repeat
-Determine whether to repeat the video when the end is reached
-* **false (default)** - Don't repeat the video
-* **true** - Repeat the video
-
-Platforms: all
-
-#### reportBandwidth
-Determine whether to generate onBandwidthUpdate events. This is needed due to the high frequency of these events on ExoPlayer.
-
-* **false (default)** - Don't generate onBandwidthUpdate events
-* **true** - Generate onBandwidthUpdate events
-
-Platforms: Android ExoPlayer
-
-#### resizeMode
-Determines how to resize the video when the frame doesn't match the raw video dimensions.
-* **"none" (default)** - Don't apply resize
-* **"contain"** - Scale the video uniformly (maintain the video's aspect ratio) so that both dimensions (width and height) of the video will be equal to or less than the corresponding dimension of the view (minus padding).
-* **"cover"** - Scale the video uniformly (maintain the video's aspect ratio) so that both dimensions (width and height) of the image will be equal to or larger than the corresponding dimension of the view (minus padding).
-* **"stretch"** - Scale width and height independently, This may change the aspect ratio of the src.
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS, Windows UWP
-
-#### selectedAudioTrack
-Configure which audio track, if any, is played.
-
-```
-selectedAudioTrack={{
-  type: Type,
-  value: Value
-}}
-```
-
-Example:
-```
-selectedAudioTrack={{
-  type: "title",
-  value: "Dubbing"
-}}
-```
-
-Type | Value | Description
---- | --- | ---
-"system" (default) | N/A | Play the audio track that matches the system language. If none match, play the first track.
-"disabled" | N/A | Turn off audio
-"title" | string | Play the audio track with the title specified as the Value, e.g. "French"
-"language" | string | Play the audio track with the language specified as the Value, e.g. "fr"
-"index" | number | Play the audio track with the index specified as the value, e.g. 0
-
-If a track matching the specified Type (and Value if appropriate) is unavailable, the first audio track will be played. If multiple tracks match the criteria, the first match will be used.
-
-Platforms: Android ExoPlayer, iOS
-
-#### selectedTextTrack
-Configure which text track (caption or subtitle), if any, is shown.
-
-```
-selectedTextTrack={{
-  type: Type,
-  value: Value
-}}
-```
-
-Example:
-```
-selectedTextTrack={{
-  type: "title",
-  value: "English Subtitles"
-}}
-```
-
-Type | Value | Description
---- | --- | ---
-"system" (default) | N/A | Display captions only if the system preference for captions is enabled
-"disabled" | N/A | Don't display a text track
-"title" | string | Display the text track with the title specified as the Value, e.g. "French 1"
-"language" | string | Display the text track with the language specified as the Value, e.g. "fr"
-"index" | number | Display the text track with the index specified as the value, e.g. 0
-
-Both iOS & Android (only 4.4 and higher) offer Settings to enable Captions for hearing impaired people. If "system" is selected and the Captions Setting is enabled, iOS/Android will look for a caption that matches that customer's language and display it. 
-
-If a track matching the specified Type (and Value if appropriate) is unavailable, no text track will be displayed. If multiple tracks match the criteria, the first match will be used.
-
-Platforms: Android ExoPlayer, iOS
-
-#### selectedVideoTrack
-Configure which video track should be played. By default, the player uses Adaptive Bitrate Streaming to automatically select the stream it thinks will perform best based on available bandwidth.
-
-```
-selectedVideoTrack={{
-  type: Type,
-  value: Value
-}}
-```
-
-Example:
-```
-selectedVideoTrack={{
-  type: "resolution",
-  value: 480
-}}
-```
-
-Type | Value | Description
---- | --- | ---
-"auto" (default) | N/A | Let the player determine which track to play using ABR
-"disabled" | N/A | Turn off video
-"resolution" | number | Play the video track with the height specified, e.g. 480 for the 480p stream
-"index" | number | Play the video track with the index specified as the value, e.g. 0
-
-If a track matching the specified Type (and Value if appropriate) is unavailable, ABR will be used.
-
-Platforms: Android ExoPlayer
-
-#### source
-Sets the media source. You can pass an asset loaded via require or an object with a uri.
-
-Setting the source will trigger the player to attempt to load the provided media with all other given props. Please be sure that all props are provided before/at the same time as setting the source.
-
-Rendering the player component with a null source will init the player, and start playing once a source value is provided.
-
-Providing a null source value after loading a previous source will stop playback, and clear out the previous source content.
-
-The docs for this prop are incomplete and will be updated as each option is investigated and tested.
-
-
-##### Asset loaded via require
-
-Example: 
-```
-const sintel = require('./sintel.mp4');
-
-source={sintel}
-```
-
-##### URI string
-
-A number of URI schemes are supported by passing an object with a `uri` attribute.
-
-###### Web address (http://, https://)
-
-Example:
-```
-source={{uri: 'https://www.sample-videos.com/video/mp4/720/big_buck_bunny_720p_10mb.mp4' }}
-```
-
-Platforms: all
-
-###### File path (file://)
-
-Example:
-```
-source={{ uri: 'file:///sdcard/Movies/sintel.mp4' }}
-```
-
-Note: Your app will need to request permission to read external storage if you're accessing a file outside your app.
-
-Platforms: Android ExoPlayer, Android MediaPlayer, possibly others
-
-###### iPod Library (ipod-library://)
-
-Path to a sound file in your iTunes library. Typically shared from iTunes to your app.
-
-Example:
-```
-source={{ uri: 'ipod-library:///path/to/music.mp3' }}
-```
-
-Note: Using this feature adding an entry for NSAppleMusicUsageDescription to your Info.plist file as described [here](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html)
-
-Platforms: iOS
-
-##### Explicit mimetype for the stream
-
-Provide a member `type` with value (`mpd`/`m3u8`/`ism`) inside the source object.
-Sometimes is needed when URL extension does not match with the mimetype that you are expecting, as seen on the next example. (Extension is .ism -smooth streaming- but file served is on format mpd -mpeg dash-)
-
-Example:
-```
-source={{ uri: 'http://host-serving-a-type-different-than-the-extension.ism/manifest(format=mpd-time-csf)',
-type: 'mpd' }}
-```
-
-###### Other protocols
-
-The following other types are supported on some platforms, but aren't fully documented yet:
-`content://, ms-appx://, ms-appdata://, assets-library://`
-
-
-#### stereoPan
-Adjust the balance of the left and right audio channels.  Any value between –1.0 and 1.0 is accepted.
-* **-1.0** - Full left
-* **0.0 (default)** - Center
-* **1.0** - Full right
-
-Platforms: Android MediaPlayer
-
-#### textTracks
-Load one or more "sidecar" text tracks. This takes an array of objects representing each track. Each object should have the format:
-
-Property | Description
---- | ---
-title | Descriptive name for the track
-language | 2 letter [ISO 639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) representing the language
-type | Mime type of the track<br> * TextTrackType.SRT - SubRip (.srt)<br> * TextTrackType.TTML - TTML (.ttml)<br> * TextTrackType.VTT - WebVTT (.vtt)<br>iOS only supports VTT, Android ExoPlayer supports all 3
-uri | URL for the text track. Currently, only tracks hosted on a webserver are supported
-
-On iOS, sidecar text tracks are only supported for individual files, not HLS playlists. For HLS, you should include the text tracks as part of the playlist.
-
-Note: Due to iOS limitations, sidecar text tracks are not compatible with Airplay. If textTracks are specified, AirPlay support will be automatically disabled.
-
-Example:
-```
-import { TextTrackType }, Video from 'react-native-video';
-
-textTracks={[
-  {
-    title: "English CC",
-    language: "en",
-    type: TextTrackType.VTT, // "text/vtt"
-    uri: "https://bitdash-a.akamaihd.net/content/sintel/subtitles/subtitles_en.vtt"
-  },
-  {
-    title: "Spanish Subtitles",
-    language: "es",
-    type: TextTrackType.SRT, // "application/x-subrip"
-    uri: "https://durian.blender.org/wp-content/content/subtitles/sintel_es.srt"
-  }
-]}
-```
-
-
-Platforms: Android ExoPlayer, iOS
-
-#### trackId
-Configure an identifier for the video stream to link the playback context to the events emitted.
-
-Platforms: Android ExoPlayer
-
-#### useTextureView
-Controls whether to output to a TextureView or SurfaceView.
-
-SurfaceView is more efficient and provides better performance but has two limitations:
-* It can't be animated, transformed or scaled
-* You can't overlay multiple SurfaceViews
-
-useTextureView can only be set at same time you're setting the source.
-
-* **true (default)** - Use a TextureView
-* **false** - Use a SurfaceView
-
-Platforms: Android ExoPlayer
-
-#### volume
-Adjust the volume.
-* **1.0 (default)** - Play at full volume
-* **0.0** - Mute the audio
-* **Other values** - Reduce volume
-
-Platforms: all
-
-
-### Event props
-
-#### onAudioBecomingNoisy
-Callback function that is called when the audio is about to become 'noisy' due to a change in audio outputs. Typically this is called when audio output is being switched from an external source like headphones back to the internal speaker. It's a good idea to pause the media when this happens so the speaker doesn't start blasting sound.
-
-Payload: none
-
-Platforms: Android ExoPlayer, iOS
-
-#### onBandwidthUpdate
-Callback function that is called when the available bandwidth changes.
-
-Payload:
-
-Property | Type | Description
---- | --- | ---
-bitrate | number | The estimated bitrate in bits/sec
-
-Example:
-```
-{
-  bitrate: 1000000
-}
-```
-
-Note: On Android ExoPlayer, you must set the [reportBandwidth](#reportbandwidth) prop to enable this event. This is due to the high volume of events generated.
-
-Platforms: Android ExoPlayer
-
-#### onEnd
-Callback function that is called when the player reaches the end of the media.
-
-Payload: none
-
-Platforms: all
-
-#### onExternalPlaybackChange
-Callback function that is called when external playback mode for current playing video has changed. Mostly useful when connecting/disconnecting to Apple TV – it's called on connection/disconnection.
-
-Payload:
-
-Property | Type | Description
---- | --- | ---
-isExternalPlaybackActive | boolean | Boolean indicating whether external playback mode is active
-
-Example:
-```
-{
-  isExternalPlaybackActive: true
-}
-```
-
-Platforms: iOS
-
-#### onFullscreenPlayerWillPresent
-Callback function that is called when the player is about to enter fullscreen mode.
-
-Payload: none
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS
-
-#### onFullscreenPlayerDidPresent
-Callback function that is called when the player has entered fullscreen mode.
-
-Payload: none
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS
-
-#### onFullscreenPlayerWillDismiss
-Callback function that is called when the player is about to exit fullscreen mode.
-
-Payload: none
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS
-
-#### onFullscreenPlayerDidDismiss
-Callback function that is called when the player has exited fullscreen mode.
-
-Payload: none
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS
-
-#### onLoad
-Callback function that is called when the media is loaded and ready to play.
-
-Payload:
-
-Property | Type | Description
---- | --- | ---
-currentPosition | number | Time in seconds where the media will start
-duration | number | Length of the media in seconds
-naturalSize | object | Properties:<br> * width - Width in pixels that the video was encoded at<br> * height - Height in pixels that the video was encoded at<br> * orientation - "portrait" or "landscape"
-audioTracks | array | An array of audio track info objects with the following properties:<br> * index - Index number<br> * title - Description of the track<br> * language - 2 letter [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) or 3 letter [ISO639-2](https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes) language code<br> * type - Mime type of track
-textTracks | array | An array of text track info objects with the following properties:<br> * index - Index number<br> * title - Description of the track<br> * language - 2 letter [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) or 3 letter [ISO 639-2](https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes) language code<br> * type - Mime type of track
-videoTracks | array | An array of video track info objects with the following properties:<br> * trackId - ID for the track<br> * bitrate - Bit rate in bits per second<br> * codecs - Comma separated list of codecs<br> * height - Height of the video<br> * width - Width of the video
-
-Example:
-```
-{ 
-  canPlaySlowForward: true,
-  canPlayReverse: false,
-  canPlaySlowReverse: false,
-  canPlayFastForward: false,
-  canStepForward: false,
-  canStepBackward: false,
-  currentTime: 0,
-  duration: 5910.208984375,
-  naturalSize: {
-     height: 1080
-     orientation: 'landscape'
-     width: '1920'
-  },
-  audioTracks: [
-    { language: 'es', title: 'Spanish', type: 'audio/mpeg', index: 0 },
-    { language: 'en', title: 'English', type: 'audio/mpeg', index: 1 }
-  ],
-  textTracks: [
-    { title: '#1 French', language: 'fr', index: 0, type: 'text/vtt' },
-    { title: '#2 English CC', language: 'en', index: 1, type: 'text/vtt' },
-    { title: '#3 English Director Commentary', language: 'en', index: 2, type: 'text/vtt' }
-  ],
-  videoTracks: [
-    { bitrate: 3987904, codecs: "avc1.640028", height: 720, trackId: "f1-v1-x3", width: 1280 },
-    { bitrate: 7981888, codecs: "avc1.640028", height: 1080, trackId: "f2-v1-x3", width: 1920 },
-    { bitrate: 1994979, codecs: "avc1.4d401f", height: 480, trackId: "f3-v1-x3", width: 848 }
-  ]
-}
-```
-
-Platforms: all
-
-#### onLoadStart
-Callback function that is called when the media starts loading.
-
-Payload:
-
-Property | Description
---- | ---
-isNetwork | boolean | Boolean indicating if the media is being loaded from the network
-type | string | Type of the media. Not available on Windows
-uri | string | URI for the media source. Not available on Windows
-
-Example:
-```
-{
-  isNetwork: true,
-  type: '',
-  uri: 'https://bitdash-a.akamaihd.net/content/sintel/hls/playlist.m3u8'
-}
-```
-
-Platforms: all
-
-#### onReadyForDisplay
-Callback function that is called when the first video frame is ready for display. This is when the poster is removed.
-
-Payload: none
-
-* iOS: [readyForDisplay](https://developer.apple.com/documentation/avkit/avplayerviewcontroller/1615830-readyfordisplay?language=objc)
-* Android: [MEDIA_INFO_VIDEO_RENDERING_START](https://developer.android.com/reference/android/media/MediaPlayer#MEDIA_INFO_VIDEO_RENDERING_START)
-* Android ExoPlayer [STATE_READY](https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Player.html#STATE_READY)
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS, Web
-
-#### onPictureInPictureStatusChanged
-Callback function that is called when picture in picture becomes active or inactive.
-
-Property | Type | Description
---- | --- | ---
-isActive | boolean | Boolean indicating whether picture in picture is active
-
-Example:
-```
-{
-isActive: true
-}
-```
-
-Platforms:  iOS
-
-#### onPlaybackRateChange
-Callback function that is called when the rate of playback changes - either paused or starts/resumes.
-
-Property | Type | Description
---- | --- | ---
-playbackRate | number | 0 when playback is paused, 1 when playing at normal speed. Other values when playback is slowed down or sped up
-
-Example:
-```
-{
-  playbackRate: 0, // indicates paused
-}
-```
-
-Platforms: all
-
-
-#### onProgress
-Callback function that is called every progressUpdateInterval seconds with info about which position the media is currently playing.
-
-Property | Type | Description
---- | --- | ---
-currentTime | number | Current position in seconds
-playableDuration | number | Position to where the media can be played to using just the buffer in seconds
-seekableDuration | number | Position to where the media can be seeked to in seconds. Typically, the total length of the media
-
-Example:
-```
-{
-  currentTime: 5.2,
-  playableDuration: 34.6,
-  seekableDuration: 888
-}
-```
-
-Platforms: all
-
-#### onSeek
-Callback function that is called when a seek completes.
-
-Payload:
-
-Property | Type | Description
---- | --- | ---
-currentTime | number | The current time after the seek
-seekTime | number | The requested time
-
-Example:
-```
-{
-  currentTime: 100.5
-  seekTime: 100
-}
-```
-
-Both the currentTime & seekTime are reported because the video player may not seek to the exact requested position in order to improve seek performance.
-
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS, Windows UWP
-
-#### onRestoreUserInterfaceForPictureInPictureStop
-Callback function that corresponds to Apple's [`restoreUserInterfaceForPictureInPictureStopWithCompletionHandler`](https://developer.apple.com/documentation/avkit/avpictureinpicturecontrollerdelegate/1614703-pictureinpicturecontroller?language=objc). Call `restoreUserInterfaceForPictureInPictureStopCompleted` inside of this function when done restoring the user interface. 
-
-Payload: none
-
-Platforms: iOS
-
-#### onTimedMetadata
-Callback function that is called when timed metadata becomes available
-
-Payload:
-
-Property | Type | Description
---- | --- | ---
-metadata | array | Array of metadata objects
-
-Example:
-```
-{
-  metadata: [
-    { value: 'Streaming Encoder', identifier: 'TRSN' },
-    { value: 'Internet Stream', identifier: 'TRSO' },
-    { value: 'Any Time You Like', identifier: 'TIT2' }
-  ]
-}
-```
-
-Support for timed metadata on Android MediaPlayer is limited at best and only compatible with some videos. It requires a target SDK of 23 or higher.
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS
-
-### Methods
-Methods operate on a ref to the Video element. You can create a ref using code like:
-```
-return (
-  <Video source={...}
-    ref={ref => (this.player = ref)} />
-);
-```
-
-#### dismissFullscreenPlayer
-`dismissFullscreenPlayer()`
-
-Take the player out of fullscreen mode.
-
-Example:
-```
-this.player.dismissFullscreenPlayer();
-```
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS
-
-#### presentFullscreenPlayer
-`presentFullscreenPlayer()`
-
-Put the player in fullscreen mode.
-
-On iOS, this displays the video in a fullscreen view controller with controls.
-
-On Android ExoPlayer & MediaPlayer, this puts the navigation controls in fullscreen mode. It is not a complete fullscreen implementation, so you will still need to apply a style that makes the width and height match your screen dimensions to get a fullscreen video.
-
-Example:
-```
-this.player.presentFullscreenPlayer();
-```
-
-Platforms: Android ExoPlayer, Android MediaPlayer, iOS
-
-#### save
-`save(): Promise`
-
-Save video to your Photos with current filter prop. Returns promise.
-
-Example:
-```
-let response = await this.player.save();
-let path = response.uri;
-```
-
-Notes:
- - Currently only supports highest quality export
- - Currently only supports MP4 export
- - Currently only supports exporting to user's cache directory with a generated UUID filename. 
- - User will need to remove the saved video through their Photos app
- - Works with cached videos as well. (Checkout video-caching example)
- - If the video is has not began buffering (e.g. there is no internet connection) then the save function will throw an error.
- - If the video is buffering then the save function promise will return after the video has finished buffering and processing.
-
-Future: 
- - Will support multiple qualities through options
- - Will support more formats in the future through options
- - Will support custom directory and file name through options
-
-Platforms: iOS
-
-#### restoreUserInterfaceForPictureInPictureStopCompleted
-`restoreUserInterfaceForPictureInPictureStopCompleted(restored)`
-
-This function corresponds to the completion handler in Apple's [restoreUserInterfaceForPictureInPictureStop](https://developer.apple.com/documentation/avkit/avpictureinpicturecontrollerdelegate/1614703-pictureinpicturecontroller?language=objc). IMPORTANT: This function must be called after `onRestoreUserInterfaceForPictureInPictureStop` is called. 
-
-Example:
-```
-this.player.restoreUserInterfaceForPictureInPictureStopCompleted(true);
-```
-
-Platforms: iOS
-
-#### seek()
-`seek(seconds)`
-
-Seek to the specified position represented by seconds. seconds is a float value.
-
-`seek()` can only be called after the `onLoad` event has fired. Once completed, the [onSeek](#onseek) event will be called.
-
-Example:
-```
-this.player.seek(200); // Seek to 3 minutes, 20 seconds
-```
-
-Platforms: all
-
-##### Exact seek
-
-By default iOS seeks within 100 milliseconds of the target position. If you need more accuracy, you can use the seek with tolerance method:
-
-`seek(seconds, tolerance)`
-
-tolerance is the max distance in milliseconds from the seconds position that's allowed. Using a more exact tolerance can cause seeks to take longer. If you want to seek exactly, set tolerance to 0.
-
-Example:
-```
-this.player.seek(120, 50); // Seek to 2 minutes with +/- 50 milliseconds accuracy
-```
-
-Platforms: iOS
-
-
-
-
-### iOS App Transport Security
-
-- By default, iOS will only load encrypted (https) urls. If you want to load content from an unencrypted (http) source, you will need to modify your Info.plist file and add the following entry:
-
-<img src="./docs/AppTransportSecuritySetting.png" width="50%">
-
-For more detailed info check this [article](https://cocoacasts.com/how-to-add-app-transport-security-exception-domains)
-</details>
-
-### Audio Mixing
-
-At some point in the future, react-native-video will include an Audio Manager for configuring how videos mix with other apps playing sounds on the device.
-
-On iOS, if you would like to allow other apps to play music over your video component, make the following change:
-
-**AppDelegate.m**
-
-```objective-c
-#import <AVFoundation/AVFoundation.h>  // import
-
-- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
-{
-  ...
-  [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryAmbient error:nil];  // allow
-  ...
-}
-```
-
-You can also use the [ignoreSilentSwitch](#ignoresilentswitch) prop.
-</details>
-
-### Android Expansion File Usage
-Expansions files allow you to ship assets that exceed the 100MB apk size limit and don't need to be updated each time you push an app update.
-
-This only supports mp4 files and they must not be compressed. Example command line for preventing compression:
-```bash
-zip -r -n .mp4 *.mp4 player.video.example.com
-```
-
-```javascript
-// Within your render function, assuming you have a file called
-// "background.mp4" in your expansion file. Just add your main and (if applicable) patch version
-<Video source={{uri: "background", mainVer: 1, patchVer: 0}} // Looks for .mp4 file (background.mp4) in the given expansion version.
-       resizeMode="cover"           // Fill the whole screen at aspect ratio.
-       style={styles.backgroundVideo} />
-```
-
-### Load files with the RN Asset System
-
-The asset system [introduced in RN `0.14`](http://www.reactnative.com/react-native-v0-14-0-released/) allows loading image resources shared across iOS and Android without touching native code. As of RN `0.31` [the same is true](https://github.com/facebook/react-native/commit/91ff6868a554c4930fd5fda6ba8044dbd56c8374) of mp4 video assets for Android. As of [RN `0.33`](https://github.com/facebook/react-native/releases/tag/v0.33.0) iOS is also supported. Requires `react-native-video@0.9.0`.
-
-```javascript
-<Video
-  source={require('../assets/video/turntable.mp4')}
-/>
-```
-
-### Play in background on iOS
-
-To enable audio to play in background on iOS the audio session needs to be set to `AVAudioSessionCategoryPlayback`. See [Apple documentation][3] for additional details. (NOTE: there is now a ticket to [expose this as a prop]( https://github.com/react-native-community/react-native-video/issues/310) )
-
-## Examples
-
-- See an [Example integration][1] in `react-native-login` *note that this example uses an older version of this library, before we used `export default` -- if you use `require` you will need to do `require('react-native-video').default` as per instructions above.*
-- Try the included [VideoPlayer example][2] yourself:
-
-   ```sh
-   git clone git@github.com:react-native-community/react-native-video.git
-   cd react-native-video/example
-   npm install
-   open ios/VideoPlayer.xcodeproj
-
-   ```
-
-   Then `Cmd+R` to start the React Packager, build and run the project in the simulator.
-
-- [Lumpen Radio](https://github.com/jhabdas/lumpen-radio) contains another example integration using local files and full screen background video.
-
-## Updating
-
-### Version 5.0.0
-
-Probably you want to update your gradle version:
-#### gradle-wrapper.properties
-```diff
-- distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
-+ distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-all.zip
-```
-
-#### **android/app/build.gradle**
-
-From version >= 5.0.0, you have to apply this changes:
-
-```diff
-dependencies {
-   ...
-    compile project(':react-native-video')
-+   implementation "androidx.appcompat:appcompat:1.0.0"
--   implementation "com.android.support:appcompat-v7:${rootProject.ext.supportLibVersion}"
-
-}
-```
-
-#### **android/gradle.properties**
-
-Migrating to AndroidX (needs version >= 5.0.0):
-
-```gradle.properties
-android.useAndroidX=true
-android.enableJetifier=true
-```
-
-### Version 4.0.0
-
-#### Gradle 3 and target SDK 26 requirement
-In order to support ExoPlayer 2.9.0, you must use version 3 or higher of the Gradle plugin. This is included by default in React Native 0.57.
-
-#### ExoPlayer 2.9.0 Java 1.8 requirement
-ExoPlayer 2.9.0 uses some Java 1.8 features, so you may need to enable support for Java 1.8 in your app/build.gradle file. If you get an error, compiling with ExoPlayer like:
-`Default interface methods are only supported starting with Android N (--min-api 24)`
-
-Add the following to your app/build.gradle file:
-```
-android {
-   ... // Various other settings go here
-   compileOptions {
-     targetCompatibility JavaVersion.VERSION_1_8
-   }
-}
-```
-
-#### ExoPlayer no longer detaches
-When using a router like the react-navigation TabNavigator, switching between tab routes would previously cause ExoPlayer to detach causing the video player to pause. We now don't detach the view, allowing the video to continue playing in a background tab. This matches the behavior for iOS. Android MediaPlayer will crash if it detaches when switching routes, so its behavior has not been changed.
-
-#### useTextureView now defaults to true
-The SurfaceView, which ExoPlayer has been using by default has a number of quirks that people are unaware of and often cause issues. This includes not supporting animations or scaling. It also causes strange behavior if you overlay two videos on top of each other, because the SurfaceView will [punch a hole](https://developer.android.com/reference/android/view/SurfaceView) through other views. Since TextureView doesn't have these issues and behaves in the way most developers expect, it makes sense to make it the default.
-
-TextureView is not as fast as SurfaceView, so you may still want to enable SurfaceView support. To do this, you can set `useTextureView={false}`.
-
-
-### Version 3.0.0
-
-#### All platforms now auto-play
-Previously, on Android ExoPlayer if the paused prop was not set, the media would not automatically start playing. The only way it would work was if you set `paused={false}`. This has been changed to automatically play if paused is not set so that the behavior is consistent across platforms.
-
-#### All platforms now keep their paused state when returning from the background
-Previously, on Android MediaPlayer if you setup an AppState event when the app went into the background and set a paused prop so that when you returned to the app the video would be paused it would be ignored.
-
-Note, Windows does not have a concept of an app going into the background, so this doesn't apply there.
-
-#### Use Android target SDK 27 by default
-Version 3.0 updates the Android build tools and SDK to version 27. React Native is in the process of [switchting over](https://github.com/facebook/react-native/issues/18095#issuecomment-395596130) to SDK 27 in preparation for Google's requirement that new Android apps [use SDK 26](https://android-developers.googleblog.com/2017/12/improving-app-security-and-performance.html) by August 2018.
-
-You will either need to install the version 27 SDK and version 27.0.3 buildtools or modify your build.gradle file to configure react-native-video to use the same build settings as the rest of your app as described below.
-
-##### Using app build settings
-You will need to create a `project.ext` section in the top-level build.gradle file (not app/build.gradle). Fill in the values from the example below using the values found in your app/build.gradle file.
-```
-// Top-level build file where you can add configuration options common to all sub-projects/modules.
-
-buildscript {
-    ... // Various other settings go here
-}
-
-allprojects {
-    ... // Various other settings go here
-
-    project.ext {
-        compileSdkVersion = 23
-        buildToolsVersion = "23.0.1"
-
-        minSdkVersion = 16
-        targetSdkVersion = 22
-    }
-}
-```
-
-If you encounter an error `Could not find com.android.support:support-annotations:27.0.0.` reinstall your Android Support Repository.
-
-## TODOS
-
-- [ ] Add support for playing multiple videos in a sequence (will interfere with current `repeat` implementation)
-- [x] Callback to get buffering progress for remote videos
-- [ ] Bring API closer to HTML5 `<Video>` [reference](http://devdocs.io/html/element/video)
-
-[1]: https://github.com/brentvatne/react-native-login/blob/56c47a5d1e23781e86e19b27e10427fd6391f666/App/Screens/UserInfoScreen.js#L32-L35
-[2]: https://github.com/react-native-community/react-native-video/tree/master/example
-[3]: https://developer.apple.com/library/ios/qa/qa1668/_index.html
 
----
+## Useful resources
+- [Documentation](API.md)
+- [Changelog](CHANGELOG.md)
+- [Contribution guide](CONTRIBUTING.md)
+- [Usefull Side Project](./docs/PROJECTS.md)
+- [Advanced debugging](./docs/DEBUGGING.md)
 
-**MIT Licensed**
+**react-native-video** was originally created by [Brent Vatne](https://github.com/brentvatne)
diff --git a/node_modules/react-native-video/Video.js b/node_modules/react-native-video/Video.js
index a3452ad..da52d53 100644
--- a/node_modules/react-native-video/Video.js
+++ b/node_modules/react-native-video/Video.js
@@ -1,6 +1,6 @@
 import React, { Component } from 'react';
 import PropTypes from 'prop-types';
-import { StyleSheet, requireNativeComponent, NativeModules, View, Image, Platform, findNodeHandle } from 'react-native';
+import { StyleSheet, requireNativeComponent, NativeModules, UIManager, View, Image, Platform, findNodeHandle } from 'react-native';
 import { ViewPropTypes, ImagePropTypes } from 'deprecated-react-native-prop-types';
 import resolveAssetSource from 'react-native/Libraries/Image/resolveAssetSource';
 import TextTrackType from './TextTrackType';
@@ -14,7 +14,8 @@ const styles = StyleSheet.create({
   },
 });
 
-export { TextTrackType, FilterType, DRMType };
+const { VideoDecoderProperties } = NativeModules
+export { TextTrackType, FilterType, DRMType, VideoDecoderProperties }
 
 export default class Video extends Component {
 
@@ -76,7 +77,7 @@ export default class Video extends Component {
     this.setNativeProps({ fullscreen: false });
   };
 
-  save = async (options?) => {
+  save = async (options) => {
     return await NativeModules.VideoManager.save(options, findNodeHandle(this._root));
   }
 
@@ -100,6 +101,12 @@ export default class Video extends Component {
     }
   };
 
+  _onPlaybackStateChanged = (event) => {
+    if (this.props.onPlaybackStateChanged) {
+      this.props.onPlaybackStateChanged(event.nativeEvent);
+    }
+  };
+
   _onLoad = (event) => {
     // Need to hide poster here for windows as onReadyForDisplay is not implemented
     if (Platform.OS === 'windows') {
@@ -110,6 +117,24 @@ export default class Video extends Component {
     }
   };
 
+  _onAudioTracks = (event) => {
+    if (this.props.onAudioTracks) {
+      this.props.onAudioTracks(event.nativeEvent);
+    }
+  };
+
+  _onTextTracks = (event) => {
+    if (this.props.onTextTracks) {
+      this.props.onTextTracks(event.nativeEvent);
+    }
+  };
+
+  _onVideoTracks = (event) => {
+    if (this.props.onVideoTracks) {
+      this.props.onVideoTracks(event.nativeEvent);
+    }
+  };
+
   _onError = (event) => {
     if (this.props.onError) {
       this.props.onError(event.nativeEvent);
@@ -250,15 +275,22 @@ export default class Video extends Component {
           NativeModules.VideoManager.setLicenseError && NativeModules.VideoManager.setLicenseError(error, findNodeHandle(this._root));
         });
       } else {
-        NativeModules.VideoManager.setLicenseError && NativeModules.VideoManager.setLicenseError("No spc received", findNodeHandle(this._root));
+        NativeModules.VideoManager.setLicenseError && NativeModules.VideoManager.setLicenseError('No spc received', findNodeHandle(this._root));
       }
     }
   }
+
+  _onReceiveAdEvent = (event) => {
+    if (this.props.onReceiveAdEvent) {
+      this.props.onReceiveAdEvent(event.nativeEvent);
+    }
+  };
+
   getViewManagerConfig = viewManagerName => {
-    if (!NativeModules.UIManager.getViewManagerConfig) {
-      return NativeModules.UIManager[viewManagerName];
+    if (!UIManager.getViewManagerConfig) {
+      return UIManager[viewManagerName];
     }
-    return NativeModules.UIManager.getViewManagerConfig(viewManagerName);
+    return UIManager.getViewManagerConfig(viewManagerName);
   };
 
   render() {
@@ -272,11 +304,17 @@ export default class Video extends Component {
     }
 
     if (!uri) {
-      console.warn('Trying to load empty source.');
+      console.log('Trying to load empty source.');
     }
 
-    const isNetwork = !!(uri && uri.match(/^https?:/));
-    const isAsset = !!(uri && uri.match(/^(assets-library|ipod-library|file|content|ms-appx|ms-appdata):/));
+    const isNetwork = !!(uri && uri.match(/^https?:/i));
+    const isAsset = !!(uri && uri.match(/^(assets-library|ph|ipod-library|file|content|ms-appx|ms-appdata):/i));
+
+    if ((uri || uri === '') && !isNetwork && !isAsset) {
+      if (this.props.onError) {
+        this.props.onError({error: {errorString: 'invalid url, player will stop', errorCode: 'INVALID_URL'}});
+      }
+    }
 
     let nativeResizeMode;
     const RCTVideoInstance = this.getViewManagerConfig('RCTVideo');
@@ -304,9 +342,15 @@ export default class Video extends Component {
         mainVer: source.mainVer || 0,
         patchVer: source.patchVer || 0,
         requestHeaders: source.headers ? this.stringsOnlyObject(source.headers) : {},
+        startTime: source.startTime || 0,
+        endTime: source.endTime
       },
       onVideoLoadStart: this._onLoadStart,
+      onVideoPlaybackStateChanged: this._onPlaybackStateChanged,
       onVideoLoad: this._onLoad,
+      onAudioTracks: this._onAudioTracks,
+      onTextTracks: this._onTextTracks,
+      onVideoTracks: this._onVideoTracks,
       onVideoError: this._onError,
       onVideoProgress: this._onProgress,
       onVideoSeek: this._onSeek,
@@ -329,6 +373,7 @@ export default class Video extends Component {
       onGetLicense: nativeProps.drm && nativeProps.drm.getLicense && this._onGetLicense,
       onPictureInPictureStatusChanged: this._onPictureInPictureStatusChanged,
       onRestoreUserInterfaceForPictureInPictureStop: this._onRestoreUserInterfaceForPictureInPictureStop,
+      onReceiveAdEvent: this._onReceiveAdEvent,
     });
 
     const posterStyle = {
@@ -371,13 +416,6 @@ Video.propTypes = {
     FilterType.SEPIA,
   ]),
   filterEnabled: PropTypes.bool,
-  /* Native only */
-  src: PropTypes.object,
-  seek: PropTypes.oneOfType([
-    PropTypes.number,
-    PropTypes.object,
-  ]),
-  fullscreen: PropTypes.bool,
   onVideoLoadStart: PropTypes.func,
   onVideoLoad: PropTypes.func,
   onVideoBuffer: PropTypes.func,
@@ -404,7 +442,7 @@ Video.propTypes = {
   ]),
   drm: PropTypes.shape({
     type: PropTypes.oneOf([
-      DRMType.CLEARKEY, DRMType.FAIRPLAY, DRMType.WIDEVINE, DRMType.PLAYREADY
+      DRMType.CLEARKEY, DRMType.FAIRPLAY, DRMType.WIDEVINE, DRMType.PLAYREADY,
     ]),
     licenseServer: PropTypes.string,
     headers: PropTypes.shape({}),
@@ -412,6 +450,10 @@ Video.propTypes = {
     certificateUrl: PropTypes.string,
     getLicense: PropTypes.func,
   }),
+  videoOptions:PropTypes.shape({
+    title:PropTypes.string
+  }),
+  localSourceEncryptionKeyScheme: PropTypes.string,
   minLoadRetryCount: PropTypes.number,
   maxBitRate: PropTypes.number,
   resizeMode: PropTypes.string,
@@ -461,8 +503,8 @@ Video.propTypes = {
     maxBufferMs: PropTypes.number,
     bufferForPlaybackMs: PropTypes.number,
     bufferForPlaybackAfterRebufferMs: PropTypes.number,
+    maxHeapAllocationPercent: PropTypes.number,
   }),
-  stereoPan: PropTypes.number,
   rate: PropTypes.number,
   pictureInPicture: PropTypes.bool,
   playInBackground: PropTypes.bool,
@@ -470,17 +512,32 @@ Video.propTypes = {
   playWhenInactive: PropTypes.bool,
   ignoreSilentSwitch: PropTypes.oneOf(['ignore', 'obey']),
   reportBandwidth: PropTypes.bool,
+  contentStartTime: PropTypes.number,
   disableFocus: PropTypes.bool,
+  focusable: PropTypes.bool,
+  disableBuffering: PropTypes.bool,
   controls: PropTypes.bool,
   audioOnly: PropTypes.bool,
-  currentTime: PropTypes.number,
   fullscreenAutorotate: PropTypes.bool,
   fullscreenOrientation: PropTypes.oneOf(['all', 'landscape', 'portrait']),
   progressUpdateInterval: PropTypes.number,
+  subtitleStyle: PropTypes.shape({
+    paddingTop: PropTypes.number,
+    paddingBottom: PropTypes.number,
+    paddingLeft: PropTypes.number,
+    paddingRight: PropTypes.number,
+    fontSize: PropTypes.number,
+  }),
   useTextureView: PropTypes.bool,
+  useSecureView: PropTypes.bool,
   hideShutterView: PropTypes.bool,
+  shutterColor: PropTypes.string,
   onLoadStart: PropTypes.func,
+  onPlaybackStateChanged: PropTypes.func,
   onLoad: PropTypes.func,
+  onAudioTracks: PropTypes.func,
+  onTextTracks: PropTypes.func,
+  onVideoTracks: PropTypes.func,
   onBuffer: PropTypes.func,
   onError: PropTypes.func,
   onProgress: PropTypes.func,
@@ -498,22 +555,12 @@ Video.propTypes = {
   onAudioFocusChanged: PropTypes.func,
   onAudioBecomingNoisy: PropTypes.func,
   onPictureInPictureStatusChanged: PropTypes.func,
-  needsToRestoreUserInterfaceForPictureInPictureStop: PropTypes.func,
   onExternalPlaybackChange: PropTypes.func,
+  adTagUrl: PropTypes.string,
+  onReceiveAdEvent: PropTypes.func,
 
   /* Required by react-native */
-  scaleX: PropTypes.number,
-  scaleY: PropTypes.number,
-  translateX: PropTypes.number,
-  translateY: PropTypes.number,
-  rotation: PropTypes.number,
   ...ViewPropTypes,
 };
 
-const RCTVideo = requireNativeComponent('RCTVideo', Video, {
-  nativeOnly: {
-    src: true,
-    seek: true,
-    fullscreen: true,
-  },
-});
+const RCTVideo = requireNativeComponent('RCTVideo');
diff --git a/node_modules/react-native-video/android-exoplayer/build.gradle b/node_modules/react-native-video/android-exoplayer/build.gradle
deleted file mode 100644
index 6a9922b..0000000
--- a/node_modules/react-native-video/android-exoplayer/build.gradle
+++ /dev/null
@@ -1,45 +0,0 @@
-apply plugin: 'com.android.library'
-
-def safeExtGet(prop, fallback) {
-    rootProject.ext.has(prop) ? rootProject.ext.get(prop) : fallback
-}
-
-android {
-    compileSdkVersion safeExtGet('compileSdkVersion', 28)
-    buildToolsVersion safeExtGet('buildToolsVersion', '28.0.3')
-
-    compileOptions {
-        targetCompatibility JavaVersion.VERSION_1_8
-        sourceCompatibility JavaVersion.VERSION_1_8
-    }
-
-    defaultConfig {
-        minSdkVersion safeExtGet('minSdkVersion', 16)
-        targetSdkVersion safeExtGet('targetSdkVersion', 28)
-        versionCode 1
-        versionName "1.0"
-    }
-
-    compileOptions {
-        sourceCompatibility JavaVersion.VERSION_1_8
-        targetCompatibility JavaVersion.VERSION_1_8
-    }
-}
-
-dependencies {
-    implementation "com.facebook.react:react-native:${safeExtGet('reactNativeVersion', '+')}"
-    implementation('com.google.android.exoplayer:exoplayer:2.13.3') {
-        exclude group: 'com.android.support'
-    }
-
-    // All support libs must use the same version
-    implementation "androidx.annotation:annotation:1.1.0"
-    implementation "androidx.core:core:1.1.0"
-    implementation "androidx.media:media:1.1.0"
-
-    implementation('com.google.android.exoplayer:extension-okhttp:2.13.3') {
-        exclude group: 'com.squareup.okhttp3', module: 'okhttp'
-    }
-    implementation 'com.squareup.okhttp3:okhttp:${OKHTTP_VERSION}'
-
-}
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/AndroidManifest.xml b/node_modules/react-native-video/android-exoplayer/src/main/AndroidManifest.xml
deleted file mode 100644
index 3535ad4..0000000
--- a/node_modules/react-native-video/android-exoplayer/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,3 +0,0 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.brentvatne.react">
-</manifest>
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ReactExoplayerView.java b/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ReactExoplayerView.java
deleted file mode 100644
index fe95fdf..0000000
--- a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ReactExoplayerView.java
+++ /dev/null
@@ -1,1397 +0,0 @@
-package com.brentvatne.exoplayer;
-
-import android.annotation.SuppressLint;
-import android.app.Activity;
-import android.content.Context;
-import android.media.AudioManager;
-import android.net.Uri;
-import android.os.Handler;
-import android.os.Message;
-import android.text.TextUtils;
-import android.util.Log;
-import android.view.View;
-import android.view.Window;
-import android.view.accessibility.CaptioningManager;
-import android.widget.FrameLayout;
-import android.widget.ImageButton;
-
-import com.brentvatne.react.R;
-import com.brentvatne.receiver.AudioBecomingNoisyReceiver;
-import com.brentvatne.receiver.BecomingNoisyListener;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.Dynamic;
-import com.facebook.react.bridge.LifecycleEventListener;
-import com.facebook.react.bridge.ReadableArray;
-import com.facebook.react.bridge.ReadableMap;
-import com.facebook.react.bridge.WritableArray;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.ThemedReactContext;
-import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.DefaultLoadControl;
-import com.google.android.exoplayer2.DefaultRenderersFactory;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayerFactory;
-import com.google.android.exoplayer2.Format;
-import com.google.android.exoplayer2.PlaybackParameters;
-import com.google.android.exoplayer2.Player;
-import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
-import com.google.android.exoplayer2.drm.DrmSessionEventListener;
-import com.google.android.exoplayer2.drm.DrmSessionManager;
-import com.google.android.exoplayer2.drm.FrameworkMediaCrypto;
-import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
-import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
-import com.google.android.exoplayer2.drm.UnsupportedDrmException;
-import com.google.android.exoplayer2.mediacodec.MediaCodecRenderer;
-import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
-import com.google.android.exoplayer2.metadata.Metadata;
-import com.google.android.exoplayer2.metadata.MetadataOutput;
-import com.google.android.exoplayer2.source.BehindLiveWindowException;
-import com.google.android.exoplayer2.source.MediaSource;
-import com.google.android.exoplayer2.source.MergingMediaSource;
-import com.google.android.exoplayer2.source.ProgressiveMediaSource;
-import com.google.android.exoplayer2.source.SingleSampleMediaSource;
-import com.google.android.exoplayer2.source.TrackGroup;
-import com.google.android.exoplayer2.source.TrackGroupArray;
-import com.google.android.exoplayer2.source.dash.DashMediaSource;
-import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
-import com.google.android.exoplayer2.source.hls.HlsMediaSource;
-import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
-import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
-import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
-import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
-import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
-import com.google.android.exoplayer2.trackselection.ExoTrackSelection;
-import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
-import com.google.android.exoplayer2.ui.PlayerControlView;
-import com.google.android.exoplayer2.upstream.BandwidthMeter;
-import com.google.android.exoplayer2.upstream.DataSource;
-import com.google.android.exoplayer2.upstream.DefaultAllocator;
-import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
-import com.google.android.exoplayer2.upstream.HttpDataSource;
-import com.google.android.exoplayer2.util.Util;
-
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.CookiePolicy;
-import java.util.ArrayList;
-import java.util.Locale;
-import java.util.UUID;
-import java.util.Map;
-
-@SuppressLint("ViewConstructor")
-class ReactExoplayerView extends FrameLayout implements
-        LifecycleEventListener,
-        Player.EventListener,
-        BandwidthMeter.EventListener,
-        BecomingNoisyListener,
-        AudioManager.OnAudioFocusChangeListener,
-        MetadataOutput,
-        DrmSessionEventListener {
-
-    private static final String TAG = "ReactExoplayerView";
-
-    private static final CookieManager DEFAULT_COOKIE_MANAGER;
-    private static final int SHOW_PROGRESS = 1;
-
-    static {
-        DEFAULT_COOKIE_MANAGER = new CookieManager();
-        DEFAULT_COOKIE_MANAGER.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);
-    }
-
-    private final VideoEventEmitter eventEmitter;
-    private final ReactExoplayerConfig config;
-    private final DefaultBandwidthMeter bandwidthMeter;
-    private PlayerControlView playerControlView;
-    private View playPauseControlContainer;
-    private Player.EventListener eventListener;
-
-    private ExoPlayerView exoPlayerView;
-
-    private DataSource.Factory mediaDataSourceFactory;
-    private SimpleExoPlayer player;
-    private DefaultTrackSelector trackSelector;
-    private boolean playerNeedsSource;
-
-    private int resumeWindow;
-    private long resumePosition;
-    private boolean loadVideoStarted;
-    private boolean isFullscreen;
-    private boolean isInBackground;
-    private boolean isPaused;
-    private boolean isBuffering;
-    private boolean muted = false;
-    private boolean hasAudioFocus = false;
-    private float rate = 1f;
-    private float audioVolume = 1f;
-    private int minLoadRetryCount = 3;
-    private int maxBitRate = 0;
-    private long seekTime = C.TIME_UNSET;
-
-    private int minBufferMs = DefaultLoadControl.DEFAULT_MIN_BUFFER_MS;
-    private int maxBufferMs = DefaultLoadControl.DEFAULT_MAX_BUFFER_MS;
-    private int bufferForPlaybackMs = DefaultLoadControl.DEFAULT_BUFFER_FOR_PLAYBACK_MS;
-    private int bufferForPlaybackAfterRebufferMs = DefaultLoadControl.DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS;
-
-    private Handler mainHandler;
-
-    // Props from React
-    private Uri srcUri;
-    private String extension;
-    private boolean repeat;
-    private String audioTrackType;
-    private Dynamic audioTrackValue;
-    private String videoTrackType;
-    private Dynamic videoTrackValue;
-    private String textTrackType;
-    private Dynamic textTrackValue;
-    private ReadableArray textTracks;
-    private boolean disableFocus;
-    private boolean preventsDisplaySleepDuringVideoPlayback = true;
-    private float mProgressUpdateInterval = 250.0f;
-    private boolean playInBackground = false;
-    private Map<String, String> requestHeaders;
-    private boolean mReportBandwidth = false;
-    private UUID drmUUID = null;
-    private String drmLicenseUrl = null;
-    private String[] drmLicenseHeader = null;
-    private boolean controls;
-    // \ End props
-
-    // React
-    private final ThemedReactContext themedReactContext;
-    private final AudioManager audioManager;
-    private final AudioBecomingNoisyReceiver audioBecomingNoisyReceiver;
-
-    private final Handler progressHandler = new Handler() {
-        @Override
-        public void handleMessage(Message msg) {
-            switch (msg.what) {
-                case SHOW_PROGRESS:
-                    if (player != null
-                            && player.getPlaybackState() == Player.STATE_READY
-                            && player.getPlayWhenReady()
-                            ) {
-                        long pos = player.getCurrentPosition();
-                        long bufferedDuration = player.getBufferedPercentage() * player.getDuration() / 100;
-                        eventEmitter.progressChanged(pos, bufferedDuration, player.getDuration(), getPositionInFirstPeriodMsForCurrentWindow(pos));
-                        msg = obtainMessage(SHOW_PROGRESS);
-                        sendMessageDelayed(msg, Math.round(mProgressUpdateInterval));
-                    }
-                    break;
-            }
-        }
-    };
-    
-    public double getPositionInFirstPeriodMsForCurrentWindow(long currentPosition) {
-        Timeline.Window window = new Timeline.Window();
-        if(!player.getCurrentTimeline().isEmpty()) {    
-            player.getCurrentTimeline().getWindow(player.getCurrentWindowIndex(), window);
-        }
-        return window.windowStartTimeMs + currentPosition;
-    }
-
-    public ReactExoplayerView(ThemedReactContext context, ReactExoplayerConfig config) {
-        super(context);
-        this.themedReactContext = context;
-        this.eventEmitter = new VideoEventEmitter(context);
-        this.config = config;
-        this.bandwidthMeter = config.getBandwidthMeter();
-
-        createViews();
-
-        audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
-        themedReactContext.addLifecycleEventListener(this);
-        audioBecomingNoisyReceiver = new AudioBecomingNoisyReceiver(themedReactContext);
-    }
-
-
-    @Override
-    public void setId(int id) {
-        super.setId(id);
-        eventEmitter.setViewId(id);
-    }
-
-    private void createViews() {
-        clearResumePosition();
-        mediaDataSourceFactory = buildDataSourceFactory(true);
-        if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
-            CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
-        }
-
-        LayoutParams layoutParams = new LayoutParams(
-                LayoutParams.MATCH_PARENT,
-                LayoutParams.MATCH_PARENT);
-        exoPlayerView = new ExoPlayerView(getContext());
-        exoPlayerView.setLayoutParams(layoutParams);
-
-        addView(exoPlayerView, 0, layoutParams);
-
-        mainHandler = new Handler();
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        initializePlayer();
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-        /* We want to be able to continue playing audio when switching tabs.
-         * Leave this here in case it causes issues.
-         */
-        // stopPlayback();
-    }
-
-    // LifecycleEventListener implementation
-
-    @Override
-    public void onHostResume() {
-        if (!playInBackground || !isInBackground) {
-            setPlayWhenReady(!isPaused);
-        }
-        isInBackground = false;
-    }
-
-    @Override
-    public void onHostPause() {
-        isInBackground = true;
-        if (playInBackground) {
-            return;
-        }
-        setPlayWhenReady(false);
-    }
-
-    @Override
-    public void onHostDestroy() {
-        stopPlayback();
-    }
-
-    public void cleanUpResources() {
-        stopPlayback();
-    }
-
-    //BandwidthMeter.EventListener implementation
-    @Override
-    public void onBandwidthSample(int elapsedMs, long bytes, long bitrate) {
-        if (mReportBandwidth) {
-            if (player == null) {
-                eventEmitter.bandwidthReport(bitrate, 0, 0, "-1");
-            } else {
-                Format videoFormat = player.getVideoFormat();
-                int width = videoFormat != null ? videoFormat.width : 0;
-                int height = videoFormat != null ? videoFormat.height : 0;
-                String trackId = videoFormat != null ? videoFormat.id : "-1";
-                eventEmitter.bandwidthReport(bitrate, height, width, trackId);
-            }
-        }
-    }
-
-    // Internal methods
-
-    /**
-     * Toggling the visibility of the player control view
-     */
-    private void togglePlayerControlVisibility() {
-        if(player == null) return;
-        reLayout(playerControlView);
-        if (playerControlView.isVisible()) {
-            playerControlView.hide();
-        } else {
-            playerControlView.show();
-        }
-    }
-
-    /**
-     * Initializing Player control
-     */
-    private void initializePlayerControl() {
-        if (playerControlView == null) {
-            playerControlView = new PlayerControlView(getContext());
-        }
-
-        // Setting the player for the playerControlView
-        playerControlView.setPlayer(player);
-        playerControlView.show();
-        playPauseControlContainer = playerControlView.findViewById(R.id.exo_play_pause_container);
-
-        // Invoking onClick event for exoplayerView
-        exoPlayerView.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                togglePlayerControlVisibility();
-            }
-        });
-
-        //Handling the playButton click event
-        ImageButton playButton = playerControlView.findViewById(R.id.exo_play);
-        playButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                if (player != null && player.getPlaybackState() == Player.STATE_ENDED) {
-                    player.seekTo(0);
-                }
-                setPausedModifier(false);
-            }
-        });
-
-        //Handling the pauseButton click event
-        ImageButton pauseButton = playerControlView.findViewById(R.id.exo_pause);
-        pauseButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                setPausedModifier(true);
-            }
-        });
-
-        // Invoking onPlayerStateChanged event for Player
-        eventListener = new Player.EventListener() {
-            @Override
-            public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-                reLayout(playPauseControlContainer);
-                //Remove this eventListener once its executed. since UI will work fine once after the reLayout is done
-                player.removeListener(eventListener);
-            }
-        };
-        player.addListener(eventListener);
-    }
-
-    /**
-     * Adding Player control to the frame layout
-     */
-    private void addPlayerControl() {
-        if(player == null) return;
-        LayoutParams layoutParams = new LayoutParams(
-                LayoutParams.MATCH_PARENT,
-                LayoutParams.MATCH_PARENT);
-        playerControlView.setLayoutParams(layoutParams);
-        int indexOfPC = indexOfChild(playerControlView);
-        if (indexOfPC != -1) {
-            removeViewAt(indexOfPC);
-        }
-        addView(playerControlView, 1, layoutParams);
-    }
-
-    /**
-     * Update the layout
-     * @param view  view needs to update layout
-     *
-     * This is a workaround for the open bug in react-native: https://github.com/facebook/react-native/issues/17968
-     */
-    private void reLayout(View view) {
-        if (view == null) return;
-        view.measure(MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
-                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
-        view.layout(view.getLeft(), view.getTop(), view.getMeasuredWidth(), view.getMeasuredHeight());
-    }
-
-    private void initializePlayer() {
-        ReactExoplayerView self = this;
-        // This ensures all props have been settled, to avoid async racing conditions.
-        new Handler().postDelayed(new Runnable() {
-            @Override
-            public void run() {
-                if (player == null) {
-                    ExoTrackSelection.Factory videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory();
-                    trackSelector = new DefaultTrackSelector(videoTrackSelectionFactory);
-                    trackSelector.setParameters(trackSelector.buildUponParameters()
-                            .setMaxVideoBitrate(maxBitRate == 0 ? Integer.MAX_VALUE : maxBitRate));
-
-                    DefaultAllocator allocator = new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE);
-                    DefaultLoadControl.Builder defaultLoadControlBuilder = new DefaultLoadControl.Builder();
-                    defaultLoadControlBuilder.setAllocator(allocator);
-                    defaultLoadControlBuilder.setBufferDurationsMs(minBufferMs, maxBufferMs, bufferForPlaybackMs, bufferForPlaybackAfterRebufferMs);
-                    defaultLoadControlBuilder.setTargetBufferBytes(-1);
-                    defaultLoadControlBuilder.setPrioritizeTimeOverSizeThresholds(true);
-                    DefaultLoadControl defaultLoadControl = defaultLoadControlBuilder.createDefaultLoadControl();
-                    DefaultRenderersFactory renderersFactory =
-                            new DefaultRenderersFactory(getContext())
-                                    .setExtensionRendererMode(DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF);
-                    player = new SimpleExoPlayer.Builder(getContext(), renderersFactory)
-                                .setTrackSelector​(trackSelector)
-                                .setBandwidthMeter(bandwidthMeter)
-                                .setLoadControl(defaultLoadControl)
-                                .build();
-                    player.addListener(self);
-                    player.addMetadataOutput(self);
-                    exoPlayerView.setPlayer(player);
-                    audioBecomingNoisyReceiver.setListener(self);
-                    bandwidthMeter.addEventListener(new Handler(), self);
-                    setPlayWhenReady(!isPaused);
-                    playerNeedsSource = true;
-
-                    PlaybackParameters params = new PlaybackParameters(rate, 1f);
-                    player.setPlaybackParameters(params);
-                }
-                if (playerNeedsSource && srcUri != null) {
-                    exoPlayerView.invalidateAspectRatio();
-
-                    // DRM
-                    DrmSessionManager drmSessionManager = null;
-                    if (self.drmUUID != null) {
-                        try {
-                            drmSessionManager = buildDrmSessionManager(self.drmUUID, self.drmLicenseUrl,
-                                    self.drmLicenseHeader);
-                        } catch (UnsupportedDrmException e) {
-                            int errorStringId = Util.SDK_INT < 18 ? R.string.error_drm_not_supported
-                                    : (e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
-                                    ? R.string.error_drm_unsupported_scheme : R.string.error_drm_unknown);
-                            eventEmitter.error(getResources().getString(errorStringId), e);
-                            return;
-                        }
-                    }
-                    // End DRM
-
-                    ArrayList<MediaSource> mediaSourceList = buildTextSources();
-                    MediaSource videoSource = buildMediaSource(srcUri, extension, drmSessionManager);
-                    MediaSource mediaSource;
-                    if (mediaSourceList.size() == 0) {
-                        mediaSource = videoSource;
-                    } else {
-                        mediaSourceList.add(0, videoSource);
-                        MediaSource[] textSourceArray = mediaSourceList.toArray(
-                                new MediaSource[mediaSourceList.size()]
-                        );
-                        mediaSource = new MergingMediaSource(textSourceArray);
-                    }
-
-                    boolean haveResumePosition = resumeWindow != C.INDEX_UNSET;
-                    if (haveResumePosition) {
-                        player.seekTo(resumeWindow, resumePosition);
-                    }
-                    player.prepare(mediaSource, !haveResumePosition, false);
-                    playerNeedsSource = false;
-
-                    reLayout(exoPlayerView);
-                    eventEmitter.loadStart();
-                    loadVideoStarted = true;
-                }
-
-                // Initializing the playerControlView
-                initializePlayerControl();
-                setControls(controls);
-                applyModifiers();
-            }
-        }, 1);
-    }
-
-    private DrmSessionManager buildDrmSessionManager(UUID uuid,
-                                                                           String licenseUrl, String[] keyRequestPropertiesArray) throws UnsupportedDrmException {
-        if (Util.SDK_INT < 18) {
-            return null;
-        }
-        HttpMediaDrmCallback drmCallback = new HttpMediaDrmCallback(licenseUrl,
-                buildHttpDataSourceFactory(false));
-        if (keyRequestPropertiesArray != null) {
-            for (int i = 0; i < keyRequestPropertiesArray.length - 1; i += 2) {
-                drmCallback.setKeyRequestProperty(keyRequestPropertiesArray[i],
-                        keyRequestPropertiesArray[i + 1]);
-            }
-        }
-        return new DefaultDrmSessionManager(uuid,
-                FrameworkMediaDrm.newInstance(uuid), drmCallback, null, false, 3);
-    }
-
-    private MediaSource buildMediaSource(Uri uri, String overrideExtension, DrmSessionManager drmSessionManager) {
-        int type = Util.inferContentType(!TextUtils.isEmpty(overrideExtension) ? "." + overrideExtension
-                : uri.getLastPathSegment());
-        switch (type) {
-            case C.TYPE_SS:
-                return new SsMediaSource.Factory(
-                        new DefaultSsChunkSource.Factory(mediaDataSourceFactory),
-                        buildDataSourceFactory(false)
-                ).setDrmSessionManager(drmSessionManager)
-                 .setLoadErrorHandlingPolicy(
-                        config.buildLoadErrorHandlingPolicy(minLoadRetryCount)
-                ).createMediaSource(uri);
-            case C.TYPE_DASH:
-                return new DashMediaSource.Factory(
-                        new DefaultDashChunkSource.Factory(mediaDataSourceFactory),
-                        buildDataSourceFactory(false)
-                ).setDrmSessionManager(drmSessionManager)
-                 .setLoadErrorHandlingPolicy(
-                        config.buildLoadErrorHandlingPolicy(minLoadRetryCount)
-                ).createMediaSource(uri);
-            case C.TYPE_HLS:
-                return new HlsMediaSource.Factory(
-                        mediaDataSourceFactory
-                ).setDrmSessionManager(drmSessionManager)
-                 .setLoadErrorHandlingPolicy(
-                        config.buildLoadErrorHandlingPolicy(minLoadRetryCount)
-                ).createMediaSource(uri);
-            case C.TYPE_OTHER:
-                return new ProgressiveMediaSource.Factory(
-                        mediaDataSourceFactory
-                ).setDrmSessionManager(drmSessionManager)
-                 .setLoadErrorHandlingPolicy(
-                        config.buildLoadErrorHandlingPolicy(minLoadRetryCount)
-                ).createMediaSource(uri);
-            default: {
-                throw new IllegalStateException("Unsupported type: " + type);
-            }
-        }
-    }
-
-    private ArrayList<MediaSource> buildTextSources() {
-        ArrayList<MediaSource> textSources = new ArrayList<>();
-        if (textTracks == null) {
-            return textSources;
-        }
-
-        for (int i = 0; i < textTracks.size(); ++i) {
-            ReadableMap textTrack = textTracks.getMap(i);
-            String language = textTrack.getString("language");
-            String title = textTrack.hasKey("title")
-                    ? textTrack.getString("title") : language + " " + i;
-            Uri uri = Uri.parse(textTrack.getString("uri"));
-            MediaSource textSource = buildTextSource(title, uri, textTrack.getString("type"),
-                    language);
-            if (textSource != null) {
-                textSources.add(textSource);
-            }
-        }
-        return textSources;
-    }
-
-    private MediaSource buildTextSource(String title, Uri uri, String mimeType, String language) {
-        Format textFormat = Format.createTextSampleFormat(title, mimeType, Format.NO_VALUE, language);
-        return new SingleSampleMediaSource.Factory(mediaDataSourceFactory)
-                .createMediaSource(uri, textFormat, C.TIME_UNSET);
-    }
-
-    private void releasePlayer() {
-        if (player != null) {
-            updateResumePosition();
-            player.release();
-            player.removeMetadataOutput(this);
-            trackSelector = null;
-            player = null;
-        }
-        progressHandler.removeMessages(SHOW_PROGRESS);
-        themedReactContext.removeLifecycleEventListener(this);
-        audioBecomingNoisyReceiver.removeListener();
-        bandwidthMeter.removeEventListener(this);
-    }
-
-    private boolean requestAudioFocus() {
-        if (disableFocus || srcUri == null || this.hasAudioFocus) {
-            return true;
-        }
-        int result = audioManager.requestAudioFocus(this,
-                AudioManager.STREAM_MUSIC,
-                AudioManager.AUDIOFOCUS_GAIN);
-        return result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
-    }
-
-    private void setPlayWhenReady(boolean playWhenReady) {
-        if (player == null) {
-            return;
-        }
-
-        if (playWhenReady) {
-            this.hasAudioFocus = requestAudioFocus();
-            if (this.hasAudioFocus) {
-                player.setPlayWhenReady(true);
-            }
-        } else {
-            player.setPlayWhenReady(false);
-        }
-    }
-
-    private void startPlayback() {
-        if (player != null) {
-            switch (player.getPlaybackState()) {
-                case Player.STATE_IDLE:
-                case Player.STATE_ENDED:
-                    initializePlayer();
-                    break;
-                case Player.STATE_BUFFERING:
-                case Player.STATE_READY:
-                    if (!player.getPlayWhenReady()) {
-                        setPlayWhenReady(true);
-                    }
-                    break;
-                default:
-                    break;
-            }
-
-        } else {
-            initializePlayer();
-        }
-        if (!disableFocus) {
-            setKeepScreenOn(preventsDisplaySleepDuringVideoPlayback);
-        }
-    }
-
-    private void pausePlayback() {
-        if (player != null) {
-            if (player.getPlayWhenReady()) {
-                setPlayWhenReady(false);
-            }
-        }
-        setKeepScreenOn(false);
-    }
-
-    private void stopPlayback() {
-        onStopPlayback();
-        releasePlayer();
-    }
-
-    private void onStopPlayback() {
-        if (isFullscreen) {
-            setFullscreen(false);
-        }
-        audioManager.abandonAudioFocus(this);
-    }
-
-    private void updateResumePosition() {
-        resumeWindow = player.getCurrentWindowIndex();
-        resumePosition = player.isCurrentWindowSeekable() ? Math.max(0, player.getCurrentPosition())
-                : C.TIME_UNSET;
-    }
-
-    private void clearResumePosition() {
-        resumeWindow = C.INDEX_UNSET;
-        resumePosition = C.TIME_UNSET;
-    }
-
-    /**
-     * Returns a new DataSource factory.
-     *
-     * @param useBandwidthMeter Whether to set {@link #bandwidthMeter} as a listener to the new
-     *                          DataSource factory.
-     * @return A new DataSource factory.
-     */
-    private DataSource.Factory buildDataSourceFactory(boolean useBandwidthMeter) {
-        return DataSourceUtil.getDefaultDataSourceFactory(this.themedReactContext,
-                useBandwidthMeter ? bandwidthMeter : null, requestHeaders);
-    }
-
-    /**
-     * Returns a new HttpDataSource factory.
-     *
-     * @param useBandwidthMeter Whether to set {@link #bandwidthMeter} as a listener to the new
-     *     DataSource factory.
-     * @return A new HttpDataSource factory.
-     */
-    private HttpDataSource.Factory buildHttpDataSourceFactory(boolean useBandwidthMeter) {
-        return DataSourceUtil.getDefaultHttpDataSourceFactory(this.themedReactContext, useBandwidthMeter ? bandwidthMeter : null, requestHeaders);
-    }
-
-
-    // AudioManager.OnAudioFocusChangeListener implementation
-
-    @Override
-    public void onAudioFocusChange(int focusChange) {
-        switch (focusChange) {
-            case AudioManager.AUDIOFOCUS_LOSS:
-                this.hasAudioFocus = false;
-                eventEmitter.audioFocusChanged(false);
-                pausePlayback();
-                audioManager.abandonAudioFocus(this);
-                break;
-            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
-                eventEmitter.audioFocusChanged(false);
-                break;
-            case AudioManager.AUDIOFOCUS_GAIN:
-                this.hasAudioFocus = true;
-                eventEmitter.audioFocusChanged(true);
-                break;
-            default:
-                break;
-        }
-
-        if (player != null) {
-            if (focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK) {
-                // Lower the volume
-                if (!muted) {
-                    player.setVolume(audioVolume * 0.8f);
-                }
-            } else if (focusChange == AudioManager.AUDIOFOCUS_GAIN) {
-                // Raise it back to normal
-                if (!muted) {
-                    player.setVolume(audioVolume * 1);
-                }
-            }
-        }
-    }
-
-    // AudioBecomingNoisyListener implementation
-
-    @Override
-    public void onAudioBecomingNoisy() {
-        eventEmitter.audioBecomingNoisy();
-    }
-
-    // Player.EventListener implementation
-
-    @Override
-    public void onLoadingChanged(boolean isLoading) {
-        // Do nothing.
-    }
-
-    @Override
-    public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
-        String text = "onStateChanged: playWhenReady=" + playWhenReady + ", playbackState=";
-        switch (playbackState) {
-            case Player.STATE_IDLE:
-                text += "idle";
-                eventEmitter.idle();
-                clearProgressMessageHandler();
-                if (!playWhenReady) {
-                    setKeepScreenOn(false);
-                }
-                break;
-            case Player.STATE_BUFFERING:
-                text += "buffering";
-                onBuffering(true);
-                clearProgressMessageHandler();
-                setKeepScreenOn(preventsDisplaySleepDuringVideoPlayback);
-                break;
-            case Player.STATE_READY:
-                text += "ready";
-                eventEmitter.ready();
-                onBuffering(false);
-                startProgressHandler();
-                videoLoaded();
-                // Setting the visibility for the playerControlView
-                if (playerControlView != null) {
-                    playerControlView.show();
-                }
-                setKeepScreenOn(preventsDisplaySleepDuringVideoPlayback);
-                break;
-            case Player.STATE_ENDED:
-                text += "ended";
-                eventEmitter.end();
-                onStopPlayback();
-                setKeepScreenOn(false);
-                break;
-            default:
-                text += "unknown";
-                break;
-        }
-        Log.d(TAG, text);
-    }
-
-    private void startProgressHandler() {
-        progressHandler.sendEmptyMessage(SHOW_PROGRESS);
-    }
-
-    /*
-        The progress message handler will duplicate recursions of the onProgressMessage handler
-        on change of player state from any state to STATE_READY with playWhenReady is true (when
-        the video is not paused). This clears all existing messages.
-     */
-    private void clearProgressMessageHandler() {
-         progressHandler.removeMessages(SHOW_PROGRESS);
-    }
-
-    private void videoLoaded() {
-        if (loadVideoStarted) {
-            loadVideoStarted = false;
-            setSelectedAudioTrack(audioTrackType, audioTrackValue);
-            setSelectedVideoTrack(videoTrackType, videoTrackValue);
-            setSelectedTextTrack(textTrackType, textTrackValue);
-            Format videoFormat = player.getVideoFormat();
-            int width = videoFormat != null ? videoFormat.width : 0;
-            int height = videoFormat != null ? videoFormat.height : 0;
-            String trackId = videoFormat != null ? videoFormat.id : "-1";
-            eventEmitter.load(player.getDuration(), player.getCurrentPosition(), width, height,
-                    getAudioTrackInfo(), getTextTrackInfo(), getVideoTrackInfo(), trackId);
-        }
-    }
-
-    private WritableArray getAudioTrackInfo() {
-        WritableArray audioTracks = Arguments.createArray();
-
-        MappingTrackSelector.MappedTrackInfo info = trackSelector.getCurrentMappedTrackInfo();
-        int index = getTrackRendererIndex(C.TRACK_TYPE_AUDIO);
-        if (info == null || index == C.INDEX_UNSET) {
-            return audioTracks;
-        }
-
-        TrackGroupArray groups = info.getTrackGroups(index);
-        for (int i = 0; i < groups.length; ++i) {
-            Format format = groups.get(i).getFormat(0);
-            WritableMap audioTrack = Arguments.createMap();
-            audioTrack.putInt("index", i);
-            audioTrack.putString("title", format.id != null ? format.id : "");
-            audioTrack.putString("type", format.sampleMimeType);
-            audioTrack.putString("language", format.language != null ? format.language : "");
-            audioTrack.putString("bitrate", format.bitrate == Format.NO_VALUE ? ""
-                                    : String.format(Locale.US, "%.2fMbps", format.bitrate / 1000000f));
-            audioTracks.pushMap(audioTrack);
-        }
-        return audioTracks;
-    }
-    private WritableArray getVideoTrackInfo() {
-        WritableArray videoTracks = Arguments.createArray();
-
-        MappingTrackSelector.MappedTrackInfo info = trackSelector.getCurrentMappedTrackInfo();
-        int index = getTrackRendererIndex(C.TRACK_TYPE_VIDEO);
-        if (info == null || index == C.INDEX_UNSET) {
-            return videoTracks;
-        }
-
-        TrackGroupArray groups = info.getTrackGroups(index);
-        for (int i = 0; i < groups.length; ++i) {
-            TrackGroup group = groups.get(i);
-
-            for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
-                Format format = group.getFormat(trackIndex);
-                WritableMap videoTrack = Arguments.createMap();
-                videoTrack.putInt("width", format.width == Format.NO_VALUE ? 0 : format.width);
-                videoTrack.putInt("height",format.height == Format.NO_VALUE ? 0 : format.height);
-                videoTrack.putInt("bitrate", format.bitrate == Format.NO_VALUE ? 0 : format.bitrate);
-                videoTrack.putString("codecs", format.codecs != null ? format.codecs : "");
-                videoTrack.putString("trackId",
-                        format.id == null ? String.valueOf(trackIndex) : format.id);
-                videoTracks.pushMap(videoTrack);
-            }
-        }
-        return videoTracks;
-    }
-
-    private WritableArray getTextTrackInfo() {
-        WritableArray textTracks = Arguments.createArray();
-
-        MappingTrackSelector.MappedTrackInfo info = trackSelector.getCurrentMappedTrackInfo();
-        int index = getTrackRendererIndex(C.TRACK_TYPE_TEXT);
-        if (info == null || index == C.INDEX_UNSET) {
-            return textTracks;
-        }
-
-        TrackGroupArray groups = info.getTrackGroups(index);
-        for (int i = 0; i < groups.length; ++i) {
-             Format format = groups.get(i).getFormat(0);
-             WritableMap textTrack = Arguments.createMap();
-             textTrack.putInt("index", i);
-             textTrack.putString("title", format.id != null ? format.id : "");
-             textTrack.putString("type", format.sampleMimeType);
-             textTrack.putString("language", format.language != null ? format.language : "");
-             textTracks.pushMap(textTrack);
-        }
-        return textTracks;
-    }
-
-    private void onBuffering(boolean buffering) {
-        if (isBuffering == buffering) {
-            return;
-        }
-
-        isBuffering = buffering;
-        if (buffering) {
-            eventEmitter.buffering(true);
-        } else {
-            eventEmitter.buffering(false);
-        }
-    }
-
-    @Override
-    public void onPositionDiscontinuity(int reason) {
-        if (playerNeedsSource) {
-            // This will only occur if the user has performed a seek whilst in the error state. Update the
-            // resume position so that if the user then retries, playback will resume from the position to
-            // which they seeked.
-            updateResumePosition();
-        }
-        // When repeat is turned on, reaching the end of the video will not cause a state change
-        // so we need to explicitly detect it.
-        if (reason == Player.DISCONTINUITY_REASON_PERIOD_TRANSITION
-                && player.getRepeatMode() == Player.REPEAT_MODE_ONE) {
-            eventEmitter.end();
-        }
-    }
-
-    @Override
-    public void onTimelineChanged(Timeline timeline, Object manifest, int reason) {
-        // Do nothing.
-    }
-
-    @Override
-    public void onSeekProcessed() {
-        eventEmitter.seek(player.getCurrentPosition(), seekTime);
-        seekTime = C.TIME_UNSET;
-    }
-
-    @Override
-    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
-        // Do nothing.
-    }
-
-    @Override
-    public void onRepeatModeChanged(int repeatMode) {
-        // Do nothing.
-    }
-
-    @Override
-    public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-        // Do Nothing.
-    }
-
-    @Override
-    public void onPlaybackParametersChanged(PlaybackParameters params) {
-        eventEmitter.playbackRateChange(params.speed);
-    }
-
-    @Override
-    public void onPlayerError(ExoPlaybackException e) {
-        String errorString = "ExoPlaybackException type : " + e.type;
-        Exception ex = e;
-        if (e.type == ExoPlaybackException.TYPE_RENDERER) {
-            Exception cause = e.getRendererException();
-            if (cause instanceof MediaCodecRenderer.DecoderInitializationException) {
-                // Special case for decoder initialization failures.
-                MediaCodecRenderer.DecoderInitializationException decoderInitializationException =
-                        (MediaCodecRenderer.DecoderInitializationException) cause;
-                if (decoderInitializationException.codecInfo.name == null) {
-                    if (decoderInitializationException.getCause() instanceof MediaCodecUtil.DecoderQueryException) {
-                        errorString = getResources().getString(R.string.error_querying_decoders);
-                    } else if (decoderInitializationException.secureDecoderRequired) {
-                        errorString = getResources().getString(R.string.error_no_secure_decoder,
-                                decoderInitializationException.mimeType);
-                    } else {
-                        errorString = getResources().getString(R.string.error_no_decoder,
-                                decoderInitializationException.mimeType);
-                    }
-                } else {
-                    errorString = getResources().getString(R.string.error_instantiating_decoder,
-                            decoderInitializationException.codecInfo.name);
-                }
-            }
-        }
-        else if (e.type == ExoPlaybackException.TYPE_SOURCE) {
-            errorString = getResources().getString(R.string.unrecognized_media_format);
-        }
-        eventEmitter.error(errorString, ex);
-        playerNeedsSource = true;
-        if (isBehindLiveWindow(e)) {
-            clearResumePosition();
-            initializePlayer();
-        } else {
-            updateResumePosition();
-        }
-    }
-
-    private static boolean isBehindLiveWindow(ExoPlaybackException e) {
-        Log.e("ExoPlayer Exception", e.toString());
-        if (e.type != ExoPlaybackException.TYPE_SOURCE) {
-            return false;
-        }
-        Throwable cause = e.getSourceException();
-        while (cause != null) {
-            if (cause instanceof BehindLiveWindowException ||
-                    cause instanceof HttpDataSource.HttpDataSourceException) {
-                return true;
-            }
-            cause = cause.getCause();
-        }
-        return false;
-    }
-
-    public int getTrackRendererIndex(int trackType) {
-        if (player != null) {
-            int rendererCount = player.getRendererCount();
-            for (int rendererIndex = 0; rendererIndex < rendererCount; rendererIndex++) {
-                if (player.getRendererType(rendererIndex) == trackType) {
-                    return rendererIndex;
-                }
-            }
-        }
-        return C.INDEX_UNSET;
-    }
-
-    @Override
-    public void onMetadata(Metadata metadata) {
-        eventEmitter.timedMetadata(metadata);
-    }
-
-    // ReactExoplayerViewManager public api
-
-    public void setSrc(final Uri uri, final String extension, Map<String, String> headers) {
-        if (uri != null) {
-            boolean isSourceEqual = uri.equals(srcUri);
-
-            this.srcUri = uri;
-            this.extension = extension;
-            this.requestHeaders = headers;
-            this.mediaDataSourceFactory =
-                    DataSourceUtil.getDefaultDataSourceFactory(this.themedReactContext, bandwidthMeter,
-                            this.requestHeaders);
-
-            if (!isSourceEqual) {
-                reloadSource();
-            }
-        }
-    }
-
-    public void clearSrc() {
-        if (srcUri != null) {
-            player.stop(true);
-            this.srcUri = null;
-            this.extension = null;
-            this.requestHeaders = null;
-            this.mediaDataSourceFactory = null;
-            clearResumePosition();
-        }
-    }
-
-    public void setProgressUpdateInterval(final float progressUpdateInterval) {
-        mProgressUpdateInterval = progressUpdateInterval;
-    }
-
-    public void setReportBandwidth(boolean reportBandwidth) {
-        mReportBandwidth = reportBandwidth;
-    }
-
-    public void setRawSrc(final Uri uri, final String extension) {
-        if (uri != null) {
-            boolean isSourceEqual = uri.equals(srcUri);
-
-            this.srcUri = uri;
-            this.extension = extension;
-            this.mediaDataSourceFactory = buildDataSourceFactory(true);
-
-            if (!isSourceEqual) {
-                reloadSource();
-            }
-        }
-    }
-
-    public void setTextTracks(ReadableArray textTracks) {
-        this.textTracks = textTracks;
-        reloadSource();
-    }
-
-    private void reloadSource() {
-        playerNeedsSource = true;
-        initializePlayer();
-    }
-
-    public void setResizeModeModifier(@ResizeMode.Mode int resizeMode) {
-        exoPlayerView.setResizeMode(resizeMode);
-    }
-
-    private void applyModifiers() {
-        setRepeatModifier(repeat);
-        setMutedModifier(muted);
-    }
-
-    public void setRepeatModifier(boolean repeat) {
-        if (player != null) {
-            if (repeat) {
-                player.setRepeatMode(Player.REPEAT_MODE_ONE);
-            } else {
-                player.setRepeatMode(Player.REPEAT_MODE_OFF);
-            }
-        }
-        this.repeat = repeat;
-    }
-
-    public void setPreventsDisplaySleepDuringVideoPlayback(boolean preventsDisplaySleepDuringVideoPlayback) {
-        this.preventsDisplaySleepDuringVideoPlayback = preventsDisplaySleepDuringVideoPlayback;
-    }
-
-    public void setSelectedTrack(int trackType, String type, Dynamic value) {
-        if (player == null) return;
-        int rendererIndex = getTrackRendererIndex(trackType);
-        if (rendererIndex == C.INDEX_UNSET) {
-            return;
-        }
-        MappingTrackSelector.MappedTrackInfo info = trackSelector.getCurrentMappedTrackInfo();
-        if (info == null) {
-            return;
-        }
-
-        TrackGroupArray groups = info.getTrackGroups(rendererIndex);
-        int groupIndex = C.INDEX_UNSET;
-        int[] tracks = {0} ;
-
-        if (TextUtils.isEmpty(type)) {
-            type = "default";
-        }
-
-        DefaultTrackSelector.Parameters disableParameters = trackSelector.getParameters()
-                .buildUpon()
-                .setRendererDisabled(rendererIndex, true)
-                .build();
-
-        if (type.equals("disabled")) {
-            trackSelector.setParameters(disableParameters);
-            return;
-        } else if (type.equals("language")) {
-            for (int i = 0; i < groups.length; ++i) {
-                Format format = groups.get(i).getFormat(0);
-                if (format.language != null && format.language.equals(value.asString())) {
-                    groupIndex = i;
-                    break;
-                }
-            }
-        } else if (type.equals("title")) {
-            for (int i = 0; i < groups.length; ++i) {
-                Format format = groups.get(i).getFormat(0);
-                if (format.id != null && format.id.equals(value.asString())) {
-                    groupIndex = i;
-                    break;
-                }
-            }
-        } else if (type.equals("index")) {
-            if (value.asInt() < groups.length) {
-                groupIndex = value.asInt();
-            }
-        } else if (type.equals("resolution")) {
-            int height = value.asInt();
-            for (int i = 0; i < groups.length; ++i) { // Search for the exact height
-                TrackGroup group = groups.get(i);
-                for (int j = 0; j < group.length; j++) {
-                    Format format = group.getFormat(j);
-                    if (format.height == height) {
-                        groupIndex = i;
-                        tracks[0] = j;
-                        break;
-                    }
-                }
-            }
-        } else if (rendererIndex == C.TRACK_TYPE_TEXT && Util.SDK_INT > 18) { // Text default
-            // Use system settings if possible
-            CaptioningManager captioningManager
-                    = (CaptioningManager)themedReactContext.getSystemService(Context.CAPTIONING_SERVICE);
-            if (captioningManager != null && captioningManager.isEnabled()) {
-                groupIndex = getGroupIndexForDefaultLocale(groups);
-            }
-        } else if (rendererIndex == C.TRACK_TYPE_AUDIO) { // Audio default
-            groupIndex = getGroupIndexForDefaultLocale(groups);
-        }
-
-        if (groupIndex == C.INDEX_UNSET && trackType == C.TRACK_TYPE_VIDEO && groups.length != 0) { // Video auto
-            // Add all tracks as valid options for ABR to choose from
-            TrackGroup group = groups.get(0);
-            tracks = new int[group.length];
-            groupIndex = 0;
-            for (int j = 0; j < group.length; j++) {
-                tracks[j] = j;
-            }
-        }
-
-        if (groupIndex == C.INDEX_UNSET) {
-            trackSelector.setParameters(disableParameters);
-            return;
-        }
-
-        DefaultTrackSelector.Parameters selectionParameters = trackSelector.getParameters()
-                .buildUpon()
-                .setRendererDisabled(rendererIndex, false)
-                .setSelectionOverride(rendererIndex, groups,
-                        new DefaultTrackSelector.SelectionOverride(groupIndex, tracks))
-                .build();
-        trackSelector.setParameters(selectionParameters);
-    }
-
-    private int getGroupIndexForDefaultLocale(TrackGroupArray groups) {
-        if (groups.length == 0){
-            return C.INDEX_UNSET;
-        }
-
-        int groupIndex = 0; // default if no match
-        String locale2 = Locale.getDefault().getLanguage(); // 2 letter code
-        String locale3 = Locale.getDefault().getISO3Language(); // 3 letter code
-        for (int i = 0; i < groups.length; ++i) {
-            Format format = groups.get(i).getFormat(0);
-            String language = format.language;
-            if (language != null && (language.equals(locale2) || language.equals(locale3))) {
-                groupIndex = i;
-                break;
-            }
-        }
-        return groupIndex;
-    }
-
-    public void setSelectedVideoTrack(String type, Dynamic value) {
-        videoTrackType = type;
-        videoTrackValue = value;
-        setSelectedTrack(C.TRACK_TYPE_VIDEO, videoTrackType, videoTrackValue);
-    }
-
-    public void setSelectedAudioTrack(String type, Dynamic value) {
-        audioTrackType = type;
-        audioTrackValue = value;
-        setSelectedTrack(C.TRACK_TYPE_AUDIO, audioTrackType, audioTrackValue);
-    }
-
-    public void setSelectedTextTrack(String type, Dynamic value) {
-        textTrackType = type;
-        textTrackValue = value;
-        setSelectedTrack(C.TRACK_TYPE_TEXT, textTrackType, textTrackValue);
-    }
-
-    public void setPausedModifier(boolean paused) {
-        isPaused = paused;
-        if (player != null) {
-            if (!paused) {
-                startPlayback();
-            } else {
-                pausePlayback();
-            }
-        }
-    }
-
-    public void setMutedModifier(boolean muted) {
-        this.muted = muted;
-        audioVolume = muted ? 0.f : 1.f;
-        if (player != null) {
-            player.setVolume(audioVolume);
-        }
-    }
-
-
-    public void setVolumeModifier(float volume) {
-        audioVolume = volume;
-        if (player != null) {
-            player.setVolume(audioVolume);
-        }
-    }
-
-    public void seekTo(long positionMs) {
-        if (player != null) {
-            seekTime = positionMs;
-            player.seekTo(positionMs);
-        }
-    }
-
-    public void setRateModifier(float newRate) {
-        rate = newRate;
-
-        if (player != null) {
-            PlaybackParameters params = new PlaybackParameters(rate, 1f);
-            player.setPlaybackParameters(params);
-        }
-    }
-
-    public void setMaxBitRateModifier(int newMaxBitRate) {
-        maxBitRate = newMaxBitRate;
-        if (player != null) {
-            trackSelector.setParameters(trackSelector.buildUponParameters()
-                    .setMaxVideoBitrate(maxBitRate == 0 ? Integer.MAX_VALUE : maxBitRate));
-        }
-    }
-
-    public void setMinLoadRetryCountModifier(int newMinLoadRetryCount) {
-        minLoadRetryCount = newMinLoadRetryCount;
-        releasePlayer();
-        initializePlayer();
-    }
-
-    public void setPlayInBackground(boolean playInBackground) {
-        this.playInBackground = playInBackground;
-    }
-
-    public void setDisableFocus(boolean disableFocus) {
-        this.disableFocus = disableFocus;
-    }
-
-    public void setFullscreen(boolean fullscreen) {
-        if (fullscreen == isFullscreen) {
-            return; // Avoid generating events when nothing is changing
-        }
-        isFullscreen = fullscreen;
-
-        Activity activity = themedReactContext.getCurrentActivity();
-        if (activity == null) {
-            return;
-        }
-        Window window = activity.getWindow();
-        View decorView = window.getDecorView();
-        int uiOptions;
-        if (isFullscreen) {
-            if (Util.SDK_INT >= 19) { // 4.4+
-                uiOptions = SYSTEM_UI_FLAG_HIDE_NAVIGATION
-                        | SYSTEM_UI_FLAG_IMMERSIVE_STICKY
-                        | SYSTEM_UI_FLAG_FULLSCREEN;
-            } else {
-                uiOptions = SYSTEM_UI_FLAG_HIDE_NAVIGATION
-                        | SYSTEM_UI_FLAG_FULLSCREEN;
-            }
-            eventEmitter.fullscreenWillPresent();
-            decorView.setSystemUiVisibility(uiOptions);
-            eventEmitter.fullscreenDidPresent();
-        } else {
-            uiOptions = View.SYSTEM_UI_FLAG_VISIBLE;
-            eventEmitter.fullscreenWillDismiss();
-            decorView.setSystemUiVisibility(uiOptions);
-            eventEmitter.fullscreenDidDismiss();
-        }
-    }
-
-    public void setUseTextureView(boolean useTextureView) {
-        boolean finallyUseTextureView = useTextureView && this.drmUUID == null;
-        exoPlayerView.setUseTextureView(finallyUseTextureView);
-    }
-
-    public void setHideShutterView(boolean hideShutterView) {
-        exoPlayerView.setHideShutterView(hideShutterView);
-    }
-
-    public void setBufferConfig(int newMinBufferMs, int newMaxBufferMs, int newBufferForPlaybackMs, int newBufferForPlaybackAfterRebufferMs) {
-        minBufferMs = newMinBufferMs;
-        maxBufferMs = newMaxBufferMs;
-        bufferForPlaybackMs = newBufferForPlaybackMs;
-        bufferForPlaybackAfterRebufferMs = newBufferForPlaybackAfterRebufferMs;
-        releasePlayer();
-        initializePlayer();
-    }
-
-    public void setDrmType(UUID drmType) {
-        this.drmUUID = drmType;
-    }
-
-    public void setDrmLicenseUrl(String licenseUrl){
-        this.drmLicenseUrl = licenseUrl;
-    }
-
-    public void setDrmLicenseHeader(String[] header){
-        this.drmLicenseHeader = header;
-    }
-
-
-    @Override
-    public void onDrmKeysLoaded(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
-        Log.d("DRM Info", "onDrmKeysLoaded");
-    }
-
-    @Override
-    public void onDrmSessionManagerError(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId, Exception e) {
-        Log.d("DRM Info", "onDrmSessionManagerError");
-        eventEmitter.error("onDrmSessionManagerError", e);
-    }
-
-    @Override
-    public void onDrmKeysRestored(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
-        Log.d("DRM Info", "onDrmKeysRestored");
-    }
-
-    @Override
-    public void onDrmKeysRemoved(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
-        Log.d("DRM Info", "onDrmKeysRemoved");
-    }
-
-    /**
-     * Handling controls prop
-     *
-     * @param controls  Controls prop, if true enable controls, if false disable them
-     */
-    public void setControls(boolean controls) {
-        this.controls = controls;
-        if (player == null || exoPlayerView == null) return;
-        if (controls) {
-            addPlayerControl();
-        } else {
-            int indexOfPC = indexOfChild(playerControlView);
-            if (indexOfPC != -1) {
-                removeViewAt(indexOfPC);
-            }
-        }
-    }
-}
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/react/ReactVideoPackage.java b/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/react/ReactVideoPackage.java
deleted file mode 100644
index f7a5d02..0000000
--- a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/react/ReactVideoPackage.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.brentvatne.react;
-
-import com.brentvatne.exoplayer.DefaultReactExoplayerConfig;
-import com.brentvatne.exoplayer.ReactExoplayerConfig;
-import com.brentvatne.exoplayer.ReactExoplayerViewManager;
-import com.facebook.react.ReactPackage;
-import com.facebook.react.bridge.JavaScriptModule;
-import com.facebook.react.bridge.NativeModule;
-import com.facebook.react.bridge.ReactApplicationContext;
-import com.facebook.react.uimanager.ViewManager;
-
-import java.util.Collections;
-import java.util.List;
-
-public class ReactVideoPackage implements ReactPackage {
-
-    private ReactExoplayerConfig config;
-
-    public ReactVideoPackage() {
-    }
-
-    public ReactVideoPackage(ReactExoplayerConfig config) {
-        this.config = config;
-    }
-
-    @Override
-    public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {
-        return Collections.emptyList();
-    }
-
-    // Deprecated RN 0.47
-    public List<Class<? extends JavaScriptModule>> createJSModules() {
-        return Collections.emptyList();
-    }
-
-
-    @Override
-    public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
-        if (config == null) {
-            config = new DefaultReactExoplayerConfig(reactContext);
-        }
-        return Collections.singletonList(new ReactExoplayerViewManager(config));
-    }
-}
diff --git a/node_modules/react-native-video/android-exoplayer/README.md b/node_modules/react-native-video/android/README.md
similarity index 96%
rename from node_modules/react-native-video/android-exoplayer/README.md
rename to node_modules/react-native-video/android/README.md
index 9396763..07c85af 100644
--- a/node_modules/react-native-video/android-exoplayer/README.md
+++ b/node_modules/react-native-video/android/README.md
@@ -9,7 +9,7 @@ https://github.com/google/ExoPlayer
 ## Benefits over `react-native-video@0.9.0`:
 
 - Android Video library built by Google, with a lot of support
-- Supports DASH, HlS, & SmoothStreaming adaptive streams
+- Supports DASH, HLS, & SmoothStreaming adaptive streams
 - Supports formats such as MP4, M4A, FMP4, WebM, MKV, MP3, Ogg, WAV, MPEG-TS, MPEG-PS, FLV and ADTS (AAC).
 - Fewer device specific issues
 - Highly customisable
diff --git a/node_modules/react-native-video/android/build.gradle b/node_modules/react-native-video/android/build.gradle
index 1c52da9..de702f9 100644
--- a/node_modules/react-native-video/android/build.gradle
+++ b/node_modules/react-native-video/android/build.gradle
@@ -4,23 +4,76 @@ def safeExtGet(prop, fallback) {
     rootProject.ext.has(prop) ? rootProject.ext.get(prop) : fallback
 }
 
+def useExoplayerIMA = safeExtGet("RNVUseExoplayerIMA", false)
+
+println "useExoplayerIMA:" + useExoplayerIMA
+
+// This string is used to define build path.
+// As react native build output directory is react-native path of the module.
+// We need to force a new path on each configuration change.
+// If you add a new build parameter, please add the new value in this string
+def configStringPath = (
+        'useExoplayerIMA' + useExoplayerIMA \
+).md5()
+
 android {
-    compileSdkVersion safeExtGet('compileSdkVersion', 28)
-    buildToolsVersion safeExtGet('buildToolsVersion', '28.0.3')
+    namespace 'com.brentvatne.react'
+    compileSdkVersion safeExtGet('compileSdkVersion', 31)
+    buildToolsVersion safeExtGet('buildToolsVersion', '30.0.2')
+
+    compileOptions {
+        targetCompatibility JavaVersion.VERSION_1_8
+        sourceCompatibility JavaVersion.VERSION_1_8
+    }
 
     defaultConfig {
-        minSdkVersion safeExtGet('minSdkVersion', 16)
+        minSdkVersion safeExtGet('minSdkVersion', 21)
         targetSdkVersion safeExtGet('targetSdkVersion', 28)
         versionCode 1
         versionName "1.0"
-        ndk {
-            abiFilters "armeabi-v7a", "x86"
+    }
+
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_1_8
+        targetCompatibility JavaVersion.VERSION_1_8
+    }
+
+    buildDir 'buildOutput_' + configStringPath
+
+    sourceSets {
+        main {
+            java {
+                if (useExoplayerIMA) {
+                    exclude 'com/google/ads/interactivemedia/v3/api'
+                    exclude 'com/google/android/exoplayer2/ext/ima'
+                }
+            }
         }
     }
 }
 
+repositories {
+    google()
+}
+
 dependencies {
-    //noinspection GradleDynamicVersion
     implementation "com.facebook.react:react-native:${safeExtGet('reactNativeVersion', '+')}"
-    implementation 'com.github.adityaxjha:Android-ScalableVideoView:10e7b4da8b'
+    implementation('com.google.android.exoplayer:exoplayer:2.18.1') {
+        exclude group: 'com.android.support'
+    }
+
+    // All support libs must use the same version
+    implementation "androidx.annotation:annotation:1.1.0"
+    implementation "androidx.core:core:1.1.0"
+    implementation "androidx.media:media:1.1.0"
+    implementation "androidx.activity:activity:1.4.0"
+
+    implementation('com.google.android.exoplayer:extension-okhttp:2.18.1') {
+        exclude group: 'com.squareup.okhttp3', module: 'okhttp'
+    }
+
+    if (useExoplayerIMA) {
+        implementation 'com.google.android.exoplayer:extension-ima:2.18.1'
+    }
+    implementation "com.squareup.okhttp3:okhttp:" + '$OKHTTP_VERSION'
 }
diff --git a/node_modules/react-native-video/android/src/main/java/com/android/vending/expansion/zipfile/APEZProvider.java b/node_modules/react-native-video/android/src/main/java/com/android/vending/expansion/zipfile/APEZProvider.java
deleted file mode 100644
index 1ba910b..0000000
--- a/node_modules/react-native-video/android/src/main/java/com/android/vending/expansion/zipfile/APEZProvider.java
+++ /dev/null
@@ -1,287 +0,0 @@
-package com.android.vending.expansion.zipfile;
-
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-//To implement APEZProvider in your application, you'll want to change
-//the AUTHORITY to match what you define in the manifest.
-
-import com.android.vending.expansion.zipfile.ZipResourceFile.ZipEntryRO;
-
-import android.content.ContentProvider;
-import android.content.ContentProviderOperation;
-import android.content.ContentProviderResult;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.OperationApplicationException;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.content.pm.ProviderInfo;
-import android.content.res.AssetFileDescriptor;
-import android.database.Cursor;
-import android.database.MatrixCursor;
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-import android.provider.BaseColumns;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.ArrayList;
-
-/**
- * This content provider is an optional part of the library.
- * 
- * <p>Most apps don't need to use this class. This defines a
- * ContentProvider that marshalls the data from the ZIP files through a
- * content provider Uri in order to provide file access for certain Android APIs 
- * that expect Uri access to media files.
- *
- */
-public abstract class APEZProvider extends ContentProvider {	
-
-	private ZipResourceFile mAPKExtensionFile;
-	private boolean mInit;
-	
-	public static final String FILEID = BaseColumns._ID;
-	public static final String FILENAME = "ZPFN";
-	public static final String ZIPFILE = "ZFIL";
-	public static final String MODIFICATION = "ZMOD";
-	public static final String CRC32 = "ZCRC";
-	public static final String COMPRESSEDLEN = "ZCOL";
-	public static final String UNCOMPRESSEDLEN = "ZUNL";
-	public static final String COMPRESSIONTYPE = "ZTYP";
-	
-	public static final String[] ALL_FIELDS = {
-		FILEID,
-		FILENAME,
-		ZIPFILE,
-		MODIFICATION,
-		CRC32,
-		COMPRESSEDLEN,
-		UNCOMPRESSEDLEN,
-		COMPRESSIONTYPE
-	};
-	
-	public static final int FILEID_IDX = 0;
-	public static final int FILENAME_IDX = 1;
-	public static final int ZIPFILE_IDX = 2;
-	public static final int MOD_IDX = 3;
-	public static final int CRC_IDX = 4;
-	public static final int COMPLEN_IDX = 5;
-	public static final int UNCOMPLEN_IDX = 6;
-	public static final int COMPTYPE_IDX = 7;
-	
-	public static final int[] ALL_FIELDS_INT = {
-		FILEID_IDX,
-		FILENAME_IDX,
-		ZIPFILE_IDX,
-		MOD_IDX,
-		CRC_IDX,
-		COMPLEN_IDX,
-		UNCOMPLEN_IDX,
-		COMPTYPE_IDX
-	};
-	
-	/**
-	 * This needs to match the authority in your manifest
-	 */
-	public abstract String getAuthority();
-	
-	@Override
-	public int delete(Uri arg0, String arg1, String[] arg2) {
-		// TODO Auto-generated method stub
-		return 0;
-	}
-
-	@Override
-	public String getType(Uri uri) {
-		return "vnd.android.cursor.item/asset";
-	}
-
-	@Override
-	public Uri insert(Uri uri, ContentValues values) {
-		// TODO Auto-generated method stub
-		return null;
-	}
-	
-	static private final String NO_FILE = "N";
-	
-	private boolean initIfNecessary() {
-	    if ( !mInit ) {
-            Context ctx = getContext();
-            PackageManager pm = ctx.getPackageManager();
-            ProviderInfo pi = pm.resolveContentProvider(getAuthority(), PackageManager.GET_META_DATA);
-            PackageInfo packInfo;
-            try {
-                packInfo = pm.getPackageInfo(ctx.getPackageName(), 0);
-            } catch (NameNotFoundException e1) {
-                e1.printStackTrace();
-                return false;
-            }
-            int patchFileVersion;
-            int mainFileVersion;
-            int appVersionCode = packInfo.versionCode;
-            String[] resourceFiles = null;
-            if ( null != pi.metaData ) {
-                mainFileVersion = pi.metaData.getInt("mainVersion", appVersionCode);
-                patchFileVersion = pi.metaData.getInt("patchVersion", appVersionCode);
-                String mainFileName = pi.metaData.getString("mainFilename", NO_FILE);
-                if ( NO_FILE != mainFileName ) {
-                    String patchFileName = pi.metaData.getString("patchFilename", NO_FILE);
-                    if ( NO_FILE != patchFileName ) {
-                        resourceFiles = new String[] { mainFileName, patchFileName };
-                    } else {
-                        resourceFiles = new String[] { mainFileName };
-                    }
-                }
-            } else {
-                mainFileVersion = patchFileVersion = appVersionCode;
-            }
-            try {
-                if ( null == resourceFiles ) {
-                    mAPKExtensionFile = APKExpansionSupport.getAPKExpansionZipFile(ctx, mainFileVersion, patchFileVersion);
-                } else {
-                    mAPKExtensionFile = APKExpansionSupport.getResourceZipFile(resourceFiles);
-                }
-                mInit = true;
-                return true;
-            } catch (IOException e) {
-                e.printStackTrace();                
-            }
-	    }
-        return false;	    
-	}
-
-	@Override
-	public boolean onCreate() {
-	    return true;
-	}
-
-	@Override
-	public AssetFileDescriptor openAssetFile(Uri uri, String mode)
-			throws FileNotFoundException {
-        initIfNecessary();
-		String path = uri.getEncodedPath();
-		if ( path.startsWith("/") ) {
-			path = path.substring(1);
-		}
-		return mAPKExtensionFile.getAssetFileDescriptor(path);		
-	}
-
-	@Override
-	public ContentProviderResult[] applyBatch(
-			ArrayList<ContentProviderOperation> operations)
-			throws OperationApplicationException {
-        initIfNecessary();
-		return super.applyBatch(operations);
-	}
-
-	@Override
-	public ParcelFileDescriptor openFile(Uri uri, String mode)
-			throws FileNotFoundException {
-        initIfNecessary();
-		AssetFileDescriptor af = openAssetFile(uri, mode);
-		if ( null != af ) {
-			return af.getParcelFileDescriptor();
-		}
-		return null;
-	}
-
-	@Override
-	public Cursor query(Uri uri, String[] projection, String selection,
-			String[] selectionArgs, String sortOrder) {
-	    initIfNecessary();
-		// lists all of the items in the file that match
-		ZipEntryRO[] zipEntries;
-		if ( null == mAPKExtensionFile ) {
-			zipEntries = new ZipEntryRO[0];
-		} else {
-			zipEntries = mAPKExtensionFile.getAllEntries();
-		}
-		int[] intProjection;
-		if ( null == projection )  {
-			intProjection = ALL_FIELDS_INT;
-			projection = ALL_FIELDS;
-		} else {
-			int len = projection.length;
-			intProjection = new int[len];
-			for ( int i = 0; i < len; i++ ) {
-				if ( projection[i].equals(FILEID) ) {
-					intProjection[i] = FILEID_IDX;
-				} else if ( projection[i].equals(FILENAME) ) {
-					intProjection[i] = FILENAME_IDX;
-				} else if ( projection[i].equals(ZIPFILE) ) {
-					intProjection[i] = ZIPFILE_IDX;
-				} else if ( projection[i].equals(MODIFICATION) ) {
-					intProjection[i] = MOD_IDX;
-				} else if ( projection[i].equals(CRC32) ) {
-					intProjection[i] = CRC_IDX;
-				} else if ( projection[i].equals(COMPRESSEDLEN) ) {
-					intProjection[i] = COMPLEN_IDX;
-				} else if ( projection[i].equals(UNCOMPRESSEDLEN) ) {
-					intProjection[i] = UNCOMPLEN_IDX;
-				} else if ( projection[i].equals(COMPRESSIONTYPE) ) {
-					intProjection[i] = COMPTYPE_IDX;
-				} else {
-					throw new RuntimeException();
-				}
-			}
-		}
-		MatrixCursor mc = new MatrixCursor(projection, zipEntries.length);
-		int len = intProjection.length;
-		for ( ZipEntryRO zer : zipEntries ) {
-			MatrixCursor.RowBuilder rb = mc.newRow();
-			for ( int i = 0; i < len; i++ ) {				
-				switch (intProjection[i]) {
-					case FILEID_IDX:
-						rb.add(i);
-						break;
-					case FILENAME_IDX:
-						rb.add(zer.mFileName);
-						break;
-					case ZIPFILE_IDX:
-						rb.add(zer.getZipFileName());
-						break;
-					case MOD_IDX:
-						rb.add(zer.mWhenModified);
-						break;
-					case CRC_IDX:
-						rb.add(zer.mCRC32);
-						break;
-					case COMPLEN_IDX:
-						rb.add(zer.mCompressedLength);
-						break;
-					case UNCOMPLEN_IDX:
-						rb.add(zer.mUncompressedLength);
-						break;
-					case COMPTYPE_IDX:
-						rb.add(zer.mMethod);
-						break;
-				}
-			}
-		}
-		return mc;
-	}
-
-	@Override
-	public int update(Uri uri, ContentValues values, String selection,
-			String[] selectionArgs) {
-		// TODO Auto-generated method stub
-		return 0;
-	}
-
-}
diff --git a/node_modules/react-native-video/android/src/main/java/com/android/vending/expansion/zipfile/APKExpansionSupport.java b/node_modules/react-native-video/android/src/main/java/com/android/vending/expansion/zipfile/APKExpansionSupport.java
deleted file mode 100644
index 34669c1..0000000
--- a/node_modules/react-native-video/android/src/main/java/com/android/vending/expansion/zipfile/APKExpansionSupport.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package com.android.vending.expansion.zipfile;
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.io.File;
-import java.io.FileFilter;
-import java.io.IOException;
-import java.util.Vector;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import android.content.Context;
-import android.os.Environment;
-import android.util.Log;
-
-public class APKExpansionSupport {
-	// The shared path to all app expansion files
-	private final static String EXP_PATH = "/Android/obb/";
-
-	static String[] getAPKExpansionFiles(Context ctx, int mainVersion, int patchVersion) {
-		String packageName = ctx.getPackageName();
-		Vector<String> ret = new Vector<String>();
-		if (Environment.getExternalStorageState().equals(
-				Environment.MEDIA_MOUNTED)) {
-			// Build the full path to the app's expansion files
-			File root = Environment.getExternalStorageDirectory();
-			File expPath = new File(root.toString() + EXP_PATH + packageName);
-
-			// Check that expansion file path exists
-			if (expPath.exists()) {
-				if ( mainVersion > 0 ) {
-					String strMainPath = expPath + File.separator + "main." + mainVersion + "." + packageName + ".obb";
-//					Log.d("APKEXPANSION", strMainPath);
-					File main = new File(strMainPath);
-					if ( main.isFile() ) {
-						ret.add(strMainPath);
-					}
-				}
-				if ( patchVersion > 0 ) {
-					String strPatchPath = expPath + File.separator + "patch." + patchVersion + "." + packageName + ".obb";
-					File main = new File(strPatchPath);
-					if ( main.isFile() ) {
-						ret.add(strPatchPath);
-					}
-				}
-			}
-		}
-		String[] retArray = new String[ret.size()];
-		ret.toArray(retArray);
-		return retArray;
-	}
-
-	static public ZipResourceFile getResourceZipFile(String[] expansionFiles) throws IOException {
-        ZipResourceFile apkExpansionFile = null;
-        for (String expansionFilePath : expansionFiles) {
-            if ( null == apkExpansionFile ) {
-                apkExpansionFile = new ZipResourceFile(expansionFilePath);
-            } else {
-                apkExpansionFile.addPatchFile(expansionFilePath);
-            }
-        }
-        return apkExpansionFile;
-	}
-	
-	static public ZipResourceFile getAPKExpansionZipFile(Context ctx, int mainVersion, int patchVersion) throws IOException{
-		String[] expansionFiles = getAPKExpansionFiles(ctx, mainVersion, patchVersion);
-		return getResourceZipFile(expansionFiles);
-	}
-}
diff --git a/node_modules/react-native-video/android/src/main/java/com/android/vending/expansion/zipfile/ZipResourceFile.java b/node_modules/react-native-video/android/src/main/java/com/android/vending/expansion/zipfile/ZipResourceFile.java
deleted file mode 100644
index 902af3c..0000000
--- a/node_modules/react-native-video/android/src/main/java/com/android/vending/expansion/zipfile/ZipResourceFile.java
+++ /dev/null
@@ -1,428 +0,0 @@
-
-package com.android.vending.expansion.zipfile;
-
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import android.content.res.AssetFileDescriptor;
-import android.os.ParcelFileDescriptor;
-import android.util.Log;
-
-import java.io.EOFException;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.RandomAccessFile;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.MappedByteBuffer;
-import java.nio.channels.FileChannel;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Vector;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
-
-public class ZipResourceFile {
-
-    //
-    // Read-only access to Zip archives, with minimal heap allocation.
-    //
-    static final String LOG_TAG = "zipro";
-    static final boolean LOGV = false;
-
-    // 4-byte number
-    static private int swapEndian(int i)
-    {
-        return ((i & 0xff) << 24) + ((i & 0xff00) << 8) + ((i & 0xff0000) >>> 8)
-                + ((i >>> 24) & 0xff);
-    }
-
-    // 2-byte number
-    static private int swapEndian(short i)
-    {
-        return ((i & 0x00FF) << 8 | (i & 0xFF00) >>> 8);
-    }
-
-    /*
-     * Zip file constants.
-     */
-    static final int kEOCDSignature = 0x06054b50;
-    static final int kEOCDLen = 22;
-    static final int kEOCDNumEntries = 8; // offset to #of entries in file
-    static final int kEOCDSize = 12; // size of the central directory
-    static final int kEOCDFileOffset = 16; // offset to central directory
-
-    static final int kMaxCommentLen = 65535; // longest possible in ushort
-    static final int kMaxEOCDSearch = (kMaxCommentLen + kEOCDLen);
-
-    static final int kLFHSignature = 0x04034b50;
-    static final int kLFHLen = 30; // excluding variable-len fields
-    static final int kLFHNameLen = 26; // offset to filename length
-    static final int kLFHExtraLen = 28; // offset to extra length
-
-    static final int kCDESignature = 0x02014b50;
-    static final int kCDELen = 46; // excluding variable-len fields
-    static final int kCDEMethod = 10; // offset to compression method
-    static final int kCDEModWhen = 12; // offset to modification timestamp
-    static final int kCDECRC = 16; // offset to entry CRC
-    static final int kCDECompLen = 20; // offset to compressed length
-    static final int kCDEUncompLen = 24; // offset to uncompressed length
-    static final int kCDENameLen = 28; // offset to filename length
-    static final int kCDEExtraLen = 30; // offset to extra length
-    static final int kCDECommentLen = 32; // offset to comment length
-    static final int kCDELocalOffset = 42; // offset to local hdr
-
-    static final int kCompressStored = 0; // no compression
-    static final int kCompressDeflated = 8; // standard deflate
-
-    /*
-     * The values we return for ZipEntryRO use 0 as an invalid value, so we want
-     * to adjust the hash table index by a fixed amount. Using a large value
-     * helps insure that people don't mix & match arguments, e.g. to
-     * findEntryByIndex().
-     */
-    static final int kZipEntryAdj = 10000;
-
-    static public final class ZipEntryRO {
-        public ZipEntryRO(final String zipFileName, final File file, final String fileName) {
-            mFileName = fileName;
-            mZipFileName = zipFileName;
-            mFile = file;
-        }
-
-        public final File mFile;
-        public final String mFileName;
-        public final String mZipFileName;
-        public long mLocalHdrOffset; // offset of local file header
-
-        /* useful stuff from the directory entry */
-        public int mMethod;
-        public long mWhenModified;
-        public long mCRC32;
-        public long mCompressedLength;
-        public long mUncompressedLength;
-
-        public long mOffset = -1;
-
-        public void setOffsetFromFile(RandomAccessFile f, ByteBuffer buf) throws IOException {
-            long localHdrOffset = mLocalHdrOffset;
-            try {
-                f.seek(localHdrOffset);
-                f.readFully(buf.array());
-                if (buf.getInt(0) != kLFHSignature) {
-                    Log.w(LOG_TAG, "didn't find signature at start of lfh");
-                    throw new IOException();
-                }
-                int nameLen = buf.getShort(kLFHNameLen) & 0xFFFF;
-                int extraLen = buf.getShort(kLFHExtraLen) & 0xFFFF;
-                mOffset = localHdrOffset + kLFHLen + nameLen + extraLen;
-            } catch (FileNotFoundException e) {
-                e.printStackTrace();
-            } catch (IOException ioe) {
-                ioe.printStackTrace();
-            }
-        }
-
-        /**
-         * Calculates the offset of the start of the Zip file entry within the
-         * Zip file.
-         * 
-         * @return the offset, in bytes from the start of the file of the entry
-         */
-        public long getOffset() {
-            return mOffset;
-        }
-
-        /**
-         * isUncompressed
-         * 
-         * @return true if the file is stored in uncompressed form
-         */
-        public boolean isUncompressed() {
-            return mMethod == kCompressStored;
-        }
-
-        public AssetFileDescriptor getAssetFileDescriptor() {
-            if (mMethod == kCompressStored) {
-                ParcelFileDescriptor pfd;
-                try {
-                    pfd = ParcelFileDescriptor.open(mFile, ParcelFileDescriptor.MODE_READ_ONLY);
-                    return new AssetFileDescriptor(pfd, getOffset(), mUncompressedLength);
-                } catch (FileNotFoundException e) {
-                    // TODO Auto-generated catch block
-                    e.printStackTrace();
-                }
-            }
-            return null;
-        }
-
-        public String getZipFileName() {
-            return mZipFileName;
-        }
-
-        public File getZipFile() {
-            return mFile;
-        }
-
-    }
-
-    private HashMap<String, ZipEntryRO> mHashMap = new HashMap<String, ZipEntryRO>();
-
-    /* for reading compressed files */
-    public HashMap<File, ZipFile> mZipFiles = new HashMap<File, ZipFile>();
-
-    public ZipResourceFile(String zipFileName) throws IOException {
-        addPatchFile(zipFileName);
-    }
-
-    ZipEntryRO[] getEntriesAt(String path) {
-        Vector<ZipEntryRO> zev = new Vector<ZipEntryRO>();
-        Collection<ZipEntryRO> values = mHashMap.values();
-        if (null == path)
-            path = "";
-        int length = path.length();
-        for (ZipEntryRO ze : values) {
-            if (ze.mFileName.startsWith(path)) {
-                if (-1 == ze.mFileName.indexOf('/', length)) {
-                    zev.add(ze);
-                }
-            }
-        }
-        ZipEntryRO[] entries = new ZipEntryRO[zev.size()];
-        return zev.toArray(entries);
-    }
-
-    public ZipEntryRO[] getAllEntries() {
-        Collection<ZipEntryRO> values = mHashMap.values();
-        return values.toArray(new ZipEntryRO[values.size()]);
-    }
-
-    /**
-     * getAssetFileDescriptor allows for ZipResourceFile to directly feed
-     * Android API's that want an fd, offset, and length such as the
-     * MediaPlayer. It also allows for the class to be used in a content
-     * provider that can feed video players. The file must be stored
-     * (non-compressed) in the Zip file for this to work.
-     * 
-     * @param assetPath
-     * @return the asset file descriptor for the file, or null if the file isn't
-     *         present or is stored compressed
-     */
-    public AssetFileDescriptor getAssetFileDescriptor(String assetPath) {
-        ZipEntryRO entry = mHashMap.get(assetPath);
-        if (null != entry) {
-            return entry.getAssetFileDescriptor();
-        }
-        return null;
-    }
-
-    /**
-     * getInputStream returns an AssetFileDescriptor.AutoCloseInputStream
-     * associated with the asset that is contained in the Zip file, or a
-     * standard ZipInputStream if necessary to uncompress the file
-     * 
-     * @param assetPath
-     * @return an input stream for the named asset path, or null if not found
-     * @throws IOException
-     */
-    public InputStream getInputStream(String assetPath) throws IOException {
-        ZipEntryRO entry = mHashMap.get(assetPath);
-        if (null != entry) {
-            if (entry.isUncompressed()) {
-                return entry.getAssetFileDescriptor().createInputStream();
-            } else {
-                ZipFile zf = mZipFiles.get(entry.getZipFile());
-                /** read compressed files **/
-                if (null == zf) {
-                    zf = new ZipFile(entry.getZipFile(), ZipFile.OPEN_READ);
-                    mZipFiles.put(entry.getZipFile(), zf);
-                }
-                ZipEntry zi = zf.getEntry(assetPath);
-                if (null != zi)
-                    return zf.getInputStream(zi);
-            }
-        }
-        return null;
-    }
-
-    ByteBuffer mLEByteBuffer = ByteBuffer.allocate(4);
-
-    static private int read4LE(RandomAccessFile f) throws EOFException, IOException {
-        return swapEndian(f.readInt());
-    }
-    
-    /*
-     * Opens the specified file read-only. We memory-map the entire thing and
-     * close the file before returning.
-     */
-    void addPatchFile(String zipFileName) throws IOException
-    {
-        File file = new File(zipFileName);
-        RandomAccessFile f = new RandomAccessFile(file, "r");
-        long fileLength = f.length();
-
-        if (fileLength < kEOCDLen) {
-            throw new java.io.IOException();
-        }
-
-        long readAmount = kMaxEOCDSearch;
-        if (readAmount > fileLength)
-            readAmount = fileLength;
-
-        /*
-         * Make sure this is a Zip archive.
-         */
-        f.seek(0);
-
-        int header = read4LE(f);
-        if (header == kEOCDSignature) {
-            Log.i(LOG_TAG, "Found Zip archive, but it looks empty");
-            throw new IOException();
-        } else if (header != kLFHSignature) {
-            Log.v(LOG_TAG, "Not a Zip archive");
-            throw new IOException();
-        }
-
-        /*
-         * Perform the traditional EOCD snipe hunt. We're searching for the End
-         * of Central Directory magic number, which appears at the start of the
-         * EOCD block. It's followed by 18 bytes of EOCD stuff and up to 64KB of
-         * archive comment. We need to read the last part of the file into a
-         * buffer, dig through it to find the magic number, parse some values
-         * out, and use those to determine the extent of the CD. We start by
-         * pulling in the last part of the file.
-         */
-        long searchStart = fileLength - readAmount;
-
-        f.seek(searchStart);
-        ByteBuffer bbuf = ByteBuffer.allocate((int) readAmount);
-        byte[] buffer = bbuf.array();
-        f.readFully(buffer);
-        bbuf.order(ByteOrder.LITTLE_ENDIAN);
-
-        /*
-         * Scan backward for the EOCD magic. In an archive without a trailing
-         * comment, we'll find it on the first try. (We may want to consider
-         * doing an initial minimal read; if we don't find it, retry with a
-         * second read as above.)
-         */
-
-        // EOCD == 0x50, 0x4b, 0x05, 0x06
-        int eocdIdx;
-        for (eocdIdx = buffer.length - kEOCDLen; eocdIdx >= 0; eocdIdx--) {
-            if (buffer[eocdIdx] == 0x50 && bbuf.getInt(eocdIdx) == kEOCDSignature)
-            {
-                if (LOGV) {
-                    Log.v(LOG_TAG, "+++ Found EOCD at index: " + eocdIdx);
-                }
-                break;
-            }
-        }
-
-        if (eocdIdx < 0) {
-            Log.d(LOG_TAG, "Zip: EOCD not found, " + zipFileName + " is not zip");
-        }
-
-        /*
-         * Grab the CD offset and size, and the number of entries in the
-         * archive. After that, we can release our EOCD hunt buffer.
-         */
-
-        int numEntries = bbuf.getShort(eocdIdx + kEOCDNumEntries);
-        long dirSize = bbuf.getInt(eocdIdx + kEOCDSize) & 0xffffffffL;
-        long dirOffset = bbuf.getInt(eocdIdx + kEOCDFileOffset) & 0xffffffffL;
-
-        // Verify that they look reasonable.
-        if (dirOffset + dirSize > fileLength) {
-            Log.w(LOG_TAG, "bad offsets (dir " + dirOffset + ", size " + dirSize + ", eocd "
-                    + eocdIdx + ")");
-            throw new IOException();
-        }
-        if (numEntries == 0) {
-            Log.w(LOG_TAG, "empty archive?");
-            throw new IOException();
-        }
-
-        if (LOGV) {
-            Log.v(LOG_TAG, "+++ numEntries=" + numEntries + " dirSize=" + dirSize + " dirOffset="
-                    + dirOffset);
-        }
-
-        MappedByteBuffer directoryMap = f.getChannel()
-                .map(FileChannel.MapMode.READ_ONLY, dirOffset, dirSize);
-        directoryMap.order(ByteOrder.LITTLE_ENDIAN);
-
-        byte[] tempBuf = new byte[0xffff];
-
-        /*
-         * Walk through the central directory, adding entries to the hash table.
-         */
-
-        int currentOffset = 0;
-
-        /*
-         * Allocate the local directory information
-         */
-        ByteBuffer buf = ByteBuffer.allocate(kLFHLen);
-        buf.order(ByteOrder.LITTLE_ENDIAN);
-
-        for (int i = 0; i < numEntries; i++) {
-            if (directoryMap.getInt(currentOffset) != kCDESignature) {
-                Log.w(LOG_TAG, "Missed a central dir sig (at " + currentOffset + ")");
-                throw new IOException();
-            }
-
-            /* useful stuff from the directory entry */
-            int fileNameLen = directoryMap.getShort(currentOffset + kCDENameLen) & 0xffff;
-            int extraLen = directoryMap.getShort(currentOffset + kCDEExtraLen) & 0xffff;
-            int commentLen = directoryMap.getShort(currentOffset + kCDECommentLen) & 0xffff;
-
-            /* get the CDE filename */
-
-            directoryMap.position(currentOffset + kCDELen);
-            directoryMap.get(tempBuf, 0, fileNameLen);
-            directoryMap.position(0);
-
-            /* UTF-8 on Android */
-            String str = new String(tempBuf, 0, fileNameLen);
-            if (LOGV) {
-                Log.v(LOG_TAG, "Filename: " + str);
-            }
-
-            ZipEntryRO ze = new ZipEntryRO(zipFileName, file, str);
-            ze.mMethod = directoryMap.getShort(currentOffset + kCDEMethod) & 0xffff;
-            ze.mWhenModified = directoryMap.getInt(currentOffset + kCDEModWhen) & 0xffffffffL;
-            ze.mCRC32 = directoryMap.getLong(currentOffset + kCDECRC) & 0xffffffffL;
-            ze.mCompressedLength = directoryMap.getLong(currentOffset + kCDECompLen) & 0xffffffffL;
-            ze.mUncompressedLength = directoryMap.getLong(currentOffset + kCDEUncompLen) & 0xffffffffL;
-            ze.mLocalHdrOffset = directoryMap.getInt(currentOffset + kCDELocalOffset) & 0xffffffffL;
-
-            // set the offsets
-            buf.clear();
-            ze.setOffsetFromFile(f, buf);
-
-            // put file into hash
-            mHashMap.put(str, ze);
-
-            // go to next directory entry
-            currentOffset += kCDELen + fileNameLen + extraLen + commentLen;
-        }
-        if (LOGV) {
-            Log.v(LOG_TAG, "+++ zip good scan " + numEntries + " entries");
-        }
-    }
-}
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/ReactBridgeUtils.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/ReactBridgeUtils.java
new file mode 100644
index 0000000..c339128
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/ReactBridgeUtils.java
@@ -0,0 +1,22 @@
+package com.brentvatne;
+
+import com.facebook.react.bridge.ReadableMap;
+
+/*
+* This file define static helpers to parse in an easier way input props
+ */
+public class ReactBridgeUtils {
+    /*
+    retrieve key from map as int. fallback is returned if not available
+     */
+    static public int safeGetInt(ReadableMap map, String key, int fallback) {
+        return map != null && map.hasKey(key) && !map.isNull(key) ? map.getInt(key) : fallback;
+    }
+
+    /*
+    retrieve key from map as double. fallback is returned if not available
+     */
+    static public double safeGetDouble(ReadableMap map, String key, double fallback) {
+        return map != null && map.hasKey(key) && !map.isNull(key) ? map.getDouble(key) : fallback;
+    }
+}
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/common/Track.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/common/Track.java
new file mode 100644
index 0000000..198f9ec
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/common/Track.java
@@ -0,0 +1,13 @@
+package com.brentvatne.common;
+import android.net.Uri;
+
+public class Track
+{
+    public String m_title;
+    public Uri m_uri;
+    public String m_mimeType;
+    public String m_language;
+    public boolean m_isSelected;
+    public int m_bitrate;
+    public int m_index;
+}
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/common/VideoTrack.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/common/VideoTrack.java
new file mode 100644
index 0000000..6eccd98
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/common/VideoTrack.java
@@ -0,0 +1,12 @@
+package com.brentvatne.common;
+
+public class VideoTrack
+{
+    public int m_width = 0;
+    public int m_height = 0;
+    public int m_bitrate = 0;
+    public String m_codecs = "";
+    public int m_id = -1;
+    public String m_trackId = "";
+    public boolean m_isSelected = false;
+}
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/AspectRatioFrameLayout.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/AspectRatioFrameLayout.java
similarity index 100%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/AspectRatioFrameLayout.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/AspectRatioFrameLayout.java
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/DataSourceUtil.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/DataSourceUtil.java
similarity index 89%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/DataSourceUtil.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/DataSourceUtil.java
index 19dda00..c5e7047 100644
--- a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/DataSourceUtil.java
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/DataSourceUtil.java
@@ -4,13 +4,14 @@ import com.facebook.react.bridge.ReactContext;
 import com.facebook.react.modules.network.CookieJarContainer;
 import com.facebook.react.modules.network.ForwardingCookieHandler;
 import com.facebook.react.modules.network.OkHttpClientProvider;
-import com.google.android.exoplayer2.ext.okhttp.OkHttpDataSourceFactory;
+import com.google.android.exoplayer2.ext.okhttp.OkHttpDataSource;
 import com.google.android.exoplayer2.upstream.DataSource;
 import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
-import com.google.android.exoplayer2.upstream.DefaultDataSourceFactory;
+import com.google.android.exoplayer2.upstream.DefaultDataSource;
 import com.google.android.exoplayer2.upstream.HttpDataSource;
 import com.google.android.exoplayer2.util.Util;
 
+import okhttp3.Call;
 import okhttp3.JavaNetCookieJar;
 import okhttp3.OkHttpClient;
 import java.util.Map;
@@ -75,7 +76,7 @@ public class DataSourceUtil {
     }
 
     private static DataSource.Factory buildDataSourceFactory(ReactContext context, DefaultBandwidthMeter bandwidthMeter, Map<String, String> requestHeaders) {
-        return new DefaultDataSourceFactory(context, bandwidthMeter,
+        return new DefaultDataSource.Factory(context,
                 buildHttpDataSourceFactory(context, bandwidthMeter, requestHeaders));
     }
 
@@ -84,10 +85,12 @@ public class DataSourceUtil {
         CookieJarContainer container = (CookieJarContainer) client.cookieJar();
         ForwardingCookieHandler handler = new ForwardingCookieHandler(context);
         container.setCookieJar(new JavaNetCookieJar(handler));
-        OkHttpDataSourceFactory okHttpDataSourceFactory = new OkHttpDataSourceFactory(client, getUserAgent(context), bandwidthMeter);
+        OkHttpDataSource.Factory okHttpDataSourceFactory = new OkHttpDataSource.Factory((Call.Factory) client)
+                .setUserAgent(getUserAgent(context))
+                .setTransferListener(bandwidthMeter);
 
         if (requestHeaders != null)
-            okHttpDataSourceFactory.getDefaultRequestProperties().set(requestHeaders);
+            okHttpDataSourceFactory.setDefaultRequestProperties(requestHeaders);
 
         return okHttpDataSourceFactory;
     }
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/DefaultReactExoplayerConfig.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/DefaultReactExoplayerConfig.java
similarity index 60%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/DefaultReactExoplayerConfig.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/DefaultReactExoplayerConfig.java
index d68274b..3475273 100644
--- a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/DefaultReactExoplayerConfig.java
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/DefaultReactExoplayerConfig.java
@@ -9,16 +9,28 @@ import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 public class DefaultReactExoplayerConfig implements ReactExoplayerConfig {
 
     private final DefaultBandwidthMeter bandwidthMeter;
+    private boolean disableDisconnectError = false;
 
     public DefaultReactExoplayerConfig(Context context) {
         this.bandwidthMeter = new DefaultBandwidthMeter.Builder(context).build();
     }
 
-    @Override
     public LoadErrorHandlingPolicy buildLoadErrorHandlingPolicy(int minLoadRetryCount) {
+        if (this.disableDisconnectError) {
+            // Use custom error handling policy to prevent throwing an error when losing network connection
+            return new ReactExoplayerLoadErrorHandlingPolicy(minLoadRetryCount);
+        }
         return new DefaultLoadErrorHandlingPolicy(minLoadRetryCount);
     }
 
+    public void setDisableDisconnectError(boolean disableDisconnectError) {
+        this.disableDisconnectError = disableDisconnectError;
+    }
+
+    public boolean getDisableDisconnectError() {
+        return this.disableDisconnectError;
+    }
+
     @Override
     public DefaultBandwidthMeter getBandwidthMeter() {
         return bandwidthMeter;
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ExoPlayerView.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ExoPlayerView.java
similarity index 69%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ExoPlayerView.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ExoPlayerView.java
index 61cb0dd..e0d65f1 100644
--- a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ExoPlayerView.java
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ExoPlayerView.java
@@ -4,7 +4,7 @@ import android.annotation.TargetApi;
 import android.content.Context;
 import androidx.core.content.ContextCompat;
 import android.util.AttributeSet;
-import android.util.Log;
+import android.util.TypedValue;
 import android.view.Gravity;
 import android.view.SurfaceView;
 import android.view.TextureView;
@@ -13,34 +13,35 @@ import android.view.ViewGroup;
 import android.widget.FrameLayout;
 
 import com.google.android.exoplayer2.C;
-import com.google.android.exoplayer2.ExoPlaybackException;
-import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.PlaybackException;
 import com.google.android.exoplayer2.PlaybackParameters;
-import com.google.android.exoplayer2.SimpleExoPlayer;
-import com.google.android.exoplayer2.video.VideoListener;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.ExoPlayer;
 import com.google.android.exoplayer2.Timeline;
-import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.Tracks;
 import com.google.android.exoplayer2.text.Cue;
-import com.google.android.exoplayer2.text.TextRenderer;
-import com.google.android.exoplayer2.text.TextOutput;
 import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.ui.AdViewProvider;
 import com.google.android.exoplayer2.ui.SubtitleView;
+import com.google.android.exoplayer2.util.Assertions;
+import com.google.android.exoplayer2.video.VideoSize;
 
 import java.util.List;
 
-@TargetApi(16)
-public final class ExoPlayerView extends FrameLayout {
+public final class ExoPlayerView extends FrameLayout implements AdViewProvider {
 
     private View surfaceView;
     private final View shutterView;
     private final SubtitleView subtitleLayout;
     private final AspectRatioFrameLayout layout;
     private final ComponentListener componentListener;
-    private SimpleExoPlayer player;
+    private ExoPlayer player;
     private Context context;
     private ViewGroup.LayoutParams layoutParams;
+    private final FrameLayout adOverlayFrameLayout;
 
     private boolean useTextureView = true;
+    private boolean useSecureView = false;
     private boolean hideShutterView = false;
 
     public ExoPlayerView(Context context) {
@@ -80,8 +81,11 @@ public final class ExoPlayerView extends FrameLayout {
 
         updateSurfaceView();
 
+        adOverlayFrameLayout = new FrameLayout(context);
+
         layout.addView(shutterView, 1, layoutParams);
         layout.addView(subtitleLayout, 2, layoutParams);
+        layout.addView(adOverlayFrameLayout, 3, layoutParams);
 
         addViewInLayout(layout, 0, aspectRatioParams);
     }
@@ -101,9 +105,31 @@ public final class ExoPlayerView extends FrameLayout {
             player.setVideoSurfaceView((SurfaceView) surfaceView);
         }
     }
+    public void setSubtitleStyle(SubtitleStyle style) {
+        // ensure we reset subtile style before reapplying it
+        subtitleLayout.setUserDefaultStyle();
+        subtitleLayout.setUserDefaultTextSize();
+
+        if (style.getFontSize() > 0) {
+            subtitleLayout.setFixedTextSize(TypedValue.COMPLEX_UNIT_SP, style.getFontSize());
+        }
+        subtitleLayout.setPadding(style.getPaddingLeft(), style.getPaddingTop(), style.getPaddingRight(), style.getPaddingBottom());
+    }
+
+    public void setShutterColor(Integer color) {
+        shutterView.setBackgroundColor(color);
+    }
 
     private void updateSurfaceView() {
-        View view = useTextureView ? new TextureView(context) : new SurfaceView(context);
+        View view;
+        if (!useTextureView || useSecureView) {
+            view = new SurfaceView(context);
+            if (useSecureView) {
+                ((SurfaceView)view).setSecure(true);
+            }
+        } else {
+            view = new TextureView(context);
+        }
         view.setLayoutParams(layoutParams);
 
         surfaceView = view;
@@ -121,30 +147,39 @@ public final class ExoPlayerView extends FrameLayout {
         shutterView.setVisibility(this.hideShutterView ? View.INVISIBLE : View.VISIBLE);
     }
 
+    @Override
+    public void requestLayout() {
+        super.requestLayout();
+        post(measureAndLayout);
+    }
+
+     // AdsLoader.AdViewProvider implementation.
+
+    @Override
+    public ViewGroup getAdViewGroup() {
+        return Assertions.checkNotNull(adOverlayFrameLayout, "exo_ad_overlay must be present for ad playback");
+    }
+
     /**
-     * Set the {@link SimpleExoPlayer} to use. The {@link SimpleExoPlayer#addTextOutput} and
-     * {@link SimpleExoPlayer#addVideoListener} method of the player will be called and previous
+     * Set the {@link ExoPlayer} to use. The {@link ExoPlayer#addListener} method of the
+     * player will be called and previous
      * assignments are overridden.
      *
-     * @param player The {@link SimpleExoPlayer} to use.
+     * @param player The {@link ExoPlayer} to use.
      */
-    public void setPlayer(SimpleExoPlayer player) {
+    public void setPlayer(ExoPlayer player) {
         if (this.player == player) {
             return;
         }
         if (this.player != null) {
-            this.player.removeTextOutput(componentListener);
-            this.player.removeVideoListener(componentListener);
             this.player.removeListener(componentListener);
             clearVideoView();
         }
         this.player = player;
-        shutterView.setVisibility(VISIBLE);
+        shutterView.setVisibility(this.hideShutterView ? View.INVISIBLE : View.VISIBLE);
         if (player != null) {
             setVideoView();
-            player.addVideoListener(componentListener);
             player.addListener(componentListener);
-            player.addTextOutput(componentListener);
         }
     }
 
@@ -178,6 +213,13 @@ public final class ExoPlayerView extends FrameLayout {
         }
     }
 
+    public void useSecureView(boolean useSecureView) {
+        if (useSecureView != this.useSecureView) {
+            this.useSecureView = useSecureView;
+            updateSurfaceView();
+        }
+    }
+
     public void setHideShutterView(boolean hideShutterView) {
         this.hideShutterView = hideShutterView;
         updateShutterViewVisibility();
@@ -206,7 +248,7 @@ public final class ExoPlayerView extends FrameLayout {
             }
         }
         // Video disabled so the shutter must be closed.
-        shutterView.setVisibility(VISIBLE);
+        shutterView.setVisibility(this.hideShutterView ? View.INVISIBLE : View.VISIBLE);
     }
 
     public void invalidateAspectRatio() {
@@ -214,22 +256,21 @@ public final class ExoPlayerView extends FrameLayout {
         layout.invalidateAspectRatio();
     }
 
-    private final class ComponentListener implements VideoListener,
-            TextOutput, ExoPlayer.EventListener {
+    private final class ComponentListener implements Player.Listener {
 
         // TextRenderer.Output implementation
 
         @Override
         public void onCues(List<Cue> cues) {
-            subtitleLayout.onCues(cues);
+            subtitleLayout.setCues(cues);
         }
 
-        // SimpleExoPlayer.VideoListener implementation
+        // ExoPlayer.VideoListener implementation
 
         @Override
-        public void onVideoSizeChanged(int width, int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
+        public void onVideoSizeChanged(VideoSize videoSize) {
             boolean isInitialRatio = layout.getAspectRatio() == 0;
-            layout.setAspectRatio(height == 0 ? 1 : (width * pixelWidthHeightRatio) / height);
+            layout.setAspectRatio(videoSize.height == 0 ? 1 : (videoSize.width * videoSize.pixelWidthHeightRatio) / videoSize.height);
 
             // React native workaround for measuring and layout on initial load.
             if (isInitialRatio) {
@@ -245,43 +286,43 @@ public final class ExoPlayerView extends FrameLayout {
         // ExoPlayer.EventListener implementation
 
         @Override
-        public void onLoadingChanged(boolean isLoading) {
+        public void onIsLoadingChanged(boolean isLoading) {
             // Do nothing.
         }
 
         @Override
-        public void onPlayerStateChanged(boolean playWhenReady, int playbackState) {
+        public void onPlaybackStateChanged(int playbackState) {
             // Do nothing.
         }
 
         @Override
-        public void onPlayerError(ExoPlaybackException e) {
+        public void onPlayWhenReadyChanged(boolean playWhenReady, int reason) {
             // Do nothing.
         }
 
         @Override
-        public void onPositionDiscontinuity(int reason) {
+        public void onPlayerError(PlaybackException e) {
             // Do nothing.
         }
 
         @Override
-        public void onTimelineChanged(Timeline timeline, Object manifest, int reason) {
+        public void onPositionDiscontinuity(Player.PositionInfo oldPosition, Player.PositionInfo newPosition, int reason) {
             // Do nothing.
         }
 
         @Override
-        public void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections) {
-            updateForCurrentTrackSelections();
+        public void onTimelineChanged(Timeline timeline, int reason) {
+            // Do nothing.
         }
 
         @Override
-        public void onPlaybackParametersChanged(PlaybackParameters params) {
-            // Do nothing
+        public void onTracksChanged(Tracks tracks) {
+            updateForCurrentTrackSelections();
         }
 
         @Override
-        public void onSeekProcessed() {
-            // Do nothing.
+        public void onPlaybackParametersChanged(PlaybackParameters params) {
+            // Do nothing
         }
 
         @Override
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/FullScreenPlayerView.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/FullScreenPlayerView.java
new file mode 100644
index 0000000..f57bb96
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/FullScreenPlayerView.java
@@ -0,0 +1,80 @@
+package com.brentvatne.exoplayer;
+
+import android.app.Dialog;
+import android.content.Context;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.ImageButton;
+
+import androidx.activity.OnBackPressedCallback;
+
+import com.google.android.exoplayer2.ui.PlayerControlView;
+
+public class FullScreenPlayerView extends Dialog {
+  private final PlayerControlView playerControlView;
+  private final ExoPlayerView exoPlayerView;
+  private ViewGroup parent;
+  private final FrameLayout containerView;
+  private final OnBackPressedCallback onBackPressedCallback;
+
+  public FullScreenPlayerView(Context context, ExoPlayerView exoPlayerView, PlayerControlView playerControlView, OnBackPressedCallback onBackPressedCallback) {
+    super(context, android.R.style.Theme_Black_NoTitleBar_Fullscreen);
+    this.playerControlView = playerControlView;
+    this.exoPlayerView = exoPlayerView;
+    this.onBackPressedCallback = onBackPressedCallback;
+    containerView = new FrameLayout(context);
+    setContentView(containerView, generateDefaultLayoutParams());
+  }
+
+  @Override
+  public void onBackPressed() {
+    super.onBackPressed();
+    onBackPressedCallback.handleOnBackPressed();
+  }
+
+  @Override
+  protected void onStart() {
+    parent = (FrameLayout)(exoPlayerView.getParent());
+
+    parent.removeView(exoPlayerView);
+    containerView.addView(exoPlayerView, generateDefaultLayoutParams());
+
+    if (playerControlView != null) {
+      ImageButton imageButton = playerControlView.findViewById(com.brentvatne.react.R.id.exo_fullscreen);
+      imageButton.setImageResource(com.google.android.exoplayer2.ui.R.drawable.exo_icon_fullscreen_exit);
+      imageButton.setContentDescription(getContext().getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fullscreen_exit_description));
+      parent.removeView(playerControlView);
+      containerView.addView(playerControlView, generateDefaultLayoutParams());
+    }
+
+    super.onStart();
+  }
+
+  @Override
+  protected void onStop() {
+    containerView.removeView(exoPlayerView);
+    parent.addView(exoPlayerView, generateDefaultLayoutParams());
+
+    if (playerControlView != null) {
+      ImageButton imageButton = playerControlView.findViewById(com.brentvatne.react.R.id.exo_fullscreen);
+      imageButton.setImageResource(com.google.android.exoplayer2.ui.R.drawable.exo_icon_fullscreen_enter);
+      imageButton.setContentDescription(getContext().getString(com.google.android.exoplayer2.ui.R.string.exo_controls_fullscreen_enter_description));
+      containerView.removeView(playerControlView);
+      parent.addView(playerControlView, generateDefaultLayoutParams());
+    }
+
+    parent.requestLayout();
+    parent = null;
+
+    super.onStop();
+  }
+
+  private FrameLayout.LayoutParams generateDefaultLayoutParams() {
+    FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(
+        FrameLayout.LayoutParams.MATCH_PARENT,
+        FrameLayout.LayoutParams.MATCH_PARENT
+    );
+    layoutParams.setMargins(0, 0, 0, 0);
+    return layoutParams;
+  }
+}
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/RawResourceDataSourceFactory.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/RawResourceDataSourceFactory.java
similarity index 100%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/RawResourceDataSourceFactory.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/RawResourceDataSourceFactory.java
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ReactExoplayerConfig.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerConfig.java
similarity index 78%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ReactExoplayerConfig.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerConfig.java
index 522578b..2cc56f9 100644
--- a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ReactExoplayerConfig.java
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerConfig.java
@@ -9,5 +9,8 @@ import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy;
 public interface ReactExoplayerConfig {
     LoadErrorHandlingPolicy buildLoadErrorHandlingPolicy(int minLoadRetryCount);
 
+    void setDisableDisconnectError(boolean disableDisconnectError);
+    boolean getDisableDisconnectError();
+
     DefaultBandwidthMeter getBandwidthMeter();
 }
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerLoadErrorHandlingPolicy.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerLoadErrorHandlingPolicy.java
new file mode 100644
index 0000000..d0d68de
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerLoadErrorHandlingPolicy.java
@@ -0,0 +1,36 @@
+package com.brentvatne.exoplayer;
+
+import java.io.IOException;
+import com.google.android.exoplayer2.upstream.DefaultLoadErrorHandlingPolicy;
+import com.google.android.exoplayer2.upstream.HttpDataSource.HttpDataSourceException;
+import com.google.android.exoplayer2.upstream.LoadErrorHandlingPolicy.LoadErrorInfo;
+import com.google.android.exoplayer2.C;
+
+public final class ReactExoplayerLoadErrorHandlingPolicy extends DefaultLoadErrorHandlingPolicy {
+  private int minLoadRetryCount = Integer.MAX_VALUE;
+
+  public ReactExoplayerLoadErrorHandlingPolicy(int minLoadRetryCount) {
+    super(minLoadRetryCount);
+    this.minLoadRetryCount = minLoadRetryCount;
+  }
+
+  @Override
+  public long getRetryDelayMsFor(LoadErrorInfo loadErrorInfo) {
+    if (
+      loadErrorInfo.exception instanceof HttpDataSourceException &&
+      (loadErrorInfo.exception.getMessage() == "Unable to connect" || loadErrorInfo.exception.getMessage() == "Software caused connection abort")
+    ) {
+      // Capture the error we get when there is no network connectivity and keep retrying it
+      return 1000; // Retry every second
+    } else if(loadErrorInfo.errorCount < this.minLoadRetryCount) {
+      return Math.min((loadErrorInfo.errorCount - 1) * 1000, 5000); // Default timeout handling
+    } else {
+      return C.TIME_UNSET; // Done retrying and will return the error immediately
+    }
+  }
+
+  @Override
+  public int getMinimumLoadableRetryCount(int dataType) {
+    return Integer.MAX_VALUE;
+  }
+}
\ No newline at end of file
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerView.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerView.java
new file mode 100644
index 0000000..544c6ac
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerView.java
@@ -0,0 +1,2050 @@
+package com.brentvatne.exoplayer;
+
+import static com.google.android.exoplayer2.C.CONTENT_TYPE_DASH;
+import static com.google.android.exoplayer2.C.CONTENT_TYPE_HLS;
+import static com.google.android.exoplayer2.C.CONTENT_TYPE_OTHER;
+import static com.google.android.exoplayer2.C.CONTENT_TYPE_SS;
+import static com.google.android.exoplayer2.C.TIME_END_OF_SOURCE;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.content.Context;
+import android.media.AudioManager;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.View;
+import android.view.Window;
+import android.view.accessibility.CaptioningManager;
+import android.widget.FrameLayout;
+import android.widget.ImageButton;
+
+import androidx.annotation.WorkerThread;
+import androidx.activity.OnBackPressedCallback;
+
+import com.brentvatne.common.Track;
+import com.brentvatne.common.VideoTrack;
+import com.brentvatne.react.R;
+import com.brentvatne.receiver.AudioBecomingNoisyReceiver;
+import com.brentvatne.receiver.BecomingNoisyListener;
+import com.facebook.react.bridge.Dynamic;
+import com.facebook.react.bridge.LifecycleEventListener;
+import com.facebook.react.bridge.ReadableArray;
+import com.facebook.react.bridge.ReadableMap;
+import com.facebook.react.uimanager.ThemedReactContext;
+import com.google.ads.interactivemedia.v3.api.AdEvent;
+import com.google.android.exoplayer2.C;
+import com.google.android.exoplayer2.DefaultLoadControl;
+import com.google.android.exoplayer2.DefaultRenderersFactory;
+import com.google.android.exoplayer2.Format;
+import com.google.android.exoplayer2.MediaItem;
+import com.google.android.exoplayer2.PlaybackException;
+import com.google.android.exoplayer2.PlaybackParameters;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Timeline;
+import com.google.android.exoplayer2.Tracks;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManager;
+import com.google.android.exoplayer2.drm.DefaultDrmSessionManagerProvider;
+import com.google.android.exoplayer2.drm.DrmSessionEventListener;
+import com.google.android.exoplayer2.drm.DrmSessionManager;
+import com.google.android.exoplayer2.drm.DrmSessionManagerProvider;
+import com.google.android.exoplayer2.drm.FrameworkMediaDrm;
+import com.google.android.exoplayer2.drm.HttpMediaDrmCallback;
+import com.google.android.exoplayer2.drm.UnsupportedDrmException;
+import com.google.android.exoplayer2.mediacodec.MediaCodecInfo;
+import com.google.android.exoplayer2.mediacodec.MediaCodecUtil;
+import com.google.android.exoplayer2.metadata.Metadata;
+import com.google.android.exoplayer2.source.MediaSource;
+import com.google.android.exoplayer2.source.MergingMediaSource;
+import com.google.android.exoplayer2.source.ProgressiveMediaSource;
+import com.google.android.exoplayer2.source.SingleSampleMediaSource;
+import com.google.android.exoplayer2.source.TrackGroup;
+import com.google.android.exoplayer2.source.TrackGroupArray;
+import com.google.android.exoplayer2.source.dash.DashMediaSource;
+import com.google.android.exoplayer2.source.dash.DefaultDashChunkSource;
+import com.google.android.exoplayer2.source.hls.HlsMediaSource;
+import com.google.android.exoplayer2.source.smoothstreaming.DefaultSsChunkSource;
+import com.google.android.exoplayer2.source.smoothstreaming.SsMediaSource;
+import com.google.android.exoplayer2.trackselection.AdaptiveTrackSelection;
+import com.google.android.exoplayer2.trackselection.DefaultTrackSelector;
+import com.google.android.exoplayer2.trackselection.MappingTrackSelector;
+import com.google.android.exoplayer2.trackselection.ExoTrackSelection;
+import com.google.android.exoplayer2.trackselection.TrackSelectionArray;
+import com.google.android.exoplayer2.trackselection.TrackSelectionOverride;
+import com.google.android.exoplayer2.ui.PlayerControlView;
+import com.google.android.exoplayer2.upstream.BandwidthMeter;
+import com.google.android.exoplayer2.upstream.DataSource;
+import com.google.android.exoplayer2.upstream.DataSpec;
+import com.google.android.exoplayer2.upstream.DefaultAllocator;
+import com.google.android.exoplayer2.upstream.DefaultBandwidthMeter;
+import com.google.android.exoplayer2.upstream.HttpDataSource;
+import com.google.android.exoplayer2.util.Util;
+import com.google.android.exoplayer2.trackselection.TrackSelection;
+import com.google.android.exoplayer2.source.dash.DashUtil;
+import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
+import com.google.android.exoplayer2.source.dash.manifest.Period;
+import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
+import com.google.android.exoplayer2.source.dash.manifest.Representation;
+
+import com.google.android.exoplayer2.ext.ima.ImaAdsLoader;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
+import com.google.android.exoplayer2.source.DefaultMediaSourceFactory;
+import com.google.android.exoplayer2.source.ClippingMediaSource;
+
+import com.google.common.collect.ImmutableList;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.CookiePolicy;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.UUID;
+import java.util.Map;
+import java.lang.Thread;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.lang.Integer;
+
+@SuppressLint("ViewConstructor")
+class ReactExoplayerView extends FrameLayout implements
+        LifecycleEventListener,
+        Player.Listener,
+        BandwidthMeter.EventListener,
+        BecomingNoisyListener,
+        DrmSessionEventListener,
+        AdEvent.AdEventListener {
+
+    public static final double DEFAULT_MAX_HEAP_ALLOCATION_PERCENT = 1;
+    public static final double DEFAULT_MIN_BACK_BUFFER_MEMORY_RESERVE = 0;
+    public static final double DEFAULT_MIN_BUFFER_MEMORY_RESERVE = 0;
+
+    private static final String TAG = "ReactExoplayerView";
+
+    private static final CookieManager DEFAULT_COOKIE_MANAGER;
+    private static final int SHOW_PROGRESS = 1;
+
+    static {
+        DEFAULT_COOKIE_MANAGER = new CookieManager();
+        DEFAULT_COOKIE_MANAGER.setCookiePolicy(CookiePolicy.ACCEPT_ORIGINAL_SERVER);
+    }
+
+    private final VideoEventEmitter eventEmitter;
+    private final ReactExoplayerConfig config;
+    private final DefaultBandwidthMeter bandwidthMeter;
+    private PlayerControlView playerControlView;
+    private View playPauseControlContainer;
+    private Player.Listener eventListener;
+
+    private ExoPlayerView exoPlayerView;
+    private FullScreenPlayerView fullScreenPlayerView;
+    private ImaAdsLoader adsLoader;
+
+    private DataSource.Factory mediaDataSourceFactory;
+    private ExoPlayer player;
+    private DefaultTrackSelector trackSelector;
+    private boolean playerNeedsSource;
+
+    private int resumeWindow;
+    private long resumePosition;
+    private boolean loadVideoStarted;
+    private boolean isFullscreen;
+    private boolean isInBackground;
+    private boolean isPaused;
+    private boolean isBuffering;
+    private boolean muted = false;
+    private boolean hasAudioFocus = false;
+    private float rate = 1f;
+    private float audioVolume = 1f;
+    private int minLoadRetryCount = 3;
+    private int maxBitRate = 0;
+    private long seekTime = C.TIME_UNSET;
+    private boolean hasDrmFailed = false;
+    private boolean isUsingContentResolution = false;
+    private boolean selectTrackWhenReady = false;
+
+    private int minBufferMs = DefaultLoadControl.DEFAULT_MIN_BUFFER_MS;
+    private int maxBufferMs = DefaultLoadControl.DEFAULT_MAX_BUFFER_MS;
+    private int bufferForPlaybackMs = DefaultLoadControl.DEFAULT_BUFFER_FOR_PLAYBACK_MS;
+    private int bufferForPlaybackAfterRebufferMs = DefaultLoadControl.DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS;
+    private double maxHeapAllocationPercent = ReactExoplayerView.DEFAULT_MAX_HEAP_ALLOCATION_PERCENT;
+    private double minBackBufferMemoryReservePercent = ReactExoplayerView.DEFAULT_MIN_BACK_BUFFER_MEMORY_RESERVE;
+    private double minBufferMemoryReservePercent = ReactExoplayerView.DEFAULT_MIN_BUFFER_MEMORY_RESERVE;
+    private Handler mainHandler;
+
+    // Props from React
+    private int backBufferDurationMs = DefaultLoadControl.DEFAULT_BACK_BUFFER_DURATION_MS;
+    private Uri srcUri;
+    private long startTimeMs = -1;
+    private long endTimeMs = -1;
+    private String extension;
+    private boolean repeat;
+    private String audioTrackType;
+    private Dynamic audioTrackValue;
+    private String videoTrackType;
+    private Dynamic videoTrackValue;
+    private String textTrackType;
+    private Dynamic textTrackValue;
+    private ReadableArray textTracks;
+    private boolean disableFocus;
+    private boolean focusable = true;
+    private boolean disableBuffering;
+    private long contentStartTime = -1L;
+    private boolean disableDisconnectError;
+    private boolean preventsDisplaySleepDuringVideoPlayback = true;
+    private float mProgressUpdateInterval = 250.0f;
+    private boolean playInBackground = false;
+    private Map<String, String> requestHeaders;
+    private boolean mReportBandwidth = false;
+    private UUID drmUUID = null;
+    private String drmLicenseUrl = null;
+    private String[] drmLicenseHeader = null;
+    private boolean controls;
+    private Uri adTagUrl;
+    // \ End props
+
+    // React
+    private final ThemedReactContext themedReactContext;
+    private final AudioManager audioManager;
+    private final AudioBecomingNoisyReceiver audioBecomingNoisyReceiver;
+    private final AudioManager.OnAudioFocusChangeListener audioFocusChangeListener;
+
+    // store last progress event values to avoid sending unnecessary messages
+    private long lastPos = -1;
+    private long lastBufferDuration = -1;
+    private long lastDuration = -1;
+
+    private final Handler progressHandler = new Handler(Looper.getMainLooper()) {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case SHOW_PROGRESS:
+                    if (player != null) {
+                        if (playerControlView != null && isPlayingAd() && controls) {
+                            playerControlView.hide();
+                        }
+                        long pos = player.getCurrentPosition();
+                        long bufferedDuration = player.getBufferedPercentage() * player.getDuration() / 100;
+                        long duration = player.getDuration();
+
+                        if (lastPos != pos
+                                || lastBufferDuration != bufferedDuration
+                                || lastDuration != duration) {
+                            lastPos = pos;
+                            lastBufferDuration = bufferedDuration;
+                            lastDuration = duration;
+                            eventEmitter.progressChanged(pos, bufferedDuration, player.getDuration(), getPositionInFirstPeriodMsForCurrentWindow(pos));
+                        }
+                        msg = obtainMessage(SHOW_PROGRESS);
+                        sendMessageDelayed(msg, Math.round(mProgressUpdateInterval));
+                    }
+                    break;
+            }
+        }
+    };
+
+    public double getPositionInFirstPeriodMsForCurrentWindow(long currentPosition) {
+        Timeline.Window window = new Timeline.Window();
+        if(!player.getCurrentTimeline().isEmpty()) {
+            player.getCurrentTimeline().getWindow(player.getCurrentMediaItemIndex(), window);
+        }
+        return window.windowStartTimeMs + currentPosition;
+    }
+
+    public ReactExoplayerView(ThemedReactContext context, ReactExoplayerConfig config) {
+        super(context);
+        this.themedReactContext = context;
+        this.eventEmitter = new VideoEventEmitter(context);
+        this.config = config;
+        this.bandwidthMeter = config.getBandwidthMeter();
+
+        createViews();
+
+        audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
+        themedReactContext.addLifecycleEventListener(this);
+        audioBecomingNoisyReceiver = new AudioBecomingNoisyReceiver(themedReactContext);
+        audioFocusChangeListener = new OnAudioFocusChangedListener(this);
+    }
+
+    private boolean isPlayingAd() {
+        return player != null && player.isPlayingAd();
+    }
+
+    @Override
+    public void setId(int id) {
+        super.setId(id);
+        eventEmitter.setViewId(id);
+    }
+
+    private void createViews() {
+        clearResumePosition();
+        mediaDataSourceFactory = buildDataSourceFactory(true);
+        if (CookieHandler.getDefault() != DEFAULT_COOKIE_MANAGER) {
+            CookieHandler.setDefault(DEFAULT_COOKIE_MANAGER);
+        }
+
+        LayoutParams layoutParams = new LayoutParams(
+                LayoutParams.MATCH_PARENT,
+                LayoutParams.MATCH_PARENT);
+        exoPlayerView = new ExoPlayerView(getContext());
+        exoPlayerView.setLayoutParams(layoutParams);
+
+        addView(exoPlayerView, 0, layoutParams);
+
+        exoPlayerView.setFocusable(this.focusable);
+
+        mainHandler = new Handler();
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        initializePlayer();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        /* We want to be able to continue playing audio when switching tabs.
+         * Leave this here in case it causes issues.
+         */
+        // stopPlayback();
+    }
+
+    // LifecycleEventListener implementation
+
+    @Override
+    public void onHostResume() {
+        if (!playInBackground || !isInBackground) {
+            setPlayWhenReady(!isPaused);
+        }
+        isInBackground = false;
+    }
+
+    @Override
+    public void onHostPause() {
+        isInBackground = true;
+        if (playInBackground) {
+            return;
+        }
+        setPlayWhenReady(false);
+    }
+
+    @Override
+    public void onHostDestroy() {
+        stopPlayback();
+    }
+
+    public void cleanUpResources() {
+        stopPlayback();
+    }
+
+    //BandwidthMeter.EventListener implementation
+    @Override
+    public void onBandwidthSample(int elapsedMs, long bytes, long bitrate) {
+        if (mReportBandwidth) {
+            if (player == null) {
+                eventEmitter.bandwidthReport(bitrate, 0, 0, "-1");
+            } else {
+                Format videoFormat = player.getVideoFormat();
+                int width = videoFormat != null ? videoFormat.width : 0;
+                int height = videoFormat != null ? videoFormat.height : 0;
+                String trackId = videoFormat != null ? videoFormat.id : "-1";
+                eventEmitter.bandwidthReport(bitrate, height, width, trackId);
+            }
+        }
+    }
+
+    // Internal methods
+
+    /**
+     * Toggling the visibility of the player control view
+     */
+    private void togglePlayerControlVisibility() {
+        if(player == null) return;
+        reLayout(playerControlView);
+        if (playerControlView.isVisible()) {
+            playerControlView.hide();
+        } else {
+            playerControlView.show();
+        }
+    }
+
+    /**
+     * Initializing Player control
+     */
+    private void initializePlayerControl() {
+        if (playerControlView == null) {
+            playerControlView = new PlayerControlView(getContext());
+        }
+
+        if (fullScreenPlayerView == null) {
+            fullScreenPlayerView = new FullScreenPlayerView(getContext(), exoPlayerView, playerControlView, new OnBackPressedCallback(true) {
+                @Override
+                public void handleOnBackPressed() {
+                    setFullscreen(false);
+                }
+            });
+        }
+
+        // Setting the player for the playerControlView
+        playerControlView.setPlayer(player);
+        playPauseControlContainer = playerControlView.findViewById(R.id.exo_play_pause_container);
+
+        // Invoking onClick event for exoplayerView
+        exoPlayerView.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (!isPlayingAd()) {
+                    togglePlayerControlVisibility();
+                }
+            }
+        });
+
+        //Handling the playButton click event
+        ImageButton playButton = playerControlView.findViewById(R.id.exo_play);
+        playButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (player != null && player.getPlaybackState() == Player.STATE_ENDED) {
+                    player.seekTo(0);
+                }
+                setPausedModifier(false);
+            }
+        });
+
+        //Handling the pauseButton click event
+        ImageButton pauseButton = playerControlView.findViewById(R.id.exo_pause);
+        pauseButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                setPausedModifier(true);
+            }
+        });
+
+        //Handling the fullScreenButton click event
+        final ImageButton fullScreenButton = playerControlView.findViewById(R.id.exo_fullscreen);
+        fullScreenButton.setOnClickListener(v -> setFullscreen(!isFullscreen));
+        updateFullScreenButtonVisbility();
+
+        // Invoking onPlaybackStateChanged and onPlayWhenReadyChanged events for Player
+        eventListener = new Player.Listener() {
+            @Override
+            public void onPlaybackStateChanged(int playbackState) {
+                View playButton = playerControlView.findViewById(R.id.exo_play);
+                View pauseButton = playerControlView.findViewById(R.id.exo_pause);
+                if (playButton != null && playButton.getVisibility() == GONE) {
+                    playButton.setVisibility(INVISIBLE);
+                }
+                if (pauseButton != null && pauseButton.getVisibility() == GONE) {
+                    pauseButton.setVisibility(INVISIBLE);
+                }
+                reLayout(playPauseControlContainer);
+                //Remove this eventListener once its executed. since UI will work fine once after the reLayout is done
+                player.removeListener(eventListener);
+            }
+
+            @Override
+            public void onPlayWhenReadyChanged(boolean playWhenReady, int reason) {
+                reLayout(playPauseControlContainer);
+                //Remove this eventListener once its executed. since UI will work fine once after the reLayout is done
+                player.removeListener(eventListener);
+            }
+        };
+        player.addListener(eventListener);
+    }
+
+    /**
+     * Adding Player control to the frame layout
+     */
+    private void addPlayerControl() {
+        if(playerControlView == null) return;
+        LayoutParams layoutParams = new LayoutParams(
+                LayoutParams.MATCH_PARENT,
+                LayoutParams.MATCH_PARENT);
+        playerControlView.setLayoutParams(layoutParams);
+        int indexOfPC = indexOfChild(playerControlView);
+        if (indexOfPC != -1) {
+            removeViewAt(indexOfPC);
+        }
+        addView(playerControlView, 1, layoutParams);
+        reLayout(playerControlView);
+    }
+
+    /**
+     * Update the layout
+     * @param view  view needs to update layout
+     *
+     * This is a workaround for the open bug in react-native: https://github.com/facebook/react-native/issues/17968
+     */
+    private void reLayout(View view) {
+        if (view == null) return;
+        view.measure(MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
+                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
+        view.layout(view.getLeft(), view.getTop(), view.getMeasuredWidth(), view.getMeasuredHeight());
+    }
+
+    private class RNVLoadControl extends DefaultLoadControl {
+        private int availableHeapInBytes = 0;
+        private Runtime runtime;
+        public RNVLoadControl(DefaultAllocator allocator, int minBufferMs, int maxBufferMs, int bufferForPlaybackMs, int bufferForPlaybackAfterRebufferMs, int targetBufferBytes, boolean prioritizeTimeOverSizeThresholds, int backBufferDurationMs, boolean retainBackBufferFromKeyframe) {
+            super(allocator,
+                    minBufferMs,
+                    maxBufferMs,
+                    bufferForPlaybackMs,
+                    bufferForPlaybackAfterRebufferMs,
+                    targetBufferBytes,
+                    prioritizeTimeOverSizeThresholds,
+                    backBufferDurationMs,
+                    retainBackBufferFromKeyframe);
+            runtime = Runtime.getRuntime();
+            ActivityManager activityManager = (ActivityManager) themedReactContext.getSystemService(themedReactContext.ACTIVITY_SERVICE);
+            availableHeapInBytes = (int) Math.floor(activityManager.getMemoryClass() * maxHeapAllocationPercent * 1024 * 1024);
+        }
+
+        @Override
+        public boolean shouldContinueLoading(long playbackPositionUs, long bufferedDurationUs, float playbackSpeed) {
+            if (ReactExoplayerView.this.disableBuffering) {
+                return false;
+            }
+            int loadedBytes = getAllocator().getTotalBytesAllocated();
+            boolean isHeapReached = availableHeapInBytes > 0 && loadedBytes >= availableHeapInBytes;
+            if (isHeapReached) {
+                return false;
+            }
+            long usedMemory = runtime.totalMemory() - runtime.freeMemory();
+            long freeMemory = runtime.maxMemory() - usedMemory;
+            long reserveMemory = (long)minBufferMemoryReservePercent * runtime.maxMemory();
+            long bufferedMs = bufferedDurationUs / (long)1000;
+            if (reserveMemory > freeMemory && bufferedMs > 2000) {
+                // We don't have enough memory in reserve so we stop buffering to allow other components to use it instead
+                return false;
+            }
+            if (runtime.freeMemory() == 0) {
+                Log.w("ExoPlayer Warning", "Free memory reached 0, forcing garbage collection");
+                runtime.gc();
+                return false;
+            }
+            return super.shouldContinueLoading(playbackPositionUs, bufferedDurationUs, playbackSpeed);
+        }
+    }
+
+    private void startBufferCheckTimer() {
+        Player player = this.player;
+        VideoEventEmitter eventEmitter = this.eventEmitter;
+        Handler mainHandler = this.mainHandler;
+
+    }
+
+    private void initializePlayer() {
+        ReactExoplayerView self = this;
+        Activity activity = themedReactContext.getCurrentActivity();
+        // This ensures all props have been settled, to avoid async racing conditions.
+        new Handler().postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    if (player == null) {
+                        // Initialize core configuration and listeners
+                        initializePlayerCore(self);
+                    }
+                    if (playerNeedsSource && srcUri != null) {
+                        exoPlayerView.invalidateAspectRatio();
+                        // DRM session manager creation must be done on a different thread to prevent crashes so we start a new thread
+                        ExecutorService es = Executors.newSingleThreadExecutor();
+                        es.execute(new Runnable() {
+                            @Override
+                            public void run() {
+                                // DRM initialization must run on a different thread
+                                DrmSessionManager drmSessionManager = initializePlayerDrm(self);
+                                if (drmSessionManager == null && self.drmUUID != null) {
+                                    // Failed to intialize DRM session manager - cannot continue
+                                    Log.e("ExoPlayer Exception", "Failed to initialize DRM Session Manager Framework!");
+                                    eventEmitter.error("Failed to initialize DRM Session Manager Framework!", new Exception("DRM Session Manager Framework failure!"), "3003");
+                                    return;
+                                }
+                                    
+                                if (activity == null) {
+                                    Log.e("ExoPlayer Exception", "Failed to initialize Player!");
+                                    eventEmitter.error("Failed to initialize Player!", new Exception("Current Activity is null!"), "1001");
+                                    return;
+                                }
+
+                                // Initialize handler to run on the main thread
+                                activity.runOnUiThread(new Runnable() {
+                                    public void run() {
+                                        try {
+                                            // Source initialization must run on the main thread
+                                            initializePlayerSource(self, drmSessionManager);
+                                        } catch (Exception ex) {
+                                            self.playerNeedsSource = true;
+                                            Log.e("ExoPlayer Exception", "Failed to initialize Player!");
+                                            Log.e("ExoPlayer Exception", ex.toString());
+                                            self.eventEmitter.error(ex.toString(), ex, "1001");
+                                        }
+                                    }
+                                });
+                            }
+                        });
+                    } else if (srcUri != null) {
+                        initializePlayerSource(self, null);
+                    }
+                } catch (Exception ex) {
+                    self.playerNeedsSource = true;
+                    Log.e("ExoPlayer Exception", "Failed to initialize Player!");
+                    Log.e("ExoPlayer Exception", ex.toString());
+                    eventEmitter.error(ex.toString(), ex, "1001");
+                }
+            }
+        }, 1);
+
+    }
+
+    private void initializePlayerCore(ReactExoplayerView self) {
+        ExoTrackSelection.Factory videoTrackSelectionFactory = new AdaptiveTrackSelection.Factory();
+        self.trackSelector = new DefaultTrackSelector(getContext(), videoTrackSelectionFactory);
+        self.trackSelector.setParameters(trackSelector.buildUponParameters()
+                .setMaxVideoBitrate(maxBitRate == 0 ? Integer.MAX_VALUE : maxBitRate));
+
+        DefaultAllocator allocator = new DefaultAllocator(true, C.DEFAULT_BUFFER_SEGMENT_SIZE);
+        RNVLoadControl loadControl = new RNVLoadControl(
+                allocator,
+                minBufferMs,
+                maxBufferMs,
+                bufferForPlaybackMs,
+                bufferForPlaybackAfterRebufferMs,
+                -1,
+                true,
+                backBufferDurationMs,
+                DefaultLoadControl.DEFAULT_RETAIN_BACK_BUFFER_FROM_KEYFRAME
+        );
+        DefaultRenderersFactory renderersFactory =
+                new DefaultRenderersFactory(getContext())
+                        .setExtensionRendererMode(DefaultRenderersFactory.EXTENSION_RENDERER_MODE_OFF);
+
+        // Create an AdsLoader.
+        adsLoader = new ImaAdsLoader.Builder(themedReactContext).setAdEventListener(this).build();
+
+        MediaSource.Factory mediaSourceFactory = new DefaultMediaSourceFactory(mediaDataSourceFactory)
+            .setLocalAdInsertionComponents(unusedAdTagUri -> adsLoader, exoPlayerView);
+
+        player = new ExoPlayer.Builder(getContext(), renderersFactory)
+                    .setTrackSelector(self.trackSelector)
+                    .setBandwidthMeter(bandwidthMeter)
+                    .setLoadControl(loadControl)
+                    .setMediaSourceFactory(mediaSourceFactory)
+                    .build();
+        player.addListener(self);
+        exoPlayerView.setPlayer(player);
+        if (adsLoader != null) {
+            adsLoader.setPlayer(player);
+        }
+        audioBecomingNoisyReceiver.setListener(self);
+        bandwidthMeter.addEventListener(new Handler(), self);
+        setPlayWhenReady(!isPaused);
+        playerNeedsSource = true;
+
+        PlaybackParameters params = new PlaybackParameters(rate, 1f);
+        player.setPlaybackParameters(params);
+    }
+
+    private DrmSessionManager initializePlayerDrm(ReactExoplayerView self) {
+        DrmSessionManager drmSessionManager = null;
+        if (self.drmUUID != null) {
+            try {
+                drmSessionManager = self.buildDrmSessionManager(self.drmUUID, self.drmLicenseUrl,
+                        self.drmLicenseHeader);
+            } catch (UnsupportedDrmException e) {
+                int errorStringId = Util.SDK_INT < 18 ? R.string.error_drm_not_supported
+                        : (e.reason == UnsupportedDrmException.REASON_UNSUPPORTED_SCHEME
+                        ? R.string.error_drm_unsupported_scheme : R.string.error_drm_unknown);
+                eventEmitter.error(getResources().getString(errorStringId), e, "3003");
+                return null;
+            }
+        }
+        return drmSessionManager;
+    }
+
+    private void initializePlayerSource(ReactExoplayerView self, DrmSessionManager drmSessionManager) {
+        ArrayList<MediaSource> mediaSourceList = buildTextSources();
+        MediaSource videoSource = buildMediaSource(self.srcUri, self.extension, drmSessionManager, startTimeMs, endTimeMs);
+        MediaSource mediaSourceWithAds = null;
+        if (adTagUrl != null) {
+            MediaSource.Factory mediaSourceFactory = new DefaultMediaSourceFactory(mediaDataSourceFactory)
+                    .setLocalAdInsertionComponents(unusedAdTagUri -> adsLoader, exoPlayerView);
+            DataSpec adTagDataSpec = new DataSpec(adTagUrl);
+            mediaSourceWithAds = new AdsMediaSource(videoSource, adTagDataSpec, ImmutableList.of(srcUri, adTagUrl), mediaSourceFactory, adsLoader, exoPlayerView);
+        }
+        MediaSource mediaSource;
+        if (mediaSourceList.size() == 0) {
+            if (mediaSourceWithAds != null) {
+                mediaSource = mediaSourceWithAds;
+            } else {
+                mediaSource = videoSource;
+            }
+        } else {
+            if (mediaSourceWithAds != null) {
+                mediaSourceList.add(0, mediaSourceWithAds);
+            } else {
+                mediaSourceList.add(0, videoSource);
+            }
+            MediaSource[] textSourceArray = mediaSourceList.toArray(
+                    new MediaSource[mediaSourceList.size()]
+            );
+            mediaSource = new MergingMediaSource(textSourceArray);
+        }
+
+        // wait for player to be set
+        while (player == null) {
+            try {
+                wait();
+            } catch (InterruptedException ex) {
+                Thread.currentThread().interrupt();
+                Log.e("ExoPlayer Exception", ex.toString());
+            }
+        }
+
+        boolean haveResumePosition = resumeWindow != C.INDEX_UNSET;
+        if (haveResumePosition) {
+            player.seekTo(resumeWindow, resumePosition);
+        }
+        player.prepare(mediaSource, !haveResumePosition, false);
+        playerNeedsSource = false;
+
+        reLayout(exoPlayerView);
+        eventEmitter.loadStart();
+        loadVideoStarted = true;
+
+        finishPlayerInitialization();
+    }
+
+    private void finishPlayerInitialization() {
+        // Initializing the playerControlView
+        initializePlayerControl();
+        setControls(controls);
+        applyModifiers();
+        startBufferCheckTimer();
+    }
+
+    private DrmSessionManager buildDrmSessionManager(UUID uuid, String licenseUrl, String[] keyRequestPropertiesArray) throws UnsupportedDrmException {
+        return buildDrmSessionManager(uuid, licenseUrl, keyRequestPropertiesArray, 0);
+    }
+
+    private DrmSessionManager buildDrmSessionManager(UUID uuid, String licenseUrl, String[] keyRequestPropertiesArray, int retryCount) throws UnsupportedDrmException {
+        if (Util.SDK_INT < 18) {
+            return null;
+        }
+        try {
+            HttpMediaDrmCallback drmCallback = new HttpMediaDrmCallback(licenseUrl,
+                    buildHttpDataSourceFactory(false));
+            if (keyRequestPropertiesArray != null) {
+                for (int i = 0; i < keyRequestPropertiesArray.length - 1; i += 2) {
+                    drmCallback.setKeyRequestProperty(keyRequestPropertiesArray[i], keyRequestPropertiesArray[i + 1]);
+                }
+            }
+            FrameworkMediaDrm mediaDrm = FrameworkMediaDrm.newInstance(uuid);
+            if (hasDrmFailed) {
+                // When DRM fails using L1 we want to switch to L3
+                mediaDrm.setPropertyString("securityLevel", "L3");
+            }
+            return new DefaultDrmSessionManager(uuid, mediaDrm, drmCallback, null, false, 3);
+        } catch(UnsupportedDrmException ex) {
+            // Unsupported DRM exceptions are handled by the calling method
+            throw ex;
+        } catch (Exception ex) {
+            if (retryCount < 3) {
+                // Attempt retry 3 times in case where the OS Media DRM Framework fails for whatever reason
+                return buildDrmSessionManager(uuid, licenseUrl, keyRequestPropertiesArray, ++retryCount);
+            }
+            // Handle the unknow exception and emit to JS
+            eventEmitter.error(ex.toString(), ex, "3006");
+            return null;
+        }
+    }
+
+    private MediaSource buildMediaSource(Uri uri, String overrideExtension, DrmSessionManager drmSessionManager, long startTimeMs, long endTimeMs) {
+        if (uri == null) {
+            throw new IllegalStateException("Invalid video uri");
+        }
+        int type = Util.inferContentType(!TextUtils.isEmpty(overrideExtension) ? "." + overrideExtension
+                : uri.getLastPathSegment());
+        config.setDisableDisconnectError(this.disableDisconnectError);
+
+        MediaItem.Builder mediaItemBuilder = new MediaItem.Builder().setUri(uri);
+
+        if (adTagUrl != null) {
+            mediaItemBuilder.setAdsConfiguration(
+                    new MediaItem.AdsConfiguration.Builder(adTagUrl).build()
+            );
+        }
+
+        MediaItem mediaItem = mediaItemBuilder.build();
+        MediaSource mediaSource = null;
+        DrmSessionManagerProvider drmProvider = null;
+        if (drmSessionManager != null) {
+            drmProvider = new DrmSessionManagerProvider() {
+                @Override
+                public DrmSessionManager get(MediaItem mediaItem) {
+                    return drmSessionManager;
+                }
+            };
+        } else {
+            drmProvider = new DefaultDrmSessionManagerProvider();
+        }
+        switch (type) {
+            case CONTENT_TYPE_SS:
+                mediaSource = new SsMediaSource.Factory(
+                        new DefaultSsChunkSource.Factory(mediaDataSourceFactory),
+                        buildDataSourceFactory(false)
+                ).setDrmSessionManagerProvider(drmProvider)
+                 .setLoadErrorHandlingPolicy(
+                        config.buildLoadErrorHandlingPolicy(minLoadRetryCount)
+                ).createMediaSource(mediaItem);
+                break;
+            case CONTENT_TYPE_DASH:
+                mediaSource = new DashMediaSource.Factory(
+                        new DefaultDashChunkSource.Factory(mediaDataSourceFactory),
+                        buildDataSourceFactory(false)
+                ).setDrmSessionManagerProvider(drmProvider)
+                 .setLoadErrorHandlingPolicy(
+                        config.buildLoadErrorHandlingPolicy(minLoadRetryCount)
+                ).createMediaSource(mediaItem);
+                break;
+            case CONTENT_TYPE_HLS:
+                mediaSource = new HlsMediaSource.Factory(
+                        mediaDataSourceFactory
+                ).setDrmSessionManagerProvider(drmProvider)
+                 .setLoadErrorHandlingPolicy(
+                        config.buildLoadErrorHandlingPolicy(minLoadRetryCount)
+                ).createMediaSource(mediaItem);
+                break;
+            case CONTENT_TYPE_OTHER:
+                mediaSource = new ProgressiveMediaSource.Factory(
+                        mediaDataSourceFactory
+                ).setDrmSessionManagerProvider(drmProvider)
+                 .setLoadErrorHandlingPolicy(
+                        config.buildLoadErrorHandlingPolicy(minLoadRetryCount)
+                ).createMediaSource(mediaItem);
+                break;
+            default: {
+                throw new IllegalStateException("Unsupported type: " + type);
+            }
+        }
+
+        if (startTimeMs >= 0 && endTimeMs >= 0)
+        {
+            return new ClippingMediaSource(mediaSource, startTimeMs * 1000, endTimeMs * 1000);
+        } else if (startTimeMs >= 0) {
+            return new ClippingMediaSource(mediaSource, startTimeMs * 1000, TIME_END_OF_SOURCE);
+        } else if (endTimeMs >= 0) {
+            return new ClippingMediaSource(mediaSource, 0, endTimeMs * 1000);
+        }
+
+        return mediaSource;
+    }
+
+    private ArrayList<MediaSource> buildTextSources() {
+        ArrayList<MediaSource> textSources = new ArrayList<>();
+        if (textTracks == null) {
+            return textSources;
+        }
+
+        for (int i = 0; i < textTracks.size(); ++i) {
+            ReadableMap textTrack = textTracks.getMap(i);
+            String language = textTrack.getString("language");
+            String title = textTrack.hasKey("title")
+                    ? textTrack.getString("title") : language + " " + i;
+            Uri uri = Uri.parse(textTrack.getString("uri"));
+            MediaSource textSource = buildTextSource(title, uri, textTrack.getString("type"),
+                    language);
+            if (textSource != null) {
+                textSources.add(textSource);
+            }
+        }
+        return textSources;
+    }
+
+    private MediaSource buildTextSource(String title, Uri uri, String mimeType, String language) {
+        MediaItem.SubtitleConfiguration subtitleConfiguration = new MediaItem.SubtitleConfiguration.Builder(uri)
+                .setMimeType(mimeType)
+                .setLanguage(language)
+                .setSelectionFlags(C.SELECTION_FLAG_DEFAULT)
+                .setRoleFlags(C.ROLE_FLAG_SUBTITLE)
+                .setLabel(title)
+                .build();
+        return new SingleSampleMediaSource.Factory(mediaDataSourceFactory)
+                .createMediaSource(subtitleConfiguration, C.TIME_UNSET);
+    }
+
+    private void releasePlayer() {
+        if (player != null) {
+            if (adsLoader != null) {
+                adsLoader.setPlayer(null);
+            }
+            updateResumePosition();
+            player.release();
+            player.removeListener(this);
+            trackSelector = null;
+            player = null;
+        }
+        if (adsLoader != null) {
+            adsLoader.release();
+        }
+        adsLoader = null;
+        progressHandler.removeMessages(SHOW_PROGRESS);
+        themedReactContext.removeLifecycleEventListener(this);
+        audioBecomingNoisyReceiver.removeListener();
+        bandwidthMeter.removeEventListener(this);
+    }
+
+    private static class OnAudioFocusChangedListener implements AudioManager.OnAudioFocusChangeListener {
+        private final ReactExoplayerView view;
+
+        private OnAudioFocusChangedListener(ReactExoplayerView view) {
+            this.view = view;
+        }
+
+        @Override
+        public void onAudioFocusChange(int focusChange) {
+            switch (focusChange) {
+                case AudioManager.AUDIOFOCUS_LOSS:
+                    view.hasAudioFocus = false;
+                    view.eventEmitter.audioFocusChanged(false);
+                    view.pausePlayback();
+                    view.audioManager.abandonAudioFocus(this);
+                    break;
+                case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
+                    view.eventEmitter.audioFocusChanged(false);
+                    break;
+                case AudioManager.AUDIOFOCUS_GAIN:
+                    view.hasAudioFocus = true;
+                    view.eventEmitter.audioFocusChanged(true);
+                    break;
+                default:
+                    break;
+            }
+
+            if (view.player != null) {
+                if (focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK) {
+                    // Lower the volume
+                    if (!view.muted) {
+                        view.player.setVolume(view.audioVolume * 0.8f);
+                    }
+                } else if (focusChange == AudioManager.AUDIOFOCUS_GAIN) {
+                    // Raise it back to normal
+                    if (!view.muted) {
+                        view.player.setVolume(view.audioVolume * 1);
+                    }
+                }
+            }
+        }
+    }
+
+    private boolean requestAudioFocus() {
+        if (disableFocus || srcUri == null || this.hasAudioFocus) {
+            return true;
+        }
+        int result = audioManager.requestAudioFocus(audioFocusChangeListener,
+                AudioManager.STREAM_MUSIC,
+                AudioManager.AUDIOFOCUS_GAIN);
+        return result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
+    }
+
+    private void setPlayWhenReady(boolean playWhenReady) {
+        if (player == null) {
+            return;
+        }
+
+        if (playWhenReady) {
+            this.hasAudioFocus = requestAudioFocus();
+            if (this.hasAudioFocus) {
+                player.setPlayWhenReady(true);
+            }
+        } else {
+            // ensure playback is not ENDED, else it will trigger another ended event
+            if (player.getPlaybackState() != Player.STATE_ENDED) {
+                player.setPlayWhenReady(false);
+            }
+        }
+    }
+
+    private void startPlayback() {
+        if (player != null) {
+            switch (player.getPlaybackState()) {
+                case Player.STATE_IDLE:
+                case Player.STATE_ENDED:
+                    initializePlayer();
+                    break;
+                case Player.STATE_BUFFERING:
+                case Player.STATE_READY:
+                    if (!player.getPlayWhenReady()) {
+                        setPlayWhenReady(true);
+                    }
+                    break;
+                default:
+                    break;
+            }
+        } else {
+            initializePlayer();
+        }
+        if (!disableFocus) {
+            setKeepScreenOn(preventsDisplaySleepDuringVideoPlayback);
+        }
+    }
+
+    private void pausePlayback() {
+        if (player != null) {
+            if (player.getPlayWhenReady()) {
+                setPlayWhenReady(false);
+            }
+        }
+        setKeepScreenOn(false);
+    }
+
+    private void stopPlayback() {
+        onStopPlayback();
+        releasePlayer();
+    }
+
+    private void onStopPlayback() {
+        if (isFullscreen) {
+            setFullscreen(false);
+        }
+        audioManager.abandonAudioFocus(audioFocusChangeListener);
+    }
+
+    private void updateResumePosition() {
+        resumeWindow = player.getCurrentMediaItemIndex();
+        resumePosition = player.isCurrentMediaItemSeekable() ? Math.max(0, player.getCurrentPosition())
+                : C.TIME_UNSET;
+    }
+
+    private void clearResumePosition() {
+        resumeWindow = C.INDEX_UNSET;
+        resumePosition = C.TIME_UNSET;
+    }
+
+    /**
+     * Returns a new DataSource factory.
+     *
+     * @param useBandwidthMeter Whether to set {@link #bandwidthMeter} as a listener to the new
+     *                          DataSource factory.
+     * @return A new DataSource factory.
+     */
+    private DataSource.Factory buildDataSourceFactory(boolean useBandwidthMeter) {
+        return DataSourceUtil.getDefaultDataSourceFactory(this.themedReactContext,
+                useBandwidthMeter ? bandwidthMeter : null, requestHeaders);
+    }
+
+    /**
+     * Returns a new HttpDataSource factory.
+     *
+     * @param useBandwidthMeter Whether to set {@link #bandwidthMeter} as a listener to the new
+     *     DataSource factory.
+     * @return A new HttpDataSource factory.
+     */
+    private HttpDataSource.Factory buildHttpDataSourceFactory(boolean useBandwidthMeter) {
+        return DataSourceUtil.getDefaultHttpDataSourceFactory(this.themedReactContext, useBandwidthMeter ? bandwidthMeter : null, requestHeaders);
+    }
+
+
+    // AudioBecomingNoisyListener implementation
+
+    @Override
+    public void onAudioBecomingNoisy() {
+        eventEmitter.audioBecomingNoisy();
+    }
+
+    // Player.Listener implementation
+
+    @Override
+    public void onIsLoadingChanged(boolean isLoading) {
+        // Do nothing.
+    }
+
+    @Override
+    public void onEvents(Player player, Player.Events events) {
+        if (events.contains(Player.EVENT_PLAYBACK_STATE_CHANGED) || events.contains(Player.EVENT_PLAY_WHEN_READY_CHANGED)) {
+            int playbackState = player.getPlaybackState();
+            boolean playWhenReady = player.getPlayWhenReady();
+            String text = "onStateChanged: playWhenReady=" + playWhenReady + ", playbackState=";
+            eventEmitter.playbackRateChange(playWhenReady && playbackState == ExoPlayer.STATE_READY ? 1.0f : 0.0f);
+            switch (playbackState) {
+                case Player.STATE_IDLE:
+                    text += "idle";
+                    eventEmitter.idle();
+                    clearProgressMessageHandler();
+                    if (!player.getPlayWhenReady()) {
+                        setKeepScreenOn(false);
+                    }
+                    break;
+            case Player.STATE_BUFFERING:
+                text += "buffering";
+                onBuffering(true);
+                clearProgressMessageHandler();
+                setKeepScreenOn(preventsDisplaySleepDuringVideoPlayback);
+                break;
+            case Player.STATE_READY:
+                text += "ready";
+                eventEmitter.ready();
+                onBuffering(false);
+                clearProgressMessageHandler(); // ensure there is no other message
+                startProgressHandler();
+                videoLoaded();
+                if (selectTrackWhenReady && isUsingContentResolution) {
+                    selectTrackWhenReady = false;
+                    setSelectedTrack(C.TRACK_TYPE_VIDEO, videoTrackType, videoTrackValue);
+                }
+                // Setting the visibility for the playerControlView
+                if (playerControlView != null) {
+                    playerControlView.show();
+                }
+                setKeepScreenOn(preventsDisplaySleepDuringVideoPlayback);
+                break;
+            case Player.STATE_ENDED:
+                text += "ended";
+                eventEmitter.end();
+                onStopPlayback();
+                setKeepScreenOn(false);
+                break;
+            default:
+                text += "unknown";
+                break;
+            }
+        }
+    }
+
+    private void startProgressHandler() {
+        progressHandler.sendEmptyMessage(SHOW_PROGRESS);
+    }
+
+    /*
+        The progress message handler will duplicate recursions of the onProgressMessage handler
+        on change of player state from any state to STATE_READY with playWhenReady is true (when
+        the video is not paused). This clears all existing messages.
+     */
+    private void clearProgressMessageHandler() {
+         progressHandler.removeMessages(SHOW_PROGRESS);
+    }
+
+    private void videoLoaded() {
+        if (!player.isPlayingAd() && loadVideoStarted) {
+            loadVideoStarted = false;
+            if (audioTrackType != null) {
+                setSelectedAudioTrack(audioTrackType, audioTrackValue);
+            }
+            if (videoTrackType != null) {
+                setSelectedVideoTrack(videoTrackType, videoTrackValue);
+            }
+            if (textTrackType != null) {
+                setSelectedTextTrack(textTrackType, textTrackValue);
+            }
+            Format videoFormat = player.getVideoFormat();
+            int width = videoFormat != null ? videoFormat.width : 0;
+            int height = videoFormat != null ? videoFormat.height : 0;
+            String trackId = videoFormat != null ? videoFormat.id : "-1";
+
+            // Properties that must be accessed on the main thread
+            long duration = player.getDuration();
+            long currentPosition = player.getCurrentPosition();
+            ArrayList<Track> audioTracks = getAudioTrackInfo();
+            ArrayList<Track> textTracks  = getTextTrackInfo();
+
+            if (this.contentStartTime != -1L) {
+                ExecutorService es = Executors.newSingleThreadExecutor();
+                es.execute(new Runnable() {
+                    @Override
+                    public void run() {
+                        // To prevent ANRs caused by getVideoTrackInfo we run this on a different thread and notify the player only when we're done
+                        ArrayList<VideoTrack> videoTracks = getVideoTrackInfoFromManifest();
+                        if (videoTracks != null) {
+                            isUsingContentResolution = true;
+                        }
+                        eventEmitter.load(duration, currentPosition, width, height,
+                                audioTracks, textTracks, videoTracks, trackId );
+
+                    }
+                });
+                return;
+            }
+
+            ArrayList<VideoTrack> videoTracks = getVideoTrackInfo();
+
+            eventEmitter.load(duration, currentPosition, width, height,
+                    audioTracks, textTracks, videoTracks, trackId);
+        }
+    }
+
+    private static boolean isTrackSelected(TrackSelection selection, TrackGroup group,
+                                           int trackIndex){
+        return selection != null && selection.getTrackGroup() == group
+                && selection.indexOf( trackIndex ) != C.INDEX_UNSET;
+    }
+
+    private ArrayList<Track> getAudioTrackInfo() {
+        ArrayList<Track> audioTracks = new ArrayList<>();
+        if (trackSelector == null) {
+            // Likely player is unmounting so no audio tracks are available anymore
+            return audioTracks;
+        }
+
+        MappingTrackSelector.MappedTrackInfo info = trackSelector.getCurrentMappedTrackInfo();
+        int index = getTrackRendererIndex(C.TRACK_TYPE_AUDIO);
+        if (info == null || index == C.INDEX_UNSET) {
+            return audioTracks;
+        }
+        TrackGroupArray groups = info.getTrackGroups(index);
+        TrackSelectionArray selectionArray = player.getCurrentTrackSelections();
+        TrackSelection selection = selectionArray.get( C.TRACK_TYPE_AUDIO );
+
+        for (int i = 0; i < groups.length; ++i) {
+            TrackGroup group = groups.get(i);
+            Format format = group.getFormat(0);
+            Track audioTrack = new Track();
+            audioTrack.m_index = i;
+            audioTrack.m_title = format.id != null ? format.id : "";
+            audioTrack.m_mimeType = format.sampleMimeType;
+            audioTrack.m_language = format.language != null ? format.language : "";
+            audioTrack.m_bitrate = format.bitrate == Format.NO_VALUE ? 0 : format.bitrate;
+            audioTrack.m_isSelected = isTrackSelected(selection, group, 0 );
+            audioTracks.add(audioTrack);
+        }
+        return audioTracks;
+    }
+
+    private ArrayList<VideoTrack> getVideoTrackInfo() {
+        ArrayList<VideoTrack> videoTracks = new ArrayList<>();
+        if (trackSelector == null) {
+            // Likely player is unmounting so no audio tracks are available anymore
+            return videoTracks;
+        }
+        MappingTrackSelector.MappedTrackInfo info = trackSelector.getCurrentMappedTrackInfo();
+        int index = getTrackRendererIndex(C.TRACK_TYPE_VIDEO);
+        if (info == null || index == C.INDEX_UNSET) {
+            return videoTracks;
+        }
+
+        TrackGroupArray groups = info.getTrackGroups(index);
+        for (int i = 0; i < groups.length; ++i) {
+            TrackGroup group = groups.get(i);
+
+            for (int trackIndex = 0; trackIndex < group.length; trackIndex++) {
+                Format format = group.getFormat(trackIndex);
+                if (isFormatSupported(format)) {
+                    VideoTrack videoTrack = new VideoTrack();
+                    videoTrack.m_width = format.width == Format.NO_VALUE ? 0 : format.width;
+                    videoTrack.m_height = format.height == Format.NO_VALUE ? 0 : format.height;
+                    videoTrack.m_bitrate = format.bitrate == Format.NO_VALUE ? 0 : format.bitrate;
+                    videoTrack.m_codecs = format.codecs != null ? format.codecs : "";
+                    videoTrack.m_trackId = format.id == null ? String.valueOf(trackIndex) : format.id;
+                    videoTracks.add(videoTrack);
+                }
+            }
+        }
+        return videoTracks;
+    }
+
+    private ArrayList<VideoTrack> getVideoTrackInfoFromManifest() {
+        return this.getVideoTrackInfoFromManifest(0);
+    }
+
+    // We need retry count to in case where minefest request fails from poor network conditions
+    @WorkerThread
+    private ArrayList<VideoTrack> getVideoTrackInfoFromManifest(int retryCount) {
+        ExecutorService es = Executors.newSingleThreadExecutor();
+        final DataSource dataSource = this.mediaDataSourceFactory.createDataSource();
+        final Uri sourceUri = this.srcUri;
+        final long startTime = this.contentStartTime * 1000 - 100; // s -> ms with 100ms offset
+
+        Future<ArrayList<VideoTrack>> result = es.submit(new Callable<ArrayList<VideoTrack>>() {
+            DataSource ds = dataSource;
+            Uri uri = sourceUri;
+            long startTimeUs = startTime * 1000; // ms -> us
+
+            public ArrayList<VideoTrack> call() throws Exception {
+                ArrayList<VideoTrack> videoTracks = new ArrayList<>();
+                try  {
+                    DashManifest manifest = DashUtil.loadManifest(this.ds, this.uri);
+                    int periodCount = manifest.getPeriodCount();
+                    for (int i = 0; i < periodCount; i++) {
+                        Period period = manifest.getPeriod(i);
+                        for (int adaptationIndex = 0; adaptationIndex < period.adaptationSets.size(); adaptationIndex++) {
+                            AdaptationSet adaptation = period.adaptationSets.get(adaptationIndex);
+                            if (adaptation.type != C.TRACK_TYPE_VIDEO) {
+                                continue;
+                            }
+                            boolean hasFoundContentPeriod = false;
+                            for (int representationIndex = 0; representationIndex < adaptation.representations.size(); representationIndex++) {
+                                Representation representation = adaptation.representations.get(representationIndex);
+                                Format format = representation.format;
+                                if (isFormatSupported(format)) {
+                                    if (representation.presentationTimeOffsetUs <= startTimeUs) {
+                                        break;
+                                    }
+                                    hasFoundContentPeriod = true;
+                                    VideoTrack videoTrack = new VideoTrack();
+                                    videoTrack.m_width = format.width == Format.NO_VALUE ? 0 : format.width;
+                                    videoTrack.m_height = format.height == Format.NO_VALUE ? 0 : format.height;
+                                    videoTrack.m_bitrate = format.bitrate == Format.NO_VALUE ? 0 : format.bitrate;
+                                    videoTrack.m_codecs = format.codecs != null ? format.codecs : "";
+                                    videoTrack.m_trackId = format.id == null ? String.valueOf(representationIndex) : format.id;
+                                    videoTracks.add(videoTrack);
+                                }
+                            }
+                            if (hasFoundContentPeriod) {
+                                return videoTracks;
+                            }
+                        }
+                    }
+                } catch (Exception e) {}
+                return null;
+            }
+        });
+
+        try {
+            ArrayList<VideoTrack> results = result.get(3000, TimeUnit.MILLISECONDS);
+            if (results == null && retryCount < 1) {
+                return this.getVideoTrackInfoFromManifest(++retryCount);
+            }
+            es.shutdown();
+            return results;
+        } catch (Exception e) {}
+
+        return null;
+    }
+
+    private ArrayList<Track> getTextTrackInfo() {
+        ArrayList<Track> textTracks = new ArrayList<>();
+        if (trackSelector == null) {
+            return textTracks;
+        }
+        MappingTrackSelector.MappedTrackInfo info = trackSelector.getCurrentMappedTrackInfo();
+        int index = getTrackRendererIndex(C.TRACK_TYPE_TEXT);
+        if (info == null || index == C.INDEX_UNSET) {
+            return textTracks;
+        }
+        TrackSelectionArray selectionArray = player.getCurrentTrackSelections();
+        TrackSelection selection = selectionArray.get( C.TRACK_TYPE_VIDEO );
+        TrackGroupArray groups = info.getTrackGroups(index);
+
+        for (int i = 0; i < groups.length; ++i) {
+            TrackGroup group = groups.get(i);
+            Format format = group.getFormat(0);
+
+            Track textTrack = new Track();
+            textTrack.m_index = i;
+            textTrack.m_title = format.id != null ? format.id : "";
+            textTrack.m_mimeType = format.sampleMimeType;
+            textTrack.m_language = format.language != null ? format.language : "";
+            textTrack.m_isSelected = isTrackSelected(selection, group, 0 );
+            textTracks.add(textTrack);
+        }
+        return textTracks;
+    }
+
+    private void onBuffering(boolean buffering) {
+        if (isBuffering == buffering) {
+            return;
+        }
+
+        isBuffering = buffering;
+        if (buffering) {
+            eventEmitter.buffering(true);
+        } else {
+            eventEmitter.buffering(false);
+        }
+    }
+
+    @Override
+    public void onPositionDiscontinuity(Player.PositionInfo oldPosition, Player.PositionInfo newPosition, int reason) {
+        if (playerNeedsSource) {
+            // This will only occur if the user has performed a seek whilst in the error state. Update the
+            // resume position so that if the user then retries, playback will resume from the position to
+            // which they seeked.
+            updateResumePosition();
+        }
+        if (isUsingContentResolution) {
+            // Discontinuity events might have a different track list so we update the selected track
+            setSelectedTrack(C.TRACK_TYPE_VIDEO, videoTrackType, videoTrackValue);
+            selectTrackWhenReady = true;
+        }
+        // When repeat is turned on, reaching the end of the video will not cause a state change
+        // so we need to explicitly detect it.
+        if (reason == Player.DISCONTINUITY_REASON_AUTO_TRANSITION
+                && player.getRepeatMode() == Player.REPEAT_MODE_ONE) {
+            eventEmitter.end();
+        }
+
+    }
+
+    @Override
+    public void onTimelineChanged(Timeline timeline, int reason) {
+        // Do nothing.
+    }
+
+    @Override
+    public void onPlaybackStateChanged(int playbackState) {
+        if (playbackState == Player.STATE_READY && seekTime != C.TIME_UNSET) {
+            eventEmitter.seek(player.getCurrentPosition(), seekTime);
+            seekTime = C.TIME_UNSET;
+            if (isUsingContentResolution) {
+                // We need to update the selected track to make sure that it still matches user selection if track list has changed in this period
+                setSelectedTrack(C.TRACK_TYPE_VIDEO, videoTrackType, videoTrackValue);
+            }
+        }
+    }
+
+    @Override
+    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
+        // Do nothing.
+    }
+
+    @Override
+    public void onRepeatModeChanged(int repeatMode) {
+        // Do nothing.
+    }
+
+    @Override
+    public void onTracksChanged(Tracks tracks) {
+        eventEmitter.textTracks(getTextTrackInfo());
+        eventEmitter.audioTracks(getAudioTrackInfo());
+        eventEmitter.videoTracks(getVideoTrackInfo());
+    }
+
+    @Override
+    public void onPlaybackParametersChanged(PlaybackParameters params) {
+        eventEmitter.playbackRateChange(params.speed);
+    }
+
+    @Override
+    public void onIsPlayingChanged(boolean isPlaying) {
+        eventEmitter.playbackStateChanged(isPlaying);
+    }
+
+    @Override
+    public void onPlayerError(PlaybackException e) {
+        if (e == null) {
+            return;
+        }
+        String errorString = "ExoPlaybackException: " + PlaybackException.getErrorCodeName(e.errorCode);
+        String errorCode = "2" + String.valueOf(e.errorCode);
+        boolean needsReInitialization = false;
+        switch(e.errorCode) {
+            case PlaybackException.ERROR_CODE_DRM_DEVICE_REVOKED:
+            case PlaybackException.ERROR_CODE_DRM_LICENSE_ACQUISITION_FAILED:
+            case PlaybackException.ERROR_CODE_DRM_PROVISIONING_FAILED:
+            case PlaybackException.ERROR_CODE_DRM_SYSTEM_ERROR:
+            case PlaybackException.ERROR_CODE_DRM_UNSPECIFIED:
+                if (!hasDrmFailed) {
+                    // When DRM fails to reach the app level certificate server it will fail with a source error so we assume that it is DRM related and try one more time
+                    hasDrmFailed = true;
+                    playerNeedsSource = true;
+                    updateResumePosition();
+                    initializePlayer();
+                    setPlayWhenReady(true);
+                    return;
+                }
+                break;
+            default:
+                break;
+        }
+        eventEmitter.error(errorString, e, errorCode);
+        playerNeedsSource = true;
+        if (isBehindLiveWindow(e)) {
+            clearResumePosition();
+            initializePlayer();
+        } else {
+            updateResumePosition();
+            if (needsReInitialization) {
+                initializePlayer();
+            }
+        }
+    }
+
+    private static boolean isBehindLiveWindow(PlaybackException e) {
+        return e.errorCode == PlaybackException.ERROR_CODE_BEHIND_LIVE_WINDOW;
+    }
+
+    public int getTrackRendererIndex(int trackType) {
+        if (player != null) {
+            int rendererCount = player.getRendererCount();
+            for (int rendererIndex = 0; rendererIndex < rendererCount; rendererIndex++) {
+                if (player.getRendererType(rendererIndex) == trackType) {
+                    return rendererIndex;
+                }
+            }
+        }
+        return C.INDEX_UNSET;
+    }
+
+    @Override
+    public void onMetadata(Metadata metadata) {
+        eventEmitter.timedMetadata(metadata);
+    }
+
+    // ReactExoplayerViewManager public api
+
+    public void setSrc(final Uri uri, final long startTimeMs, final long endTimeMs, final String extension, Map<String, String> headers) {
+        if (uri != null) {
+            boolean isSourceEqual = uri.equals(srcUri) && startTimeMs == this.startTimeMs && endTimeMs == this.endTimeMs;
+            hasDrmFailed = false;
+            this.srcUri = uri;
+            this.startTimeMs = startTimeMs;
+            this.endTimeMs = endTimeMs;
+            this.extension = extension;
+            this.requestHeaders = headers;
+            this.mediaDataSourceFactory =
+                    DataSourceUtil.getDefaultDataSourceFactory(this.themedReactContext, bandwidthMeter,
+                            this.requestHeaders);
+
+            if (!isSourceEqual) {
+                reloadSource();
+            }
+        }
+    }
+
+    public void clearSrc() {
+        if (srcUri != null) {
+            player.stop();
+            player.clearMediaItems();
+            this.srcUri = null;
+            this.startTimeMs = -1;
+            this.endTimeMs = -1;
+            this.extension = null;
+            this.requestHeaders = null;
+            this.mediaDataSourceFactory = null;
+            clearResumePosition();
+        }
+    }
+
+    public void setProgressUpdateInterval(final float progressUpdateInterval) {
+        mProgressUpdateInterval = progressUpdateInterval;
+    }
+
+    public void setReportBandwidth(boolean reportBandwidth) {
+        mReportBandwidth = reportBandwidth;
+    }
+
+    public void setAdTagUrl(final Uri uri) {
+        adTagUrl = uri;
+    }
+
+    public void setRawSrc(final Uri uri, final String extension) {
+        if (uri != null) {
+            boolean isSourceEqual = uri.equals(srcUri);
+            this.srcUri = uri;
+            this.extension = extension;
+            this.mediaDataSourceFactory = buildDataSourceFactory(true);
+
+            if (!isSourceEqual) {
+                reloadSource();
+            }
+        }
+    }
+
+    public void setTextTracks(ReadableArray textTracks) {
+        this.textTracks = textTracks;
+        reloadSource();
+    }
+
+    private void reloadSource() {
+        playerNeedsSource = true;
+        initializePlayer();
+    }
+
+    public void setResizeModeModifier(@ResizeMode.Mode int resizeMode) {
+        exoPlayerView.setResizeMode(resizeMode);
+    }
+
+    private void applyModifiers() {
+        setRepeatModifier(repeat);
+        setMutedModifier(muted);
+    }
+
+    public void setRepeatModifier(boolean repeat) {
+        if (player != null) {
+            if (repeat) {
+                player.setRepeatMode(Player.REPEAT_MODE_ONE);
+            } else {
+                player.setRepeatMode(Player.REPEAT_MODE_OFF);
+            }
+        }
+        this.repeat = repeat;
+    }
+
+    public void setPreventsDisplaySleepDuringVideoPlayback(boolean preventsDisplaySleepDuringVideoPlayback) {
+        this.preventsDisplaySleepDuringVideoPlayback = preventsDisplaySleepDuringVideoPlayback;
+    }
+
+    public void disableTrack(int rendererIndex) {
+        DefaultTrackSelector.Parameters disableParameters = trackSelector.getParameters()
+                .buildUpon()
+                .setRendererDisabled(rendererIndex, true)
+                .build();
+        trackSelector.setParameters(disableParameters);
+    }
+
+    public void setSelectedTrack(int trackType, String type, Dynamic value) {
+        if (player == null) return;
+        int rendererIndex = getTrackRendererIndex(trackType);
+        if (rendererIndex == C.INDEX_UNSET) {
+            return;
+        }
+        MappingTrackSelector.MappedTrackInfo info = trackSelector.getCurrentMappedTrackInfo();
+        if (info == null) {
+            return;
+        }
+
+        TrackGroupArray groups = info.getTrackGroups(rendererIndex);
+        int groupIndex = C.INDEX_UNSET;
+        List<Integer> tracks = new ArrayList<>();
+        tracks.add(0);
+
+        if (TextUtils.isEmpty(type)) {
+            type = "default";
+        }
+
+        if (type.equals("disabled")) {
+            disableTrack(rendererIndex);
+            return;
+        } else if (type.equals("language")) {
+            for (int i = 0; i < groups.length; ++i) {
+                Format format = groups.get(i).getFormat(0);
+                if (format.language != null && format.language.equals(value.asString())) {
+                    groupIndex = i;
+                    break;
+                }
+            }
+        } else if (type.equals("title")) {
+            for (int i = 0; i < groups.length; ++i) {
+                Format format = groups.get(i).getFormat(0);
+                if (format.id != null && format.id.equals(value.asString())) {
+                    groupIndex = i;
+                    break;
+                }
+            }
+        } else if (type.equals("index")) {
+            if (value.asInt() < groups.length) {
+                groupIndex = value.asInt();
+            }
+        } else if (type.equals("resolution")) {
+            int height = value.asInt();
+            for (int i = 0; i < groups.length; ++i) { // Search for the exact height
+                TrackGroup group = groups.get(i);
+                Format closestFormat = null;
+                int closestTrackIndex = -1;
+                boolean usingExactMatch = false;
+                for (int j = 0; j < group.length; j++) {
+                    Format format = group.getFormat(j);
+                    if (format.height == height) {
+                        groupIndex = i;
+                        tracks.set(0, j);
+                        closestFormat = null;
+                        closestTrackIndex = -1;
+                        usingExactMatch = true;
+                        break;
+                    } else if (isUsingContentResolution) {
+                        // When using content resolution rather than ads, we need to try and find the closest match if there is no exact match
+                        if (closestFormat != null) {
+                            if ((format.bitrate > closestFormat.bitrate || format.height > closestFormat.height) && format.height < height) {
+                                // Higher quality match
+                                closestFormat = format;
+                                closestTrackIndex = j;
+                            }
+                        } else if(format.height < height) {
+                            closestFormat = format;
+                            closestTrackIndex = j;
+                        }
+                    }
+                }
+                // This is a fallback if the new period contains only higher resolutions than the user has selected
+                if (closestFormat == null && isUsingContentResolution && !usingExactMatch) {
+                    // No close match found - so we pick the lowest quality
+                    int minHeight = Integer.MAX_VALUE;
+                    for (int j = 0; j < group.length; j++) {
+                        Format format = group.getFormat(j);
+                        if (format.height < minHeight) {
+                            minHeight = format.height;
+                            groupIndex = i;
+                            tracks.set(0, j);
+                        }
+                    }
+                }
+                // Selecting the closest match found
+                if (closestFormat != null && closestTrackIndex != -1) {
+                    // We found the closest match instead of an exact one
+                    groupIndex = i;
+                    tracks.set(0, closestTrackIndex);
+                }
+            }
+        } else if (trackType == C.TRACK_TYPE_TEXT && Util.SDK_INT > 18) { // Text default
+            // Use system settings if possible
+            CaptioningManager captioningManager
+                    = (CaptioningManager)themedReactContext.getSystemService(Context.CAPTIONING_SERVICE);
+            if (captioningManager != null && captioningManager.isEnabled()) {
+                groupIndex = getGroupIndexForDefaultLocale(groups);
+            }
+        } else if (rendererIndex == C.TRACK_TYPE_AUDIO) { // Audio default
+            groupIndex = getGroupIndexForDefaultLocale(groups);
+        }
+
+        if (groupIndex == C.INDEX_UNSET && trackType == C.TRACK_TYPE_VIDEO && groups.length != 0) { // Video auto
+            // Add all tracks as valid options for ABR to choose from
+            TrackGroup group = groups.get(0);
+            tracks = new ArrayList<Integer>(group.length);
+            ArrayList<Integer> allTracks = new ArrayList<Integer>(group.length);
+            groupIndex = 0;
+            for (int j = 0; j < group.length; j++) {
+                allTracks.add(j);
+            }
+
+            // Valiate list of all tracks and add only supported formats
+            int supportedFormatLength = 0;
+            ArrayList<Integer> supportedTrackList = new ArrayList<Integer>();
+            for (int g = 0; g < allTracks.size(); g++) {
+                Format format = group.getFormat(g);
+                if (isFormatSupported(format)) {
+                    supportedFormatLength++;
+                }
+            }
+            if (allTracks.size() == 1) {
+                // With only one tracks we can't remove any tracks so attempt to play it anyway
+                tracks = allTracks;
+            } else {
+                tracks =  new ArrayList<>(supportedFormatLength + 1);
+                for (int k = 0; k < allTracks.size(); k++) {
+                    Format format = group.getFormat(k);
+                    if (isFormatSupported(format)) {
+                        tracks.add(allTracks.get(k));
+                        supportedTrackList.add(allTracks.get(k));
+                    }
+                }
+            }
+        }
+
+        if (groupIndex == C.INDEX_UNSET) {
+            disableTrack(rendererIndex);
+            return;
+        }
+
+        TrackSelectionOverride selectionOverride = new TrackSelectionOverride(groups.get(groupIndex), tracks);
+
+        DefaultTrackSelector.Parameters selectionParameters = trackSelector.getParameters()
+            .buildUpon()
+            .setRendererDisabled(rendererIndex, false)
+            .clearOverridesOfType(selectionOverride.getType())
+            .addOverride(selectionOverride)
+            .build();
+        trackSelector.setParameters(selectionParameters);
+    }
+
+    private boolean isFormatSupported(Format format) {
+        int width = format.width == Format.NO_VALUE ? 0 : format.width;
+        int height = format.height == Format.NO_VALUE ? 0 : format.height;
+        float frameRate = format.frameRate == Format.NO_VALUE ? 0 : format.frameRate;
+        String mimeType = format.sampleMimeType;
+        if (mimeType == null) {
+            return true;
+        }
+        boolean isSupported = false;
+        try {
+            MediaCodecInfo codecInfo = MediaCodecUtil.getDecoderInfo(mimeType, false, false);
+            isSupported = codecInfo.isVideoSizeAndRateSupportedV21(width, height, frameRate);
+        } catch (Exception e) {
+            // Failed to get decoder info - assume it is supported
+            isSupported = true;
+        }
+        return isSupported;
+    }
+
+    private int getGroupIndexForDefaultLocale(TrackGroupArray groups) {
+        if (groups.length == 0){
+            return C.INDEX_UNSET;
+        }
+
+        int groupIndex = 0; // default if no match
+        String locale2 = Locale.getDefault().getLanguage(); // 2 letter code
+        String locale3 = Locale.getDefault().getISO3Language(); // 3 letter code
+        for (int i = 0; i < groups.length; ++i) {
+            Format format = groups.get(i).getFormat(0);
+            String language = format.language;
+            if (language != null && (language.equals(locale2) || language.equals(locale3))) {
+                groupIndex = i;
+                break;
+            }
+        }
+        return groupIndex;
+    }
+
+    public void setSelectedVideoTrack(String type, Dynamic value) {
+        videoTrackType = type;
+        videoTrackValue = value;
+        setSelectedTrack(C.TRACK_TYPE_VIDEO, videoTrackType, videoTrackValue);
+    }
+
+    public void setSelectedAudioTrack(String type, Dynamic value) {
+        audioTrackType = type;
+        audioTrackValue = value;
+        setSelectedTrack(C.TRACK_TYPE_AUDIO, audioTrackType, audioTrackValue);
+    }
+
+    public void setSelectedTextTrack(String type, Dynamic value) {
+        textTrackType = type;
+        textTrackValue = value;
+        setSelectedTrack(C.TRACK_TYPE_TEXT, textTrackType, textTrackValue);
+    }
+
+    public void setPausedModifier(boolean paused) {
+        isPaused = paused;
+        if (player != null) {
+            if (!paused) {
+                startPlayback();
+            } else {
+                pausePlayback();
+            }
+        }
+    }
+
+    public void setMutedModifier(boolean muted) {
+        this.muted = muted;
+        if (player != null) {
+            player.setVolume(muted ? 0.f : audioVolume);
+        }
+    }
+
+    public void setVolumeModifier(float volume) {
+        audioVolume = volume;
+        if (player != null) {
+            player.setVolume(audioVolume);
+        }
+    }
+
+    public void seekTo(long positionMs) {
+        if (player != null) {
+            player.seekTo(positionMs);
+            eventEmitter.seek(player.getCurrentPosition(), positionMs);
+        }
+    }
+
+    public void setRateModifier(float newRate) {
+        rate = newRate;
+
+        if (player != null) {
+            PlaybackParameters params = new PlaybackParameters(rate, 1f);
+            player.setPlaybackParameters(params);
+        }
+    }
+
+    public void setMaxBitRateModifier(int newMaxBitRate) {
+        maxBitRate = newMaxBitRate;
+        if (player != null) {
+            trackSelector.setParameters(trackSelector.buildUponParameters()
+                    .setMaxVideoBitrate(maxBitRate == 0 ? Integer.MAX_VALUE : maxBitRate));
+        }
+    }
+
+    public void setMinLoadRetryCountModifier(int newMinLoadRetryCount) {
+        minLoadRetryCount = newMinLoadRetryCount;
+        releasePlayer();
+        initializePlayer();
+    }
+
+    public void setPlayInBackground(boolean playInBackground) {
+        this.playInBackground = playInBackground;
+    }
+
+    public void setDisableFocus(boolean disableFocus) {
+        this.disableFocus = disableFocus;
+    }
+
+    public void setFocusable(boolean focusable) {
+        this.focusable = focusable;
+        exoPlayerView.setFocusable(this.focusable);
+    }
+
+    public void setBackBufferDurationMs(int backBufferDurationMs) {
+        Runtime runtime = Runtime.getRuntime();
+        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
+        long freeMemory = runtime.maxMemory() - usedMemory;
+        long reserveMemory = (long)minBackBufferMemoryReservePercent * runtime.maxMemory();
+        if (reserveMemory > freeMemory) {
+            // We don't have enough memory in reserve so we will
+            Log.w("ExoPlayer Warning", "Not enough reserve memory, setting back buffer to 0ms to reduce memory pressure!");
+            this.backBufferDurationMs = 0;
+            return;
+        }
+        this.backBufferDurationMs = backBufferDurationMs;
+    }
+
+    public void setContentStartTime(int contentStartTime) {
+        this.contentStartTime = (long)contentStartTime;
+    }
+
+    public void setDisableBuffering(boolean disableBuffering) {
+        this.disableBuffering = disableBuffering;
+    }
+
+    private void updateFullScreenButtonVisbility() {
+        if (playerControlView != null) {
+            final ImageButton fullScreenButton = playerControlView.findViewById(R.id.exo_fullscreen);
+            if (controls) {
+                //Handling the fullScreenButton click event
+                if (isFullscreen && fullScreenPlayerView != null && !fullScreenPlayerView.isShowing()) {
+                    fullScreenButton.setVisibility(GONE);
+                } else {
+                    fullScreenButton.setVisibility(VISIBLE);
+                }
+            } else {
+                fullScreenButton.setVisibility(GONE);
+            }
+        }
+    }
+
+    public void setDisableDisconnectError(boolean disableDisconnectError) {
+        this.disableDisconnectError = disableDisconnectError;
+    }
+
+    public void setFullscreen(boolean fullscreen) {
+        if (fullscreen == isFullscreen) {
+            return; // Avoid generating events when nothing is changing
+        }
+        isFullscreen = fullscreen;
+
+        Activity activity = themedReactContext.getCurrentActivity();
+        if (activity == null) {
+            return;
+        }
+
+        Window window = activity.getWindow();
+        View decorView = window.getDecorView();
+        int uiOptions;
+        if (isFullscreen) {
+            if (Util.SDK_INT >= 19) { // 4.4+
+                uiOptions = SYSTEM_UI_FLAG_HIDE_NAVIGATION
+                        | SYSTEM_UI_FLAG_IMMERSIVE_STICKY
+                        | SYSTEM_UI_FLAG_FULLSCREEN;
+            } else {
+                uiOptions = SYSTEM_UI_FLAG_HIDE_NAVIGATION
+                        | SYSTEM_UI_FLAG_FULLSCREEN;
+            }
+            eventEmitter.fullscreenWillPresent();
+            if (controls && fullScreenPlayerView != null) {
+                fullScreenPlayerView.show();
+            }
+            post(() -> {
+                decorView.setSystemUiVisibility(uiOptions);
+                eventEmitter.fullscreenDidPresent();
+            });
+        } else {
+            uiOptions = View.SYSTEM_UI_FLAG_VISIBLE;
+            eventEmitter.fullscreenWillDismiss();
+            if (controls && fullScreenPlayerView != null) {
+                fullScreenPlayerView.dismiss();
+                reLayout(exoPlayerView);
+            }
+            post(() -> {
+                decorView.setSystemUiVisibility(uiOptions);
+                eventEmitter.fullscreenDidDismiss();
+            });
+        }
+        // need to be done at the end to avoid hiding fullscreen control button when fullScreenPlayerView is shown
+        updateFullScreenButtonVisbility();
+    }
+
+    public void setUseTextureView(boolean useTextureView) {
+        boolean finallyUseTextureView = useTextureView && this.drmUUID == null;
+        exoPlayerView.setUseTextureView(finallyUseTextureView);
+    }
+
+    public void useSecureView(boolean useSecureView) {
+        exoPlayerView.useSecureView(useSecureView);
+    }
+
+    public void setHideShutterView(boolean hideShutterView) {
+        exoPlayerView.setHideShutterView(hideShutterView);
+    }
+
+    public void setBufferConfig(int newMinBufferMs, int newMaxBufferMs, int newBufferForPlaybackMs, int newBufferForPlaybackAfterRebufferMs, double newMaxHeapAllocationPercent, double newMinBackBufferMemoryReservePercent, double newMinBufferMemoryReservePercent) {
+        minBufferMs = newMinBufferMs;
+        maxBufferMs = newMaxBufferMs;
+        bufferForPlaybackMs = newBufferForPlaybackMs;
+        bufferForPlaybackAfterRebufferMs = newBufferForPlaybackAfterRebufferMs;
+        maxHeapAllocationPercent = newMaxHeapAllocationPercent;
+        minBackBufferMemoryReservePercent = newMinBackBufferMemoryReservePercent;
+        minBufferMemoryReservePercent = newMinBufferMemoryReservePercent;
+        releasePlayer();
+        initializePlayer();
+    }
+
+    public void setDrmType(UUID drmType) {
+        this.drmUUID = drmType;
+    }
+
+    public void setDrmLicenseUrl(String licenseUrl){
+        this.drmLicenseUrl = licenseUrl;
+    }
+
+    public void setDrmLicenseHeader(String[] header){
+        this.drmLicenseHeader = header;
+    }
+
+
+    @Override
+    public void onDrmKeysLoaded(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
+        Log.d("DRM Info", "onDrmKeysLoaded");
+    }
+
+    @Override
+    public void onDrmSessionManagerError(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId, Exception e) {
+        Log.d("DRM Info", "onDrmSessionManagerError");
+        eventEmitter.error("onDrmSessionManagerError", e, "3002");
+    }
+
+    @Override
+    public void onDrmKeysRestored(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
+        Log.d("DRM Info", "onDrmKeysRestored");
+    }
+
+    @Override
+    public void onDrmKeysRemoved(int windowIndex, MediaSource.MediaPeriodId mediaPeriodId) {
+        Log.d("DRM Info", "onDrmKeysRemoved");
+    }
+
+    /**
+     * Handling controls prop
+     *
+     * @param controls  Controls prop, if true enable controls, if false disable them
+     */
+    public void setControls(boolean controls) {
+        this.controls = controls;
+        if (controls) {
+            addPlayerControl();
+            updateFullScreenButtonVisbility();
+        } else {
+            int indexOfPC = indexOfChild(playerControlView);
+            if (indexOfPC != -1) {
+                removeViewAt(indexOfPC);
+            }
+        }
+    }
+
+    public void setSubtitleStyle(SubtitleStyle style) {
+        exoPlayerView.setSubtitleStyle(style);
+    }
+
+    public void setShutterColor(Integer color) {
+        exoPlayerView.setShutterColor(color);
+    }
+
+    @Override
+    public void onAdEvent(AdEvent adEvent) {
+        eventEmitter.receiveAdEvent(adEvent.getType().name());
+    }
+}
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ReactExoplayerViewManager.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerViewManager.java
similarity index 76%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ReactExoplayerViewManager.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerViewManager.java
index eccbee7..ed810ca 100644
--- a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ReactExoplayerViewManager.java
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ReactExoplayerViewManager.java
@@ -1,9 +1,9 @@
 package com.brentvatne.exoplayer;
 
+import android.graphics.Color;
 import android.content.Context;
 import android.net.Uri;
 import android.text.TextUtils;
-import android.util.Log;
 
 import com.facebook.react.bridge.Dynamic;
 import com.facebook.react.bridge.ReadableArray;
@@ -13,7 +13,6 @@ import com.facebook.react.common.MapBuilder;
 import com.facebook.react.uimanager.ThemedReactContext;
 import com.facebook.react.uimanager.ViewGroupManager;
 import com.facebook.react.uimanager.annotations.ReactProp;
-import com.facebook.react.bridge.ReactMethod;
 import com.google.android.exoplayer2.util.Util;
 import com.google.android.exoplayer2.DefaultLoadControl;
 import com.google.android.exoplayer2.upstream.RawResourceDataSource;
@@ -28,9 +27,11 @@ import javax.annotation.Nullable;
 public class ReactExoplayerViewManager extends ViewGroupManager<ReactExoplayerView> {
 
     private static final String REACT_CLASS = "RCTVideo";
-
     private static final String PROP_SRC = "src";
     private static final String PROP_SRC_URI = "uri";
+    private static final String PROP_SRC_START_TIME = "startTime";
+    private static final String PROP_SRC_END_TIME = "endTime";
+    private static final String PROP_AD_TAG_URL = "adTagUrl";
     private static final String PROP_SRC_TYPE = "type";
     private static final String PROP_DRM = "drm";
     private static final String PROP_DRM_TYPE = "type";
@@ -49,11 +50,15 @@ public class ReactExoplayerViewManager extends ViewGroupManager<ReactExoplayerVi
     private static final String PROP_PAUSED = "paused";
     private static final String PROP_MUTED = "muted";
     private static final String PROP_VOLUME = "volume";
+    private static final String PROP_BACK_BUFFER_DURATION_MS = "backBufferDurationMs";
     private static final String PROP_BUFFER_CONFIG = "bufferConfig";
     private static final String PROP_BUFFER_CONFIG_MIN_BUFFER_MS = "minBufferMs";
     private static final String PROP_BUFFER_CONFIG_MAX_BUFFER_MS = "maxBufferMs";
     private static final String PROP_BUFFER_CONFIG_BUFFER_FOR_PLAYBACK_MS = "bufferForPlaybackMs";
     private static final String PROP_BUFFER_CONFIG_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS = "bufferForPlaybackAfterRebufferMs";
+    private static final String PROP_BUFFER_CONFIG_MAX_HEAP_ALLOCATION_PERCENT = "maxHeapAllocationPercent";
+    private static final String PROP_BUFFER_CONFIG_MIN_BACK_BUFFER_MEMORY_RESERVE_PERCENT = "minBackBufferMemoryReservePercent";
+    private static final String PROP_BUFFER_CONFIG_MIN_BUFFER_MEMORY_RESERVE_PERCENT = "minBufferMemoryReservePercent";
     private static final String PROP_PREVENTS_DISPLAY_SLEEP_DURING_VIDEO_PLAYBACK = "preventsDisplaySleepDuringVideoPlayback";
     private static final String PROP_PROGRESS_UPDATE_INTERVAL = "progressUpdateInterval";
     private static final String PROP_REPORT_BANDWIDTH = "reportBandwidth";
@@ -62,14 +67,21 @@ public class ReactExoplayerViewManager extends ViewGroupManager<ReactExoplayerVi
     private static final String PROP_MIN_LOAD_RETRY_COUNT = "minLoadRetryCount";
     private static final String PROP_MAXIMUM_BIT_RATE = "maxBitRate";
     private static final String PROP_PLAY_IN_BACKGROUND = "playInBackground";
+    private static final String PROP_CONTENT_START_TIME = "contentStartTime";
     private static final String PROP_DISABLE_FOCUS = "disableFocus";
+    private static final String PROP_DISABLE_BUFFERING = "disableBuffering";
+    private static final String PROP_DISABLE_DISCONNECT_ERROR = "disableDisconnectError";
+    private static final String PROP_FOCUSABLE = "focusable";
     private static final String PROP_FULLSCREEN = "fullscreen";
     private static final String PROP_USE_TEXTURE_VIEW = "useTextureView";
+    private static final String PROP_SECURE_VIEW = "useSecureView";
     private static final String PROP_SELECTED_VIDEO_TRACK = "selectedVideoTrack";
     private static final String PROP_SELECTED_VIDEO_TRACK_TYPE = "type";
     private static final String PROP_SELECTED_VIDEO_TRACK_VALUE = "value";
     private static final String PROP_HIDE_SHUTTER_VIEW = "hideShutterView";
     private static final String PROP_CONTROLS = "controls";
+    private static final String PROP_SUBTITLE_STYLE = "subtitleStyle";
+    private static final String PROP_SHUTTER_COLOR = "shutterColor";
 
     private ReactExoplayerConfig config;
 
@@ -140,6 +152,8 @@ public class ReactExoplayerViewManager extends ViewGroupManager<ReactExoplayerVi
     public void setSrc(final ReactExoplayerView videoView, @Nullable ReadableMap src) {
         Context context = videoView.getContext().getApplicationContext();
         String uriString = src.hasKey(PROP_SRC_URI) ? src.getString(PROP_SRC_URI) : null;
+        int startTimeMs = src.hasKey(PROP_SRC_START_TIME) ? src.getInt(PROP_SRC_START_TIME) : -1;
+        int endTimeMs = src.hasKey(PROP_SRC_END_TIME) ? src.getInt(PROP_SRC_END_TIME) : -1;
         String extension = src.hasKey(PROP_SRC_TYPE) ? src.getString(PROP_SRC_TYPE) : null;
         Map<String, String> headers = src.hasKey(PROP_SRC_HEADERS) ? toStringMap(src.getMap(PROP_SRC_HEADERS)) : null;
 
@@ -152,7 +166,7 @@ public class ReactExoplayerViewManager extends ViewGroupManager<ReactExoplayerVi
             Uri srcUri = Uri.parse(uriString);
 
             if (srcUri != null) {
-                videoView.setSrc(srcUri, extension, headers);
+                videoView.setSrc(srcUri, startTimeMs, endTimeMs, extension, headers);
             }
         } else {
             int identifier = context.getResources().getIdentifier(
@@ -172,10 +186,24 @@ public class ReactExoplayerViewManager extends ViewGroupManager<ReactExoplayerVi
                 if (srcUri != null) {
                     videoView.setRawSrc(srcUri, extension);
                 }
+            } else {
+                videoView.clearSrc();
             }
         }
     }
 
+    @ReactProp(name = PROP_AD_TAG_URL)
+    public void setAdTagUrl(final ReactExoplayerView videoView, final String uriString) {
+        if (TextUtils.isEmpty(uriString)) {
+            return;
+        }
+
+        Uri adTagUrl = Uri.parse(uriString);
+
+        videoView.setAdTagUrl(adTagUrl);
+    }
+
+
     @ReactProp(name = PROP_RESIZE_MODE)
     public void setResizeMode(final ReactExoplayerView videoView, final String resizeModeOrdinalString) {
         videoView.setResizeModeModifier(convertToIntDef(resizeModeOrdinalString));
@@ -294,6 +322,31 @@ public class ReactExoplayerViewManager extends ViewGroupManager<ReactExoplayerVi
         videoView.setDisableFocus(disableFocus);
     }
 
+    @ReactProp(name = PROP_FOCUSABLE, defaultBoolean = true)
+    public void setFocusable(final ReactExoplayerView videoView, final boolean focusable) {
+        videoView.setFocusable(focusable);
+    }
+
+    @ReactProp(name = PROP_BACK_BUFFER_DURATION_MS, defaultInt = 0)
+    public void setBackBufferDurationMs(final ReactExoplayerView videoView, final int backBufferDurationMs) {
+        videoView.setBackBufferDurationMs(backBufferDurationMs);
+    }
+
+    @ReactProp(name = PROP_CONTENT_START_TIME, defaultInt = -1)
+    public void setContentStartTime(final ReactExoplayerView videoView, final int contentStartTime) {
+        videoView.setContentStartTime(contentStartTime);
+    }
+
+    @ReactProp(name = PROP_DISABLE_BUFFERING, defaultBoolean = false)
+    public void setDisableBuffering(final ReactExoplayerView videoView, final boolean disableBuffering) {
+        videoView.setDisableBuffering(disableBuffering);
+    }
+
+    @ReactProp(name = PROP_DISABLE_DISCONNECT_ERROR, defaultBoolean = false)
+    public void setDisableDisconnectError(final ReactExoplayerView videoView, final boolean disableDisconnectError) {
+        videoView.setDisableDisconnectError(disableDisconnectError);
+    }
+
     @ReactProp(name = PROP_FULLSCREEN, defaultBoolean = false)
     public void setFullscreen(final ReactExoplayerView videoView, final boolean fullscreen) {
         videoView.setFullscreen(fullscreen);
@@ -304,6 +357,11 @@ public class ReactExoplayerViewManager extends ViewGroupManager<ReactExoplayerVi
         videoView.setUseTextureView(useTextureView);
     }
 
+    @ReactProp(name = PROP_SECURE_VIEW, defaultBoolean = true)
+    public void useSecureView(final ReactExoplayerView videoView, final boolean useSecureView) {
+        videoView.useSecureView(useSecureView);
+    }
+
     @ReactProp(name = PROP_HIDE_SHUTTER_VIEW, defaultBoolean = false)
     public void setHideShutterView(final ReactExoplayerView videoView, final boolean hideShutterView) {
         videoView.setHideShutterView(hideShutterView);
@@ -314,12 +372,26 @@ public class ReactExoplayerViewManager extends ViewGroupManager<ReactExoplayerVi
         videoView.setControls(controls);
     }
 
+    @ReactProp(name = PROP_SUBTITLE_STYLE)
+    public void setSubtitleStyle(final ReactExoplayerView videoView, @Nullable final ReadableMap src) {
+        videoView.setSubtitleStyle(SubtitleStyle.parse(src));
+    }
+
+    @ReactProp(name = PROP_SHUTTER_COLOR, customType = "Color")
+    public void setShutterColor(final ReactExoplayerView videoView, final Integer color) {
+        videoView.setShutterColor(color == null ? Color.BLACK : color);
+    }
+
     @ReactProp(name = PROP_BUFFER_CONFIG)
     public void setBufferConfig(final ReactExoplayerView videoView, @Nullable ReadableMap bufferConfig) {
         int minBufferMs = DefaultLoadControl.DEFAULT_MIN_BUFFER_MS;
         int maxBufferMs = DefaultLoadControl.DEFAULT_MAX_BUFFER_MS;
         int bufferForPlaybackMs = DefaultLoadControl.DEFAULT_BUFFER_FOR_PLAYBACK_MS;
         int bufferForPlaybackAfterRebufferMs = DefaultLoadControl.DEFAULT_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS;
+        double maxHeapAllocationPercent = ReactExoplayerView.DEFAULT_MAX_HEAP_ALLOCATION_PERCENT;
+        double minBackBufferMemoryReservePercent = ReactExoplayerView.DEFAULT_MIN_BACK_BUFFER_MEMORY_RESERVE;
+        double minBufferMemoryReservePercent = ReactExoplayerView.DEFAULT_MIN_BUFFER_MEMORY_RESERVE;
+
         if (bufferConfig != null) {
             minBufferMs = bufferConfig.hasKey(PROP_BUFFER_CONFIG_MIN_BUFFER_MS)
                     ? bufferConfig.getInt(PROP_BUFFER_CONFIG_MIN_BUFFER_MS) : minBufferMs;
@@ -329,16 +401,23 @@ public class ReactExoplayerViewManager extends ViewGroupManager<ReactExoplayerVi
                     ? bufferConfig.getInt(PROP_BUFFER_CONFIG_BUFFER_FOR_PLAYBACK_MS) : bufferForPlaybackMs;
             bufferForPlaybackAfterRebufferMs = bufferConfig.hasKey(PROP_BUFFER_CONFIG_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS)
                     ? bufferConfig.getInt(PROP_BUFFER_CONFIG_BUFFER_FOR_PLAYBACK_AFTER_REBUFFER_MS) : bufferForPlaybackAfterRebufferMs;
-            videoView.setBufferConfig(minBufferMs, maxBufferMs, bufferForPlaybackMs, bufferForPlaybackAfterRebufferMs);
+            maxHeapAllocationPercent = bufferConfig.hasKey(PROP_BUFFER_CONFIG_MAX_HEAP_ALLOCATION_PERCENT)
+                    ? bufferConfig.getDouble(PROP_BUFFER_CONFIG_MAX_HEAP_ALLOCATION_PERCENT) : maxHeapAllocationPercent;
+            minBackBufferMemoryReservePercent = bufferConfig.hasKey(PROP_BUFFER_CONFIG_MIN_BACK_BUFFER_MEMORY_RESERVE_PERCENT)
+                    ? bufferConfig.getDouble(PROP_BUFFER_CONFIG_MIN_BACK_BUFFER_MEMORY_RESERVE_PERCENT) : minBackBufferMemoryReservePercent;
+            minBufferMemoryReservePercent = bufferConfig.hasKey(PROP_BUFFER_CONFIG_MIN_BUFFER_MEMORY_RESERVE_PERCENT)
+                    ? bufferConfig.getDouble(PROP_BUFFER_CONFIG_MIN_BUFFER_MEMORY_RESERVE_PERCENT) : minBufferMemoryReservePercent;
+            videoView.setBufferConfig(minBufferMs, maxBufferMs, bufferForPlaybackMs, bufferForPlaybackAfterRebufferMs, maxHeapAllocationPercent, minBackBufferMemoryReservePercent, minBufferMemoryReservePercent);
         }
     }
 
     private boolean startsWithValidScheme(String uriString) {
-        return uriString.startsWith("http://")
-                || uriString.startsWith("https://")
-                || uriString.startsWith("content://")
-                || uriString.startsWith("file://")
-                || uriString.startsWith("asset://");
+        String lowerCaseUri = uriString.toLowerCase();
+        return lowerCaseUri.startsWith("http://")
+                || lowerCaseUri.startsWith("https://")
+                || lowerCaseUri.startsWith("content://")
+                || lowerCaseUri.startsWith("file://")
+                || lowerCaseUri.startsWith("asset://");
     }
 
     private @ResizeMode.Mode int convertToIntDef(String resizeModeOrdinalString) {
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ResizeMode.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ResizeMode.java
similarity index 100%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/ResizeMode.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/ResizeMode.java
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/SubtitleStyle.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/SubtitleStyle.java
new file mode 100644
index 0000000..bc4e305
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/SubtitleStyle.java
@@ -0,0 +1,38 @@
+package com.brentvatne.exoplayer;
+import com.brentvatne.ReactBridgeUtils;
+import com.facebook.react.bridge.ReadableMap;
+
+/**
+ * Helper file to parse SubtitleStyle prop and build a dedicated class
+ */
+public class SubtitleStyle {
+    private static final String PROP_FONT_SIZE_TRACK = "fontSize";
+    private static final String PROP_PADDING_BOTTOM = "paddingBottom";
+    private static final String PROP_PADDING_TOP = "paddingTop";
+    private static final String PROP_PADDING_LEFT = "paddingLeft";
+    private static final String PROP_PADDING_RIGHT = "paddingRight";
+
+    private int fontSize = -1;
+    private int paddingLeft = 0;
+    private int paddingRight = 0;
+    private int paddingTop = 0;
+    private int paddingBottom = 0;
+
+    private SubtitleStyle() {}
+
+    int getFontSize() {return fontSize;}
+    int getPaddingBottom() {return paddingBottom;}
+    int getPaddingTop() {return paddingTop;}
+    int getPaddingLeft() {return paddingLeft;}
+    int getPaddingRight() {return paddingRight;}
+
+    public static SubtitleStyle parse(ReadableMap src) {
+        SubtitleStyle subtitleStyle = new SubtitleStyle();
+        subtitleStyle.fontSize = ReactBridgeUtils.safeGetInt(src, PROP_FONT_SIZE_TRACK, -1);
+        subtitleStyle.paddingBottom = ReactBridgeUtils.safeGetInt(src, PROP_PADDING_BOTTOM, 0);
+        subtitleStyle.paddingTop = ReactBridgeUtils.safeGetInt(src, PROP_PADDING_TOP, 0);
+        subtitleStyle.paddingLeft = ReactBridgeUtils.safeGetInt(src, PROP_PADDING_LEFT, 0);
+        subtitleStyle.paddingRight = ReactBridgeUtils.safeGetInt(src, PROP_PADDING_RIGHT, 0);
+        return subtitleStyle;
+    }
+}
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/VideoEventEmitter.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/VideoEventEmitter.java
similarity index 64%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/VideoEventEmitter.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/VideoEventEmitter.java
index ea0cc5a..24d8eaf 100644
--- a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/exoplayer/VideoEventEmitter.java
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/exoplayer/VideoEventEmitter.java
@@ -3,6 +3,8 @@ package com.brentvatne.exoplayer;
 import androidx.annotation.StringDef;
 import android.view.View;
 
+import com.brentvatne.common.Track;
+import com.brentvatne.common.VideoTrack;
 import com.facebook.react.bridge.Arguments;
 import com.facebook.react.bridge.ReactContext;
 import com.facebook.react.bridge.WritableArray;
@@ -15,6 +17,9 @@ import com.google.android.exoplayer2.metadata.id3.TextInformationFrame;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.io.StringWriter;
+import java.io.PrintWriter;
+import java.util.ArrayList;
 
 class VideoEventEmitter {
 
@@ -42,11 +47,16 @@ class VideoEventEmitter {
     private static final String EVENT_RESUME = "onPlaybackResume";
     private static final String EVENT_READY = "onReadyForDisplay";
     private static final String EVENT_BUFFER = "onVideoBuffer";
+    private static final String EVENT_PLAYBACK_STATE_CHANGED = "onVideoPlaybackStateChanged";
     private static final String EVENT_IDLE = "onVideoIdle";
     private static final String EVENT_TIMED_METADATA = "onTimedMetadata";
     private static final String EVENT_AUDIO_BECOMING_NOISY = "onVideoAudioBecomingNoisy";
     private static final String EVENT_AUDIO_FOCUS_CHANGE = "onAudioFocusChanged";
     private static final String EVENT_PLAYBACK_RATE_CHANGE = "onPlaybackRateChange";
+    private static final String EVENT_AUDIO_TRACKS = "onAudioTracks";
+    private static final String EVENT_TEXT_TRACKS = "onTextTracks";
+    private static final String EVENT_VIDEO_TRACKS = "onVideoTracks";
+    private static final String EVENT_ON_RECEIVE_AD_EVENT = "onReceiveAdEvent";
 
     static final String[] Events = {
             EVENT_LOAD_START,
@@ -63,12 +73,17 @@ class VideoEventEmitter {
             EVENT_RESUME,
             EVENT_READY,
             EVENT_BUFFER,
+            EVENT_PLAYBACK_STATE_CHANGED,
             EVENT_IDLE,
             EVENT_TIMED_METADATA,
             EVENT_AUDIO_BECOMING_NOISY,
             EVENT_AUDIO_FOCUS_CHANGE,
             EVENT_PLAYBACK_RATE_CHANGE,
+            EVENT_AUDIO_TRACKS,
+            EVENT_TEXT_TRACKS,
+            EVENT_VIDEO_TRACKS,
             EVENT_BANDWIDTH,
+            EVENT_ON_RECEIVE_AD_EVENT
     };
 
     @Retention(RetentionPolicy.SOURCE)
@@ -87,12 +102,17 @@ class VideoEventEmitter {
             EVENT_RESUME,
             EVENT_READY,
             EVENT_BUFFER,
+            EVENT_PLAYBACK_STATE_CHANGED,
             EVENT_IDLE,
             EVENT_TIMED_METADATA,
             EVENT_AUDIO_BECOMING_NOISY,
             EVENT_AUDIO_FOCUS_CHANGE,
             EVENT_PLAYBACK_RATE_CHANGE,
+            EVENT_AUDIO_TRACKS,
+            EVENT_TEXT_TRACKS,
+            EVENT_VIDEO_TRACKS,
             EVENT_BANDWIDTH,
+            EVENT_ON_RECEIVE_AD_EVENT
     })
     @interface VideoEvents {
     }
@@ -104,6 +124,8 @@ class VideoEventEmitter {
     private static final String EVENT_PROP_STEP_FORWARD = "canStepForward";
     private static final String EVENT_PROP_STEP_BACKWARD = "canStepBackward";
 
+    private static final String EVENT_PROP_BUFFER_START = "bufferStart";
+    private static final String EVENT_PROP_BUFFER_END = "bufferEnd";
     private static final String EVENT_PROP_DURATION = "duration";
     private static final String EVENT_PROP_PLAYABLE_DURATION = "playableDuration";
     private static final String EVENT_PROP_SEEKABLE_DURATION = "seekableDuration";
@@ -125,11 +147,14 @@ class VideoEventEmitter {
     private static final String EVENT_PROP_ERROR = "error";
     private static final String EVENT_PROP_ERROR_STRING = "errorString";
     private static final String EVENT_PROP_ERROR_EXCEPTION = "errorException";
+    private static final String EVENT_PROP_ERROR_TRACE = "errorStackTrace";
+    private static final String EVENT_PROP_ERROR_CODE = "errorCode";
 
     private static final String EVENT_PROP_TIMED_METADATA = "metadata";
 
     private static final String EVENT_PROP_BITRATE = "bitrate";
 
+    private static final String EVENT_PROP_IS_PLAYING = "isPlaying";
 
     void setViewId(int viewId) {
         this.viewId = viewId;
@@ -139,20 +164,90 @@ class VideoEventEmitter {
         receiveEvent(EVENT_LOAD_START, null);
     }
 
-    void load(double duration, double currentPosition, int videoWidth, int videoHeight,
-              WritableArray audioTracks, WritableArray textTracks, WritableArray videoTracks, String trackId) {
-        WritableMap event = Arguments.createMap();
-        event.putDouble(EVENT_PROP_DURATION, duration / 1000D);
-        event.putDouble(EVENT_PROP_CURRENT_TIME, currentPosition / 1000D);
-
+    WritableMap aspectRatioToNaturalSize(int videoWidth, int videoHeight) {
         WritableMap naturalSize = Arguments.createMap();
         naturalSize.putInt(EVENT_PROP_WIDTH, videoWidth);
         naturalSize.putInt(EVENT_PROP_HEIGHT, videoHeight);
         if (videoWidth > videoHeight) {
             naturalSize.putString(EVENT_PROP_ORIENTATION, "landscape");
-        } else {
+        } else if (videoWidth < videoHeight) {
             naturalSize.putString(EVENT_PROP_ORIENTATION, "portrait");
+        } else {
+            naturalSize.putString(EVENT_PROP_ORIENTATION, "square");
         }
+        return naturalSize;
+    }
+
+    WritableArray audioTracksToArray(ArrayList<Track> audioTracks) {
+        WritableArray waAudioTracks = Arguments.createArray();
+        if( audioTracks != null ){
+            for (int i = 0; i < audioTracks.size(); ++i) {
+                Track format = audioTracks.get(i);
+                WritableMap audioTrack = Arguments.createMap();
+                audioTrack.putInt("index", i);
+                audioTrack.putString("title", format.m_title != null ? format.m_title : "");
+                audioTrack.putString("type", format.m_mimeType != null ? format.m_mimeType : "");
+                audioTrack.putString("language", format.m_language != null ? format.m_language : "");
+                audioTrack.putInt("bitrate", format.m_bitrate);
+                audioTrack.putBoolean("selected", format.m_isSelected);
+                waAudioTracks.pushMap(audioTrack);
+            }
+        }
+        return waAudioTracks;
+    }
+
+    WritableArray videoTracksToArray(ArrayList<VideoTrack> videoTracks) {
+        WritableArray waVideoTracks = Arguments.createArray();
+        if( videoTracks != null ){
+            for (int i = 0; i < videoTracks.size(); ++i) {
+                VideoTrack vTrack = videoTracks.get(i);
+                WritableMap videoTrack = Arguments.createMap();
+                videoTrack.putInt("width", vTrack.m_width);
+                videoTrack.putInt("height",vTrack.m_height);
+                videoTrack.putInt("bitrate", vTrack.m_bitrate);
+                videoTrack.putString("codecs", vTrack.m_codecs);
+                videoTrack.putInt("trackId",vTrack.m_id);
+                videoTrack.putBoolean("selected", vTrack.m_isSelected);
+                waVideoTracks.pushMap(videoTrack);
+            }
+        }
+        return waVideoTracks;
+    }
+
+    WritableArray textTracksToArray(ArrayList<Track> textTracks) {
+        WritableArray waTextTracks = Arguments.createArray();
+        if (textTracks != null) {
+            for (int i = 0; i < textTracks.size(); ++i) {
+                Track format = textTracks.get(i);
+                WritableMap textTrack = Arguments.createMap();
+                textTrack.putInt("index", i);
+                textTrack.putString("title", format.m_title != null ? format.m_title : "");
+                textTrack.putString("type", format.m_mimeType != null ? format.m_mimeType : "");
+                textTrack.putString("language", format.m_language != null ? format.m_language : "");
+                textTrack.putBoolean("selected", format.m_isSelected);
+                waTextTracks.pushMap(textTrack);
+            }
+        }
+        return waTextTracks;
+    }
+
+    public void load(double duration, double currentPosition, int videoWidth, int videoHeight,
+                     ArrayList<Track> audioTracks, ArrayList<Track> textTracks, ArrayList<VideoTrack> videoTracks, String trackId){
+        WritableArray waAudioTracks = audioTracksToArray(audioTracks);
+        WritableArray waVideoTracks = videoTracksToArray(videoTracks);
+        WritableArray waTextTracks = textTracksToArray(textTracks);
+
+        load( duration,  currentPosition,  videoWidth,  videoHeight, waAudioTracks,  waTextTracks,  waVideoTracks, trackId);
+    }
+
+
+    private void load(double duration, double currentPosition, int videoWidth, int videoHeight,
+              WritableArray audioTracks, WritableArray textTracks, WritableArray videoTracks, String trackId) {
+        WritableMap event = Arguments.createMap();
+        event.putDouble(EVENT_PROP_DURATION, duration / 1000D);
+        event.putDouble(EVENT_PROP_CURRENT_TIME, currentPosition / 1000D);
+
+        WritableMap naturalSize = aspectRatioToNaturalSize(videoWidth, videoHeight);
         event.putMap(EVENT_PROP_NATURAL_SIZE, naturalSize);
         event.putString(EVENT_PROP_TRACK_ID, trackId);
         event.putArray(EVENT_PROP_VIDEO_TRACKS, videoTracks);
@@ -171,6 +266,26 @@ class VideoEventEmitter {
         receiveEvent(EVENT_LOAD, event);
     }
 
+
+
+    WritableMap arrayToObject(String field, WritableArray array) {
+        WritableMap event = Arguments.createMap();
+        event.putArray(field, array);
+        return event;
+    }
+
+    public void audioTracks(ArrayList<Track> audioTracks){
+        receiveEvent(EVENT_AUDIO_TRACKS, arrayToObject(EVENT_PROP_AUDIO_TRACKS, audioTracksToArray(audioTracks)));
+    }
+
+    public void textTracks(ArrayList<Track> textTracks){
+        receiveEvent(EVENT_TEXT_TRACKS, arrayToObject(EVENT_PROP_TEXT_TRACKS, textTracksToArray(textTracks)));
+    }
+
+    public void videoTracks(ArrayList<VideoTrack> videoTracks){
+        receiveEvent(EVENT_VIDEO_TRACKS, arrayToObject(EVENT_PROP_VIDEO_TRACKS, videoTracksToArray(videoTracks)));
+    }
+
     void progressChanged(double currentPosition, double bufferedDuration, double seekableDuration, double currentPlaybackTime) {
         WritableMap event = Arguments.createMap();
         event.putDouble(EVENT_PROP_CURRENT_TIME, currentPosition / 1000D);
@@ -206,6 +321,12 @@ class VideoEventEmitter {
         receiveEvent(EVENT_BUFFER, map);
     }
 
+    void playbackStateChanged(boolean isPlaying) {
+        WritableMap map = Arguments.createMap();
+        map.putBoolean(EVENT_PROP_IS_PLAYING, isPlaying);
+        receiveEvent(EVENT_PLAYBACK_STATE_CHANGED, map);
+    }
+
     void idle() {
         receiveEvent(EVENT_IDLE, null);
     }
@@ -231,9 +352,25 @@ class VideoEventEmitter {
     }
 
     void error(String errorString, Exception exception) {
+        _error(errorString, exception, "0001");
+    }
+
+    void error(String errorString, Exception exception, String errorCode) {
+        _error(errorString, exception, errorCode);
+    }
+
+    void _error(String errorString, Exception exception, String errorCode) {
+        // Prepare stack trace
+        StringWriter sw = new StringWriter();
+        PrintWriter pw = new PrintWriter(sw);
+        exception.printStackTrace(pw);
+        String stackTrace = sw.toString();
+
         WritableMap error = Arguments.createMap();
         error.putString(EVENT_PROP_ERROR_STRING, errorString);
         error.putString(EVENT_PROP_ERROR_EXCEPTION, exception.toString());
+        error.putString(EVENT_PROP_ERROR_CODE, errorCode);
+        error.putString(EVENT_PROP_ERROR_TRACE, stackTrace);
         WritableMap event = Arguments.createMap();
         event.putMap(EVENT_PROP_ERROR, error);
         receiveEvent(EVENT_ERROR, event);
@@ -298,6 +435,13 @@ class VideoEventEmitter {
         receiveEvent(EVENT_AUDIO_BECOMING_NOISY, null);
     }
 
+    void receiveAdEvent(String event) {
+        WritableMap map = Arguments.createMap();
+        map.putString("event", event);
+
+        receiveEvent(EVENT_ON_RECEIVE_AD_EVENT, map);
+    }
+
     private void receiveEvent(@VideoEvents String type, WritableMap event) {
         eventEmitter.receiveEvent(viewId, type, event);
     }
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/ReactVideoPackage.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/ReactVideoPackage.java
index b09e941..23bedad 100644
--- a/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/ReactVideoPackage.java
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/ReactVideoPackage.java
@@ -1,21 +1,33 @@
 package com.brentvatne.react;
 
-import android.app.Activity;
+import com.brentvatne.exoplayer.DefaultReactExoplayerConfig;
+import com.brentvatne.exoplayer.ReactExoplayerConfig;
+import com.brentvatne.exoplayer.ReactExoplayerViewManager;
 import com.facebook.react.ReactPackage;
 import com.facebook.react.bridge.JavaScriptModule;
 import com.facebook.react.bridge.NativeModule;
 import com.facebook.react.bridge.ReactApplicationContext;
 import com.facebook.react.uimanager.ViewManager;
 
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 public class ReactVideoPackage implements ReactPackage {
 
+    private ReactExoplayerConfig config;
+
+    public ReactVideoPackage() {
+    }
+
+    public ReactVideoPackage(ReactExoplayerConfig config) {
+        this.config = config;
+    }
+
     @Override
     public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {
-        return Collections.emptyList();
+        return Collections.singletonList(
+                new VideoDecoderPropertiesModule(reactContext)
+        );
     }
 
     // Deprecated RN 0.47
@@ -23,8 +35,12 @@ public class ReactVideoPackage implements ReactPackage {
         return Collections.emptyList();
     }
 
+
     @Override
     public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
-        return Arrays.<ViewManager>asList(new ReactVideoViewManager());
+        if (config == null) {
+            config = new DefaultReactExoplayerConfig(reactContext);
+        }
+        return Collections.singletonList(new ReactExoplayerViewManager(config));
     }
 }
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/ReactVideoView.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/ReactVideoView.java
deleted file mode 100644
index f3f5fe7..0000000
--- a/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/ReactVideoView.java
+++ /dev/null
@@ -1,796 +0,0 @@
-package com.brentvatne.react;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.res.AssetFileDescriptor;
-import android.graphics.Matrix;
-import android.media.MediaPlayer;
-import android.media.TimedMetaData;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Handler;
-import android.util.Log;
-import android.view.MotionEvent;
-import android.view.WindowManager;
-import android.view.View;
-import android.view.Window;
-import android.webkit.CookieManager;
-import android.widget.MediaController;
-
-import com.android.vending.expansion.zipfile.APKExpansionSupport;
-import com.android.vending.expansion.zipfile.ZipResourceFile;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.LifecycleEventListener;
-import com.facebook.react.bridge.ReadableMap;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.bridge.WritableArray;
-import com.facebook.react.bridge.WritableNativeArray;
-import com.facebook.react.uimanager.ThemedReactContext;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-import com.yqritc.scalablevideoview.ScalableType;
-import com.yqritc.scalablevideoview.ScalableVideoView;
-import com.yqritc.scalablevideoview.ScaleManager;
-import com.yqritc.scalablevideoview.Size;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.util.HashMap;
-import java.util.Map;
-import java.lang.Math;
-import java.math.BigDecimal;
-
-import javax.annotation.Nullable;
-
-@SuppressLint("ViewConstructor")
-public class ReactVideoView extends ScalableVideoView implements
-    MediaPlayer.OnPreparedListener,
-    MediaPlayer.OnErrorListener,
-    MediaPlayer.OnBufferingUpdateListener,
-    MediaPlayer.OnSeekCompleteListener,
-    MediaPlayer.OnCompletionListener,
-    MediaPlayer.OnInfoListener,
-    LifecycleEventListener,
-    MediaController.MediaPlayerControl {
-
-    public enum Events {
-        EVENT_LOAD_START("onVideoLoadStart"),
-        EVENT_LOAD("onVideoLoad"),
-        EVENT_ERROR("onVideoError"),
-        EVENT_PROGRESS("onVideoProgress"),
-        EVENT_TIMED_METADATA("onTimedMetadata"),
-        EVENT_SEEK("onVideoSeek"),
-        EVENT_END("onVideoEnd"),
-        EVENT_STALLED("onPlaybackStalled"),
-        EVENT_RESUME("onPlaybackResume"),
-        EVENT_READY_FOR_DISPLAY("onReadyForDisplay"),
-        EVENT_FULLSCREEN_WILL_PRESENT("onVideoFullscreenPlayerWillPresent"),
-        EVENT_FULLSCREEN_DID_PRESENT("onVideoFullscreenPlayerDidPresent"),
-        EVENT_FULLSCREEN_WILL_DISMISS("onVideoFullscreenPlayerWillDismiss"),
-        EVENT_FULLSCREEN_DID_DISMISS("onVideoFullscreenPlayerDidDismiss");
-
-        private final String mName;
-
-        Events(final String name) {
-            mName = name;
-        }
-
-        @Override
-        public String toString() {
-            return mName;
-        }
-    }
-
-    public static final String EVENT_PROP_FAST_FORWARD = "canPlayFastForward";
-    public static final String EVENT_PROP_SLOW_FORWARD = "canPlaySlowForward";
-    public static final String EVENT_PROP_SLOW_REVERSE = "canPlaySlowReverse";
-    public static final String EVENT_PROP_REVERSE = "canPlayReverse";
-    public static final String EVENT_PROP_STEP_FORWARD = "canStepForward";
-    public static final String EVENT_PROP_STEP_BACKWARD = "canStepBackward";
-
-    public static final String EVENT_PROP_DURATION = "duration";
-    public static final String EVENT_PROP_PLAYABLE_DURATION = "playableDuration";
-    public static final String EVENT_PROP_SEEKABLE_DURATION = "seekableDuration";
-    public static final String EVENT_PROP_CURRENT_TIME = "currentTime";
-    public static final String EVENT_PROP_SEEK_TIME = "seekTime";
-    public static final String EVENT_PROP_NATURALSIZE = "naturalSize";
-    public static final String EVENT_PROP_WIDTH = "width";
-    public static final String EVENT_PROP_HEIGHT = "height";
-    public static final String EVENT_PROP_ORIENTATION = "orientation";
-    public static final String EVENT_PROP_METADATA = "metadata";
-    public static final String EVENT_PROP_TARGET = "target";
-    public static final String EVENT_PROP_METADATA_IDENTIFIER = "identifier";
-    public static final String EVENT_PROP_METADATA_VALUE = "value";
-
-    public static final String EVENT_PROP_ERROR = "error";
-    public static final String EVENT_PROP_WHAT = "what";
-    public static final String EVENT_PROP_EXTRA = "extra";
-
-    private ThemedReactContext mThemedReactContext;
-    private RCTEventEmitter mEventEmitter;
-
-    private Handler mProgressUpdateHandler = new Handler();
-    private Runnable mProgressUpdateRunnable = null;
-    private Handler videoControlHandler = new Handler();
-    private MediaController mediaController;
-
-    private String mSrcUriString = null;
-    private String mSrcType = "mp4";
-    private ReadableMap mRequestHeaders = null;
-    private boolean mSrcIsNetwork = false;
-    private boolean mSrcIsAsset = false;
-    private ScalableType mResizeMode = ScalableType.LEFT_TOP;
-    private boolean mRepeat = false;
-    private boolean mPaused = false;
-    private boolean mMuted = false;
-    private boolean mPreventsDisplaySleepDuringVideoPlayback = true;
-    private float mVolume = 1.0f;
-    private float mStereoPan = 0.0f;
-    private float mProgressUpdateInterval = 250.0f;
-    private float mRate = 1.0f;
-    private float mActiveRate = 1.0f;
-    private long mSeekTime = 0;
-    private boolean mPlayInBackground = false;
-    private boolean mBackgroundPaused = false;
-    private boolean mIsFullscreen = false;
-
-    private int mMainVer = 0;
-    private int mPatchVer = 0;
-
-    private boolean mMediaPlayerValid = false; // True if mMediaPlayer is in prepared, started, paused or completed state.
-
-    private int mVideoDuration = 0;
-    private int mVideoBufferedDuration = 0;
-    private boolean isCompleted = false;
-    private boolean mUseNativeControls = false;
-
-    public ReactVideoView(ThemedReactContext themedReactContext) {
-        super(themedReactContext);
-
-        mThemedReactContext = themedReactContext;
-        mEventEmitter = themedReactContext.getJSModule(RCTEventEmitter.class);
-        themedReactContext.addLifecycleEventListener(this);
-
-        initializeMediaPlayerIfNeeded();
-        setSurfaceTextureListener(this);
-
-        mProgressUpdateRunnable = new Runnable() {
-            @Override
-            public void run() {
-
-                if (mMediaPlayerValid && !isCompleted && !mPaused && !mBackgroundPaused) {
-                    WritableMap event = Arguments.createMap();
-                    event.putDouble(EVENT_PROP_CURRENT_TIME, mMediaPlayer.getCurrentPosition() / 1000.0);
-                    event.putDouble(EVENT_PROP_PLAYABLE_DURATION, mVideoBufferedDuration / 1000.0); //TODO:mBufferUpdateRunnable
-                    event.putDouble(EVENT_PROP_SEEKABLE_DURATION, mVideoDuration / 1000.0);
-                    mEventEmitter.receiveEvent(getId(), Events.EVENT_PROGRESS.toString(), event);
-
-                    // Check for update after an interval
-                    mProgressUpdateHandler.postDelayed(mProgressUpdateRunnable, Math.round(mProgressUpdateInterval));
-                }
-            }
-        };
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        if (mUseNativeControls) {
-            initializeMediaControllerIfNeeded();
-            mediaController.show();
-        }
-
-        return super.onTouchEvent(event);
-    }
-
-    @Override
-    @SuppressLint("DrawAllocation")
-    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-        super.onLayout(changed, left, top, right, bottom);
-
-        if (!changed || !mMediaPlayerValid) {
-            return;
-        }
-
-        int videoWidth = getVideoWidth();
-        int videoHeight = getVideoHeight();
-
-        if (videoWidth == 0 || videoHeight == 0) {
-            return;
-        }
-
-        Size viewSize = new Size(getWidth(), getHeight());
-        Size videoSize = new Size(videoWidth, videoHeight);
-        ScaleManager scaleManager = new ScaleManager(viewSize, videoSize);
-        Matrix matrix = scaleManager.getScaleMatrix(mScalableType);
-        if (matrix != null) {
-            setTransform(matrix);
-        }
-    }
-
-    private void initializeMediaPlayerIfNeeded() {
-        if (mMediaPlayer == null) {
-            mMediaPlayerValid = false;
-            mMediaPlayer = new MediaPlayer();
-            mMediaPlayer.setOnVideoSizeChangedListener(this);
-            mMediaPlayer.setOnErrorListener(this);
-            mMediaPlayer.setOnPreparedListener(this);
-            mMediaPlayer.setOnBufferingUpdateListener(this);
-            mMediaPlayer.setOnSeekCompleteListener(this);
-            mMediaPlayer.setOnCompletionListener(this);
-            mMediaPlayer.setOnInfoListener(this);
-            if (Build.VERSION.SDK_INT >= 23) {
-                mMediaPlayer.setOnTimedMetaDataAvailableListener(new TimedMetaDataAvailableListener());
-            }
-        }
-    }
-
-    private void initializeMediaControllerIfNeeded() {
-        if (mediaController == null) {
-            mediaController = new MediaController(this.getContext());
-        }
-    }
-
-    public void cleanupMediaPlayerResources() {
-        if ( mediaController != null ) {
-            mediaController.hide();
-        }
-        if ( mMediaPlayer != null ) {
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-                mMediaPlayer.setOnTimedMetaDataAvailableListener(null);
-            }
-            mMediaPlayerValid = false;
-            release();
-        }
-        if (mIsFullscreen) {
-            setFullscreen(false);
-        }
-        if (mThemedReactContext != null) {
-            mThemedReactContext.removeLifecycleEventListener(this);
-            mThemedReactContext = null;
-        }
-    }
-
-    public void setSrc(final String uriString, final String type, final boolean isNetwork, final boolean isAsset, final ReadableMap requestHeaders) {
-        setSrc(uriString, type, isNetwork, isAsset, requestHeaders, 0, 0);
-    }
-
-    public void setSrc(final String uriString, final String type, final boolean isNetwork, final boolean isAsset, final ReadableMap requestHeaders, final int expansionMainVersion, final int expansionPatchVersion) {
-
-        mSrcUriString = uriString;
-        mSrcType = type;
-        mSrcIsNetwork = isNetwork;
-        mSrcIsAsset = isAsset;
-        mRequestHeaders = requestHeaders;
-        mMainVer = expansionMainVersion;
-        mPatchVer = expansionPatchVersion;
-
-
-        mMediaPlayerValid = false;
-        mVideoDuration = 0;
-        mVideoBufferedDuration = 0;
-
-        initializeMediaPlayerIfNeeded();
-        mMediaPlayer.reset();
-
-        try {
-            if (isNetwork) {
-                // Use the shared CookieManager to access the cookies
-                // set by WebViews inside the same app
-                CookieManager cookieManager = CookieManager.getInstance();
-
-                Uri parsedUrl = Uri.parse(uriString);
-                Uri.Builder builtUrl = parsedUrl.buildUpon();
-
-                String cookie = cookieManager.getCookie(builtUrl.build().toString());
-
-                Map<String, String> headers = new HashMap<String, String>();
-
-                if (cookie != null) {
-                    headers.put("Cookie", cookie);
-                }
-
-                if (mRequestHeaders != null) {
-                    headers.putAll(toStringMap(mRequestHeaders));
-                }
-
-                /* According to https://github.com/react-native-community/react-native-video/pull/537
-                 *   there is an issue with this where it can cause a IOException.
-                 * TODO: diagnose this exception and fix it
-                 */
-                setDataSource(mThemedReactContext, parsedUrl, headers);
-            } else if (isAsset) {
-                if (uriString.startsWith("content://")) {
-                    Uri parsedUrl = Uri.parse(uriString);
-                    setDataSource(mThemedReactContext, parsedUrl);
-                } else {
-                    setDataSource(uriString);
-                }
-            } else {
-                ZipResourceFile expansionFile= null;
-                AssetFileDescriptor fd= null;
-                if(mMainVer>0) {
-                    try {
-                        expansionFile = APKExpansionSupport.getAPKExpansionZipFile(mThemedReactContext, mMainVer, mPatchVer);
-                        fd = expansionFile.getAssetFileDescriptor(uriString.replace(".mp4","") + ".mp4");
-                    } catch (IOException e) {
-                        e.printStackTrace();
-                    } catch (NullPointerException e) {
-                        e.printStackTrace();
-                    }
-                }
-                if(fd==null) {
-                    int identifier = mThemedReactContext.getResources().getIdentifier(
-                        uriString,
-                        "drawable",
-                        mThemedReactContext.getPackageName()
-                    );
-                    if (identifier == 0) {
-                        identifier = mThemedReactContext.getResources().getIdentifier(
-                            uriString,
-                            "raw",
-                            mThemedReactContext.getPackageName()
-                        );
-                    }
-                    setRawData(identifier);
-                }
-                else {
-                    setDataSource(fd.getFileDescriptor(), fd.getStartOffset(),fd.getLength());
-                }
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-            return;
-        }
-
-        WritableMap src = Arguments.createMap();
-
-        WritableMap wRequestHeaders = Arguments.createMap();
-        wRequestHeaders.merge(mRequestHeaders);
-
-        src.putString(ReactVideoViewManager.PROP_SRC_URI, uriString);
-        src.putString(ReactVideoViewManager.PROP_SRC_TYPE, type);
-        src.putMap(ReactVideoViewManager.PROP_SRC_HEADERS, wRequestHeaders);
-        src.putBoolean(ReactVideoViewManager.PROP_SRC_IS_NETWORK, isNetwork);
-        if(mMainVer>0) {
-            src.putInt(ReactVideoViewManager.PROP_SRC_MAINVER, mMainVer);
-            if(mPatchVer>0) {
-                src.putInt(ReactVideoViewManager.PROP_SRC_PATCHVER, mPatchVer);
-            }
-        }
-        WritableMap event = Arguments.createMap();
-        event.putMap(ReactVideoViewManager.PROP_SRC, src);
-        mEventEmitter.receiveEvent(getId(), Events.EVENT_LOAD_START.toString(), event);
-        isCompleted = false;
-
-        try {
-          prepareAsync(this);
-        } catch (Exception e) {
-          e.printStackTrace();
-        }
-    }
-
-    public void setResizeModeModifier(final ScalableType resizeMode) {
-        mResizeMode = resizeMode;
-
-        if (mMediaPlayerValid) {
-            setScalableType(resizeMode);
-            invalidate();
-        }
-    }
-
-    public void setRepeatModifier(final boolean repeat) {
-
-        mRepeat = repeat;
-
-        if (mMediaPlayerValid) {
-            setLooping(repeat);
-        }
-    }
-
-    public void setPausedModifier(final boolean paused) {
-        mPaused = paused;
-
-        if (!mMediaPlayerValid) {
-            return;
-        }
-
-        if (mPaused) {
-            if (mMediaPlayer.isPlaying()) {
-                pause();
-            }
-        } else {
-            if (!mMediaPlayer.isPlaying()) {
-                start();
-                // Setting the rate unpauses, so we have to wait for an unpause
-                if (mRate != mActiveRate) { 
-                    setRateModifier(mRate);
-                }
-
-                // Also Start the Progress Update Handler
-                mProgressUpdateHandler.post(mProgressUpdateRunnable);
-            }
-        }
-        setKeepScreenOn(!mPaused && mPreventsDisplaySleepDuringVideoPlayback);
-    }
-
-    // reduces the volume based on stereoPan
-    private float calulateRelativeVolume() {
-        float relativeVolume = (mVolume * (1 - Math.abs(mStereoPan)));
-        // only one decimal allowed
-        BigDecimal roundRelativeVolume = new BigDecimal(relativeVolume).setScale(1, BigDecimal.ROUND_HALF_UP);
-        return roundRelativeVolume.floatValue();
-    }
-
-    public void setPreventsDisplaySleepDuringVideoPlaybackModifier(final boolean preventsDisplaySleepDuringVideoPlayback) {
-        mPreventsDisplaySleepDuringVideoPlayback = preventsDisplaySleepDuringVideoPlayback;
-
-        if (!mMediaPlayerValid) {
-            return;
-        }
-
-        mMediaPlayer.setScreenOnWhilePlaying(mPreventsDisplaySleepDuringVideoPlayback);
-        setKeepScreenOn(mPreventsDisplaySleepDuringVideoPlayback);
-    }
-
-    public void setMutedModifier(final boolean muted) {
-        mMuted = muted;
-
-        if (!mMediaPlayerValid) {
-            return;
-        }
-
-        if (mMuted) {
-            setVolume(0, 0);
-        } else if (mStereoPan < 0) {
-            // louder on the left channel
-            setVolume(mVolume, calulateRelativeVolume());
-        } else if (mStereoPan > 0) {
-            // louder on the right channel
-            setVolume(calulateRelativeVolume(), mVolume);
-        } else {
-            // same volume on both channels
-            setVolume(mVolume, mVolume);
-        }
-    }
-
-    public void setVolumeModifier(final float volume) {
-        mVolume = volume;
-        setMutedModifier(mMuted);
-    }
-
-    public void setStereoPan(final float stereoPan) {
-        mStereoPan = stereoPan;
-        setMutedModifier(mMuted);
-    }
-
-    public void setProgressUpdateInterval(final float progressUpdateInterval) {
-        mProgressUpdateInterval = progressUpdateInterval;
-    }
-
-    public void setRateModifier(final float rate) {
-        mRate = rate;
-
-        if (mMediaPlayerValid) {
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-                if (!mPaused) { // Applying the rate while paused will cause the video to start
-                    /* Per https://stackoverflow.com/questions/39442522/setplaybackparams-causes-illegalstateexception
-                     * Some devices throw an IllegalStateException if you set the rate without first calling reset()
-                     * TODO: Call reset() then reinitialize the player
-                     */
-                    try {
-                        mMediaPlayer.setPlaybackParams(mMediaPlayer.getPlaybackParams().setSpeed(rate));
-                        mActiveRate = rate;
-                    } catch (Exception e) {
-                        Log.e(ReactVideoViewManager.REACT_CLASS, "Unable to set rate, unsupported on this device");
-                    }
-                }
-            } else {
-                Log.e(ReactVideoViewManager.REACT_CLASS, "Setting playback rate is not yet supported on Android versions below 6.0");
-            }
-        }
-    }
-
-    public void setFullscreen(boolean isFullscreen) {
-        if (isFullscreen == mIsFullscreen) {
-            return; // Avoid generating events when nothing is changing
-        }
-        mIsFullscreen = isFullscreen;
-
-        Activity activity = mThemedReactContext.getCurrentActivity();
-        if (activity == null) {
-            return;
-        }
-        Window window = activity.getWindow();
-        View decorView = window.getDecorView();
-        int uiOptions;
-        if (mIsFullscreen) {
-            if (Build.VERSION.SDK_INT >= 19) { // 4.4+
-                uiOptions = SYSTEM_UI_FLAG_HIDE_NAVIGATION
-                        | SYSTEM_UI_FLAG_IMMERSIVE_STICKY
-                        | SYSTEM_UI_FLAG_FULLSCREEN;
-            } else {
-                uiOptions = SYSTEM_UI_FLAG_HIDE_NAVIGATION
-                        | SYSTEM_UI_FLAG_FULLSCREEN;
-            }
-            mEventEmitter.receiveEvent(getId(), Events.EVENT_FULLSCREEN_WILL_PRESENT.toString(), null);
-            decorView.setSystemUiVisibility(uiOptions);
-            mEventEmitter.receiveEvent(getId(), Events.EVENT_FULLSCREEN_DID_PRESENT.toString(), null);
-        } else {
-            uiOptions = View.SYSTEM_UI_FLAG_VISIBLE;
-            mEventEmitter.receiveEvent(getId(), Events.EVENT_FULLSCREEN_WILL_DISMISS.toString(), null);
-            decorView.setSystemUiVisibility(uiOptions);
-            mEventEmitter.receiveEvent(getId(), Events.EVENT_FULLSCREEN_DID_DISMISS.toString(), null);
-        }
-    }
-
-    public void applyModifiers() {
-        setResizeModeModifier(mResizeMode);
-        setRepeatModifier(mRepeat);
-        setPausedModifier(mPaused);
-        setMutedModifier(mMuted);
-        setPreventsDisplaySleepDuringVideoPlaybackModifier(mPreventsDisplaySleepDuringVideoPlayback);
-        setProgressUpdateInterval(mProgressUpdateInterval);
-        setRateModifier(mRate);
-    }
-
-    public void setPlayInBackground(final boolean playInBackground) {
-
-        mPlayInBackground = playInBackground;
-    }
-
-    public void setControls(boolean controls) {
-        this.mUseNativeControls = controls;
-    }
-
-    @Override
-    public void onPrepared(MediaPlayer mp) {
-
-        mMediaPlayerValid = true;
-        mVideoDuration = mp.getDuration();
-
-        WritableMap naturalSize = Arguments.createMap();
-        naturalSize.putInt(EVENT_PROP_WIDTH, mp.getVideoWidth());
-        naturalSize.putInt(EVENT_PROP_HEIGHT, mp.getVideoHeight());
-        if (mp.getVideoWidth() > mp.getVideoHeight())
-            naturalSize.putString(EVENT_PROP_ORIENTATION, "landscape");
-        else
-            naturalSize.putString(EVENT_PROP_ORIENTATION, "portrait");
-
-        WritableMap event = Arguments.createMap();
-        event.putDouble(EVENT_PROP_DURATION, mVideoDuration / 1000.0);
-        event.putDouble(EVENT_PROP_CURRENT_TIME, mp.getCurrentPosition() / 1000.0);
-        event.putMap(EVENT_PROP_NATURALSIZE, naturalSize);
-        // TODO: Actually check if you can.
-        event.putBoolean(EVENT_PROP_FAST_FORWARD, true);
-        event.putBoolean(EVENT_PROP_SLOW_FORWARD, true);
-        event.putBoolean(EVENT_PROP_SLOW_REVERSE, true);
-        event.putBoolean(EVENT_PROP_REVERSE, true);
-        event.putBoolean(EVENT_PROP_FAST_FORWARD, true);
-        event.putBoolean(EVENT_PROP_STEP_BACKWARD, true);
-        event.putBoolean(EVENT_PROP_STEP_FORWARD, true);
-        mEventEmitter.receiveEvent(getId(), Events.EVENT_LOAD.toString(), event);
-
-        applyModifiers();
-
-        if (mUseNativeControls) {
-            initializeMediaControllerIfNeeded();
-            mediaController.setMediaPlayer(this);
-            mediaController.setAnchorView(this);
-
-            videoControlHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    mediaController.setEnabled(true);
-                    mediaController.show();
-                }
-            });
-        }
-
-        selectTimedMetadataTrack(mp);
-    }
-
-    @Override
-    public boolean onError(MediaPlayer mp, int what, int extra) {
-
-        WritableMap error = Arguments.createMap();
-        error.putInt(EVENT_PROP_WHAT, what);
-        error.putInt(EVENT_PROP_EXTRA, extra);
-        WritableMap event = Arguments.createMap();
-        event.putMap(EVENT_PROP_ERROR, error);
-        mEventEmitter.receiveEvent(getId(), Events.EVENT_ERROR.toString(), event);
-        return true;
-    }
-
-    @Override
-    public boolean onInfo(MediaPlayer mp, int what, int extra) {
-        switch (what) {
-            case MediaPlayer.MEDIA_INFO_BUFFERING_START:
-                mEventEmitter.receiveEvent(getId(), Events.EVENT_STALLED.toString(), Arguments.createMap());
-                break;
-            case MediaPlayer.MEDIA_INFO_BUFFERING_END:
-                mEventEmitter.receiveEvent(getId(), Events.EVENT_RESUME.toString(), Arguments.createMap());
-                break;
-            case MediaPlayer.MEDIA_INFO_VIDEO_RENDERING_START:
-                mEventEmitter.receiveEvent(getId(), Events.EVENT_READY_FOR_DISPLAY.toString(), Arguments.createMap());
-                break;
-
-            default:
-        }
-        return false;
-    }
-
-    @Override
-    public void onBufferingUpdate(MediaPlayer mp, int percent) {
-        selectTimedMetadataTrack(mp);
-        mVideoBufferedDuration = (int) Math.round((double) (mVideoDuration * percent) / 100.0);
-    }
-
-    public void onSeekComplete(MediaPlayer mp) {
-        WritableMap event = Arguments.createMap();
-        event.putDouble(EVENT_PROP_CURRENT_TIME, getCurrentPosition() / 1000.0);
-        event.putDouble(EVENT_PROP_SEEK_TIME, mSeekTime / 1000.0);
-        mEventEmitter.receiveEvent(getId(), Events.EVENT_SEEK.toString(), event);
-        mSeekTime = 0;
-    }
-
-    @Override
-    public void seekTo(int msec) {
-        if (mMediaPlayerValid) {
-            mSeekTime = msec;
-            super.seekTo(msec);
-            if (isCompleted && mVideoDuration != 0 && msec < mVideoDuration) {
-                isCompleted = false;
-            }
-        }
-    }
-
-    @Override
-    public int getBufferPercentage() {
-        return 0;
-    }
-
-    @Override
-    public boolean canPause() {
-        return true;
-    }
-
-    @Override
-    public boolean canSeekBackward() {
-        return true;
-    }
-
-    @Override
-    public boolean canSeekForward() {
-        return true;
-    }
-
-    @Override
-    public int getAudioSessionId() {
-        return 0;
-    }
-
-    @Override
-    public void onCompletion(MediaPlayer mp) {
-        isCompleted = true;
-        mEventEmitter.receiveEvent(getId(), Events.EVENT_END.toString(), null);
-        if (!mRepeat) {
-            setKeepScreenOn(false);
-        }
-    }
-        
-    // This is not fully tested and does not work for all forms of timed metadata
-    @TargetApi(23) // 6.0
-    public class TimedMetaDataAvailableListener
-            implements MediaPlayer.OnTimedMetaDataAvailableListener
-    {
-        public void onTimedMetaDataAvailable(MediaPlayer mp, TimedMetaData data) {
-            WritableMap event = Arguments.createMap();
-
-            try {
-                String rawMeta  = new String(data.getMetaData(), "UTF-8");
-                WritableMap id3 = Arguments.createMap();
-
-                id3.putString(EVENT_PROP_METADATA_VALUE, rawMeta.substring(rawMeta.lastIndexOf("\u0003") + 1));
-                id3.putString(EVENT_PROP_METADATA_IDENTIFIER, "id3/TDEN");
-
-                WritableArray metadata = new WritableNativeArray();
-
-                metadata.pushMap(id3);
-
-                event.putArray(EVENT_PROP_METADATA, metadata);
-                event.putDouble(EVENT_PROP_TARGET, getId());
-            } catch (UnsupportedEncodingException e) {
-                e.printStackTrace();
-            }
-
-            mEventEmitter.receiveEvent(getId(), Events.EVENT_TIMED_METADATA.toString(), event);
-        }
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        mMediaPlayerValid = false;
-        super.onDetachedFromWindow();
-        setKeepScreenOn(false);
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-
-        if(mMainVer>0) {
-            setSrc(mSrcUriString, mSrcType, mSrcIsNetwork, mSrcIsAsset, mRequestHeaders, mMainVer, mPatchVer);
-        }
-        else {
-            setSrc(mSrcUriString, mSrcType, mSrcIsNetwork, mSrcIsAsset, mRequestHeaders);
-        }
-        setKeepScreenOn(mPreventsDisplaySleepDuringVideoPlayback);
-    }
-
-    @Override
-    public void onHostPause() {
-        if (mMediaPlayerValid && !mPaused && !mPlayInBackground) {
-            /* Pause the video in background
-             * Don't update the paused prop, developers should be able to update it on background
-             *  so that when you return to the app the video is paused
-             */
-            mBackgroundPaused = true;
-            mMediaPlayer.pause();
-        }
-    }
-
-    @Override
-    public void onHostResume() {
-        mBackgroundPaused = false;
-        if (mMediaPlayerValid && !mPlayInBackground && !mPaused) {
-            new Handler().post(new Runnable() {
-                @Override
-                public void run() {
-                    // Restore original state
-                    setPausedModifier(false);
-                }
-            });
-        }
-    }
-
-    @Override
-    public void onHostDestroy() {
-    }
-
-    /**
-     * toStringMap converts a {@link ReadableMap} into a HashMap.
-     *
-     * @param readableMap The ReadableMap to be conveted.
-     * @return A HashMap containing the data that was in the ReadableMap.
-     * @see 'Adapted from https://github.com/artemyarulin/react-native-eval/blob/master/android/src/main/java/com/evaluator/react/ConversionUtil.java'
-     */
-    public static Map<String, String> toStringMap(@Nullable ReadableMap readableMap) {
-        Map<String, String> result = new HashMap<>();
-        if (readableMap == null)
-            return result;
-
-        com.facebook.react.bridge.ReadableMapKeySetIterator iterator = readableMap.keySetIterator();
-        while (iterator.hasNextKey()) {
-            String key = iterator.nextKey();
-            result.put(key, readableMap.getString(key));
-        }
-
-        return result;
-    }
-        
-    // Select track (so we can use it to listen to timed meta data updates)
-    private void selectTimedMetadataTrack(MediaPlayer mp) {
-        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
-            return;
-        }
-        try { // It's possible this could throw an exception if the framework doesn't support getting track info
-            MediaPlayer.TrackInfo[] trackInfo = mp.getTrackInfo();
-            for (int i = 0; i < trackInfo.length; ++i) {
-                if (trackInfo[i].getTrackType() == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_TIMEDTEXT) {
-                    mp.selectTrack(i);
-                    break;
-                }
-            }
-        } catch (Exception e) {}
-    }
-}
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/ReactVideoViewManager.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/ReactVideoViewManager.java
deleted file mode 100644
index 59efab4..0000000
--- a/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/ReactVideoViewManager.java
+++ /dev/null
@@ -1,172 +0,0 @@
-package com.brentvatne.react;
-
-import com.brentvatne.react.ReactVideoView.Events;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.ReadableMap;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.common.MapBuilder;
-import com.facebook.react.uimanager.annotations.ReactProp;
-import com.facebook.react.uimanager.SimpleViewManager;
-import com.facebook.react.uimanager.ThemedReactContext;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-import com.yqritc.scalablevideoview.ScalableType;
-
-import javax.annotation.Nullable;
-import java.util.Map;
-
-public class ReactVideoViewManager extends SimpleViewManager<ReactVideoView> {
-
-    public static final String REACT_CLASS = "RCTVideo";
-
-    public static final String PROP_SRC = "src";
-    public static final String PROP_SRC_URI = "uri";
-    public static final String PROP_SRC_TYPE = "type";
-    public static final String PROP_SRC_HEADERS = "requestHeaders";
-    public static final String PROP_SRC_IS_NETWORK = "isNetwork";
-    public static final String PROP_SRC_MAINVER = "mainVer";
-    public static final String PROP_SRC_PATCHVER = "patchVer";
-    public static final String PROP_SRC_IS_ASSET = "isAsset";
-    public static final String PROP_RESIZE_MODE = "resizeMode";
-    public static final String PROP_REPEAT = "repeat";
-    public static final String PROP_PAUSED = "paused";
-    public static final String PROP_MUTED = "muted";
-    public static final String PROP_PREVENTS_DISPLAY_SLEEP_DURING_VIDEO_PLAYBACK = "preventsDisplaySleepDuringVideoPlayback";
-    public static final String PROP_VOLUME = "volume";
-    public static final String PROP_STEREO_PAN = "stereoPan";
-    public static final String PROP_PROGRESS_UPDATE_INTERVAL = "progressUpdateInterval";
-    public static final String PROP_SEEK = "seek";
-    public static final String PROP_RATE = "rate";
-    public static final String PROP_FULLSCREEN = "fullscreen";
-    public static final String PROP_PLAY_IN_BACKGROUND = "playInBackground";
-    public static final String PROP_CONTROLS = "controls";
-
-    @Override
-    public String getName() {
-        return REACT_CLASS;
-    }
-
-    @Override
-    protected ReactVideoView createViewInstance(ThemedReactContext themedReactContext) {
-        return new ReactVideoView(themedReactContext);
-    }
-
-    @Override
-    public void onDropViewInstance(ReactVideoView view) {
-        super.onDropViewInstance(view);
-        view.cleanupMediaPlayerResources();
-    }
-
-    @Override
-    @Nullable
-    public Map getExportedCustomDirectEventTypeConstants() {
-        MapBuilder.Builder builder = MapBuilder.builder();
-        for (Events event : Events.values()) {
-            builder.put(event.toString(), MapBuilder.of("registrationName", event.toString()));
-        }
-        return builder.build();
-    }
-
-    @Override
-    @Nullable
-    public Map getExportedViewConstants() {
-        return MapBuilder.of(
-                "ScaleNone", Integer.toString(ScalableType.LEFT_TOP.ordinal()),
-                "ScaleToFill", Integer.toString(ScalableType.FIT_XY.ordinal()),
-                "ScaleAspectFit", Integer.toString(ScalableType.FIT_CENTER.ordinal()),
-                "ScaleAspectFill", Integer.toString(ScalableType.CENTER_CROP.ordinal())
-        );
-    }
-
-    @ReactProp(name = PROP_SRC)
-    public void setSrc(final ReactVideoView videoView, @Nullable ReadableMap src) {
-        int mainVer = src.getInt(PROP_SRC_MAINVER);
-        int patchVer = src.getInt(PROP_SRC_PATCHVER);
-        if(mainVer<0) { mainVer = 0; }
-        if(patchVer<0) { patchVer = 0; }
-        if(mainVer>0) {
-            videoView.setSrc(
-                    src.getString(PROP_SRC_URI),
-                    src.getString(PROP_SRC_TYPE),
-                    src.getBoolean(PROP_SRC_IS_NETWORK),
-                    src.getBoolean(PROP_SRC_IS_ASSET),
-                    src.getMap(PROP_SRC_HEADERS),
-                    mainVer,
-                    patchVer
-            );
-        }
-        else {
-            videoView.setSrc(
-                    src.getString(PROP_SRC_URI),
-                    src.getString(PROP_SRC_TYPE),
-                    src.getBoolean(PROP_SRC_IS_NETWORK),
-                    src.getBoolean(PROP_SRC_IS_ASSET),
-                    src.getMap(PROP_SRC_HEADERS)
-                    );
-        }
-    }
-
-    @ReactProp(name = PROP_PREVENTS_DISPLAY_SLEEP_DURING_VIDEO_PLAYBACK)
-    public void setPropPreventsDisplaySleepDuringVideoPlayback(final ReactVideoView videoView, final boolean doPreventSleep) {
-        videoView.setPreventsDisplaySleepDuringVideoPlaybackModifier(doPreventSleep);
-    }
-
-    @ReactProp(name = PROP_RESIZE_MODE)
-    public void setResizeMode(final ReactVideoView videoView, final String resizeModeOrdinalString) {
-        videoView.setResizeModeModifier(ScalableType.values()[Integer.parseInt(resizeModeOrdinalString)]);
-    }
-
-    @ReactProp(name = PROP_REPEAT, defaultBoolean = false)
-    public void setRepeat(final ReactVideoView videoView, final boolean repeat) {
-        videoView.setRepeatModifier(repeat);
-    }
-
-    @ReactProp(name = PROP_PAUSED, defaultBoolean = false)
-    public void setPaused(final ReactVideoView videoView, final boolean paused) {
-        videoView.setPausedModifier(paused);
-    }
-
-    @ReactProp(name = PROP_MUTED, defaultBoolean = false)
-    public void setMuted(final ReactVideoView videoView, final boolean muted) {
-        videoView.setMutedModifier(muted);
-    }
-
-    @ReactProp(name = PROP_VOLUME, defaultFloat = 1.0f)
-    public void setVolume(final ReactVideoView videoView, final float volume) {
-        videoView.setVolumeModifier(volume);
-    }
-
-    @ReactProp(name = PROP_STEREO_PAN)
-    public void setStereoPan(final ReactVideoView videoView, final float stereoPan) {
-        videoView.setStereoPan(stereoPan);
-    }
-
-    @ReactProp(name = PROP_PROGRESS_UPDATE_INTERVAL, defaultFloat = 250.0f)
-    public void setProgressUpdateInterval(final ReactVideoView videoView, final float progressUpdateInterval) {
-        videoView.setProgressUpdateInterval(progressUpdateInterval);
-    }
-
-    @ReactProp(name = PROP_SEEK)
-    public void setSeek(final ReactVideoView videoView, final float seek) {
-        videoView.seekTo(Math.round(seek * 1000.0f));
-    }
-
-    @ReactProp(name = PROP_RATE)
-    public void setRate(final ReactVideoView videoView, final float rate) {
-        videoView.setRateModifier(rate);
-    }
-
-    @ReactProp(name = PROP_FULLSCREEN, defaultBoolean = false)
-    public void setFullscreen(final ReactVideoView videoView, final boolean fullscreen) {
-        videoView.setFullscreen(fullscreen);
-    }
-
-    @ReactProp(name = PROP_PLAY_IN_BACKGROUND, defaultBoolean = false)
-    public void setPlayInBackground(final ReactVideoView videoView, final boolean playInBackground) {
-        videoView.setPlayInBackground(playInBackground);
-    }
-
-    @ReactProp(name = PROP_CONTROLS, defaultBoolean = false)
-    public void setControls(final ReactVideoView videoView, final boolean controls) {
-        videoView.setControls(controls);
-    }
-}
diff --git a/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/VideoDecoderPropertiesModule.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/VideoDecoderPropertiesModule.java
new file mode 100644
index 0000000..6622e7f
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/brentvatne/react/VideoDecoderPropertiesModule.java
@@ -0,0 +1,107 @@
+package com.brentvatne.react;
+
+import android.annotation.SuppressLint;
+import android.media.MediaCodecList;
+import android.media.MediaDrm;
+import android.media.MediaFormat;
+import android.media.UnsupportedSchemeException;
+import android.os.Build;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.RequiresApi;
+
+import com.facebook.react.bridge.Promise;
+import com.facebook.react.bridge.ReactApplicationContext;
+import com.facebook.react.bridge.ReactContextBaseJavaModule;
+import com.facebook.react.bridge.ReactMethod;
+
+import java.util.UUID;
+
+@RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
+public class VideoDecoderPropertiesModule extends ReactContextBaseJavaModule {
+
+    ReactApplicationContext reactContext;
+
+    @NonNull
+    @Override
+    public String getName() {
+        return "VideoDecoderProperties";
+    }
+
+    @SuppressLint("ObsoleteSdkInt")
+    @ReactMethod
+    public void getWidevineLevel(Promise p) {
+        int widevineLevel = 0;
+
+        if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            p.resolve(widevineLevel);
+            return;
+        }
+        final UUID WIDEVINE_UUID = new UUID(0xEDEF8BA979D64ACEL, 0xA3C827DCD51D21EDL);
+        final String WIDEVINE_SECURITY_LEVEL_1 = "L1";
+        final String WIDEVINE_SECURITY_LEVEL_2 = "L2";
+        final String WIDEVINE_SECURITY_LEVEL_3 = "L3";
+        final String SECURITY_LEVEL_PROPERTY = "securityLevel";
+
+        String securityProperty = null;
+        try {
+            MediaDrm mediaDrm = new MediaDrm(WIDEVINE_UUID);
+            securityProperty = mediaDrm.getPropertyString(SECURITY_LEVEL_PROPERTY);
+        } catch (UnsupportedSchemeException e) {
+            e.printStackTrace();
+        }
+        if (securityProperty == null) {
+            p.resolve(widevineLevel);
+            return;
+        }
+
+        switch (securityProperty) {
+            case WIDEVINE_SECURITY_LEVEL_1: {
+                widevineLevel = 1;
+                break;
+            }
+            case WIDEVINE_SECURITY_LEVEL_2: {
+                widevineLevel = 2;
+                break;
+            }
+            case WIDEVINE_SECURITY_LEVEL_3: {
+                widevineLevel = 3;
+                break;
+            }
+            default: {
+                // widevineLevel 0
+                break;
+            }
+        }
+        p.resolve(widevineLevel);
+    }
+
+    @SuppressLint("ObsoleteSdkInt")
+    @ReactMethod
+    public void isCodecSupported(String mimeType, int width, int height, Promise p) {
+        if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.LOLLIPOP) {
+            p.resolve(false);
+            return;
+        }
+        MediaCodecList mRegularCodecs = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
+        MediaFormat format = MediaFormat.createVideoFormat(mimeType, width, height);
+        String codecName = mRegularCodecs.findDecoderForFormat(format);
+        if (codecName == null) {
+            p.resolve(false);
+        } else {
+            p.resolve(true);
+        }
+    }
+
+
+    @ReactMethod
+    public void isHEVCSupported(Promise p) {
+        isCodecSupported("video/hevc", 1920, 1080, p);
+    }
+
+    public VideoDecoderPropertiesModule(ReactApplicationContext reactContext) {
+        super(reactContext);
+        this.reactContext = reactContext;
+    }
+
+}
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/receiver/AudioBecomingNoisyReceiver.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/receiver/AudioBecomingNoisyReceiver.java
similarity index 100%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/receiver/AudioBecomingNoisyReceiver.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/receiver/AudioBecomingNoisyReceiver.java
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/receiver/BecomingNoisyListener.java b/node_modules/react-native-video/android/src/main/java/com/brentvatne/receiver/BecomingNoisyListener.java
similarity index 100%
rename from node_modules/react-native-video/android-exoplayer/src/main/java/com/brentvatne/receiver/BecomingNoisyListener.java
rename to node_modules/react-native-video/android/src/main/java/com/brentvatne/receiver/BecomingNoisyListener.java
diff --git a/node_modules/react-native-video/android/src/main/java/com/google/ads/interactivemedia/v3/api/AdEvent.java b/node_modules/react-native-video/android/src/main/java/com/google/ads/interactivemedia/v3/api/AdEvent.java
new file mode 100644
index 0000000..1913df2
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/google/ads/interactivemedia/v3/api/AdEvent.java
@@ -0,0 +1,11 @@
+package com.google.ads.interactivemedia.v3.api;
+
+import androidx.annotation.InspectableProperty;
+
+public abstract class AdEvent {
+    public abstract InspectableProperty getType();
+
+    public interface AdEventListener {
+        public void onAdEvent(AdEvent adEvent);
+    }
+}
diff --git a/node_modules/react-native-video/android/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java b/node_modules/react-native-video/android/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
new file mode 100644
index 0000000..d23e7dd
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/java/com/google/android/exoplayer2/ext/ima/ImaAdsLoader.java
@@ -0,0 +1,65 @@
+package com.google.android.exoplayer2.ext.ima;
+
+import androidx.annotation.Nullable;
+
+import com.facebook.react.uimanager.ThemedReactContext;
+import com.google.android.exoplayer2.ExoPlayer;
+import com.google.android.exoplayer2.Player;
+import com.google.android.exoplayer2.source.ads.AdsLoader;
+import com.google.android.exoplayer2.source.ads.AdsMediaSource;
+import com.google.android.exoplayer2.ui.AdViewProvider;
+import com.google.android.exoplayer2.upstream.DataSpec;
+
+import java.io.IOException;
+
+public class ImaAdsLoader implements AdsLoader {
+    public void setPlayer(ExoPlayer player) {
+    }
+
+    @Override
+    public void setPlayer(@Nullable Player player) {
+
+    }
+
+    public void release() {
+    }
+
+    @Override
+    public void setSupportedContentTypes(int... ints) {
+
+    }
+
+    @Override
+    public void start(AdsMediaSource adsMediaSource, DataSpec dataSpec, Object o, AdViewProvider adViewProvider, EventListener eventListener) {
+
+    }
+
+    @Override
+    public void stop(AdsMediaSource adsMediaSource, EventListener eventListener) {
+
+    }
+
+    @Override
+    public void handlePrepareComplete(AdsMediaSource adsMediaSource, int i, int i1) {
+
+    }
+
+    @Override
+    public void handlePrepareError(AdsMediaSource adsMediaSource, int i, int i1, IOException e) {
+
+    }
+
+    public static class Builder {
+        public Builder(ThemedReactContext themedReactContext) {
+            
+        }
+
+        public Builder setAdEventListener(Object reactExoplayerView) {
+            return this;
+        }
+
+        public ImaAdsLoader build() {
+            return null;
+        }
+    }
+}
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/res/layout/exo_player_control_view.xml b/node_modules/react-native-video/android/src/main/res/layout/exo_player_control_view.xml
similarity index 75%
rename from node_modules/react-native-video/android-exoplayer/src/main/res/layout/exo_player_control_view.xml
rename to node_modules/react-native-video/android/src/main/res/layout/exo_player_control_view.xml
index becee6a..27d3883 100644
--- a/node_modules/react-native-video/android-exoplayer/src/main/res/layout/exo_player_control_view.xml
+++ b/node_modules/react-native-video/android/src/main/res/layout/exo_player_control_view.xml
@@ -14,27 +14,27 @@
         android:paddingTop="4dp"
         android:orientation="horizontal">
 
-        <ImageButton android:id="@id/exo_prev"
+        <ImageButton android:id="@+id/exo_prev"
             style="@style/ExoMediaButton.Previous"/>
 
-        <ImageButton android:id="@id/exo_rew"
+        <ImageButton android:id="@+id/exo_rew"
             style="@style/ExoMediaButton.Rewind"/>
         <FrameLayout
             android:id="@+id/exo_play_pause_container"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
             android:layout_gravity="center">
-            <ImageButton android:id="@id/exo_play"
+            <ImageButton android:id="@+id/exo_play"
                 style="@style/ExoMediaButton.Play"/>
 
-            <ImageButton android:id="@id/exo_pause"
+            <ImageButton android:id="@+id/exo_pause"
                 style="@style/ExoMediaButton.Pause"/>
         </FrameLayout>
 
-        <ImageButton android:id="@id/exo_ffwd"
+        <ImageButton android:id="@+id/exo_ffwd"
             style="@style/ExoMediaButton.FastForward"/>
 
-        <ImageButton android:id="@id/exo_next"
+        <ImageButton android:id="@+id/exo_next"
             style="@style/ExoMediaButton.Next"/>
 
     </LinearLayout>
@@ -46,7 +46,7 @@
         android:gravity="center_vertical"
         android:orientation="horizontal">
 
-        <TextView android:id="@id/exo_position"
+        <TextView android:id="@+id/exo_position"
             android:layout_width="50dp"
             android:layout_height="wrap_content"
             android:textSize="14sp"
@@ -57,12 +57,12 @@
             android:textColor="#FFBEBEBE"/>
 
         <com.google.android.exoplayer2.ui.DefaultTimeBar
-            android:id="@id/exo_progress"
+            android:id="@+id/exo_progress"
             android:layout_width="0dp"
             android:layout_weight="1"
             android:layout_height="26dp"/>
 
-        <TextView android:id="@id/exo_duration"
+        <TextView android:id="@+id/exo_duration"
             android:layout_width="50dp"
             android:layout_height="wrap_content"
             android:textSize="14sp"
@@ -71,6 +71,14 @@
             android:paddingRight="4dp"
             android:includeFontPadding="false"
             android:textColor="#FFBEBEBE"/>
+
+        <ImageButton
+            android:id="@+id/exo_fullscreen"
+            style="@style/ExoMediaButton.FullScreen"
+            android:layout_width="30dp"
+            android:layout_height="30dp"
+            android:layout_margin="4dp"
+            android:scaleType="fitCenter" />
     </LinearLayout>
 
 </LinearLayout>
diff --git a/node_modules/react-native-video/android-exoplayer/src/main/res/values/strings.xml b/node_modules/react-native-video/android/src/main/res/values/strings.xml
similarity index 100%
rename from node_modules/react-native-video/android-exoplayer/src/main/res/values/strings.xml
rename to node_modules/react-native-video/android/src/main/res/values/strings.xml
diff --git a/node_modules/react-native-video/android/src/main/res/values/styles.xml b/node_modules/react-native-video/android/src/main/res/values/styles.xml
new file mode 100644
index 0000000..3459d9d
--- /dev/null
+++ b/node_modules/react-native-video/android/src/main/res/values/styles.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <style name="ExoMediaButton.FullScreen">
+        <item name="android:src">@drawable/exo_icon_fullscreen_enter</item>
+        <item name="android:contentDescription">@string/exo_controls_fullscreen_enter_description</item>
+    </style>
+</resources>
\ No newline at end of file
diff --git a/node_modules/react-native-video/docs/AppTransportSecuritySetting.png b/node_modules/react-native-video/docs/AppTransportSecuritySetting.png
new file mode 100644
index 0000000..b57be9a
Binary files /dev/null and b/node_modules/react-native-video/docs/AppTransportSecuritySetting.png differ
diff --git a/node_modules/react-native-video/docs/DEBUGGING.md b/node_modules/react-native-video/docs/DEBUGGING.md
new file mode 100644
index 0000000..4ad9fda
--- /dev/null
+++ b/node_modules/react-native-video/docs/DEBUGGING.md
@@ -0,0 +1,47 @@
+# Advanced debuging and common issues
+
+### HTTP playback doesn't work or  Black Screen on Release build (Android)
+If your video work on Debug mode, but on Release you see only black screen, please, check the link to your video. If you use 'http' protocol there, you will need to add next string to your AndroidManifest.xml file. [Details here](https://developer.android.com/guide/topics/manifest/application-element#usesCleartextTraffic)
+
+```
+<application
+ ...
+ android:usesCleartextTraffic="true"
+>
+```
+
+### Decoder Issue (Android)
+
+Devices have a maximum of simulataneous possible playback. It means you have reach this limit. Exoplayer returns: 'Unable to instantiate decoder'
+
+**known issue**: This issue happen really often in debug mode.
+
+## You cannot play clean content (all OS)
+
+Here are the steps to consider before opening a ticket in issue tracker
+
+### Check you can access to remote file
+
+Ensure you can download to manifest / content file with a browser for exemple
+
+### Check another player can read the content
+
+Usually clear playback can be read with all Video player. Then you should ensure content can be played without any issue with another player ([VideoLan/VLC](https://www.videolan.org/vlc/) is a good reference implementation)
+
+## You cannot play protected content (all OS)
+
+### Protected content gives error (token error / access forbidden) 
+
+If content is protected with an access token or any other http header, ensure you can access to you data with a wget call or a rest client app. You need to provide all needed access token / authentication parameters.
+
+### Everything seems correct but content cannot be accessed
+
+You need to record network trace to ensure communications with server is correct.
+[Charles proxy](https://www.charlesproxy.com/) is a simple and usefull tool to sniff all http/https calls. 
+With this tool you should be able to analyze what is going on with network. You will see all access to content and DRM, audio / vido chuncks, ...
+
+Then try to compare exchanges with previous tests you made.
+
+### It's still not working
+
+You can try to open a ticket now !
diff --git a/node_modules/react-native-video/docs/DRM.md b/node_modules/react-native-video/docs/DRM.md
new file mode 100644
index 0000000..d0ce88b
--- /dev/null
+++ b/node_modules/react-native-video/docs/DRM.md
@@ -0,0 +1,139 @@
+# DRM
+
+## Provide DRM data (only tested with http/https assets)
+
+You can provide some configuration to allow DRM playback.
+This feature will disable the use of `TextureView` on Android.
+
+DRM object allows this members:
+
+| Property | Type | Default | Platform | Description |
+| --- | --- | --- | --- | --- |
+| [`type`](#type) | DRMType | undefined | iOS/Android | Specifies which type of DRM you are going to use, DRMType is an enum exposed on the JS module ('fairplay', 'playready', ...) |
+| [`licenseServer`](#licenseserver) | string | undefined | iOS/Android | Specifies the license server URL |
+| [`headers`](#headers) | Object | undefined | iOS/Android | Specifies the headers send to the license server URL on license acquisition |
+| [`contentId`](#contentid) | string | undefined | iOS | Specify the content id of the stream, otherwise it will take the host value from `loadingRequest.request.URL.host` (f.e: `skd://testAsset` -> will take `testAsset`) |
+| [`certificateUrl`](#certificateurl) | string | undefined | iOS | Specifies the url to obtain your ios certificate for fairplay, Url to the .cer file |
+| [`base64Certificate`](#base64certificate) | bool | false | iOS | Specifies whether or not the certificate returned by the `certificateUrl` is on base64 |
+| [`getLicense`](#getlicense)| function | undefined | iOS | Rather than setting the `licenseServer` url to get the license, you can manually get the license on the JS part, and send the result to the native part to configure FairplayDRM for the stream |
+
+### `base64Certificate`
+
+Whether or not the certificate url returns it on base64.
+
+Platforms: iOS
+
+### `certificateUrl`
+
+URL to fetch a valid certificate for FairPlay.
+
+Platforms: iOS
+
+### `getLicense`
+
+`licenseServer` and `headers` will be ignored. You will obtain as argument the `SPC` (as ASCII string, you will probably need to convert it to base 64) obtained from your `contentId` + the provided certificate via `[loadingRequest streamingContentKeyRequestDataForApp:certificateData contentIdentifier:contentIdData options:nil error:&spcError];`.
+  You should return on this method a `CKC` in Base64, either by just returning it or returning a `Promise` that resolves with the `CKC`.
+
+With this prop you can override the license acquisition flow, as an example:
+
+```js
+getLicense: (spcString) => {
+  const base64spc = Base64.encode(spcString);
+  const formData = new FormData();
+  formData.append('spc', base64spc);
+  return fetch(`https://license.pallycon.com/ri/licenseManager.do`, {
+      method: 'POST',
+      headers: {
+          'pallycon-customdata-v2': 'd2VpcmRiYXNlNjRzdHJpbmcgOlAgRGFuaWVsIE1hcmnxbyB3YXMgaGVyZQ==',
+          'Content-Type': 'application/x-www-form-urlencoded',
+      },
+      body: formData
+  }).then(response => response.text()).then((response) => {
+      return response;
+  }).catch((error) => {
+      console.error('Error', error);
+  });
+}
+```
+
+Platforms: iOS
+
+### `headers`
+
+You can customize headers send to the licenseServer.
+
+Example:
+
+```js
+source={{
+    uri: 'https://media.axprod.net/TestVectors/v7-MultiDRM-SingleKey/Manifest_1080p.mpd',
+}}
+drm={{
+      type: DRMType.WIDEVINE,
+      licenseServer: 'https://drm-widevine-licensing.axtest.net/AcquireLicense',
+      headers: {
+          'X-AxDRM-Message': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ2ZXJzaW9uIjoxLCJjb21fa2V5X2lkIjoiYjMzNjRlYjUtNTFmNi00YWUzLThjOTgtMzNjZWQ1ZTMxYzc4IiwibWVzc2FnZSI6eyJ0eXBlIjoiZW50aXRsZW1lbnRfbWVzc2FnZSIsImZpcnN0X3BsYXlfZXhwaXJhdGlvbiI6NjAsInBsYXlyZWFkeSI6eyJyZWFsX3RpbWVfZXhwaXJhdGlvbiI6dHJ1ZX0sImtleXMiOlt7ImlkIjoiOWViNDA1MGQtZTQ0Yi00ODAyLTkzMmUtMjdkNzUwODNlMjY2IiwiZW5jcnlwdGVkX2tleSI6ImxLM09qSExZVzI0Y3Iya3RSNzRmbnc9PSJ9XX19.FAbIiPxX8BHi9RwfzD7Yn-wugU19ghrkBFKsaCPrZmU'
+      },
+}}
+```
+
+### `licenseServer`
+
+The URL pointing to the licenseServer that will provide the authorization to play the protected stream.
+
+### `type`
+
+You can specify the DRM type, either by string or using the exported DRMType enum.
+Valid values are, for Android: DRMType.WIDEVINE / DRMType.PLAYREADY / DRMType.CLEARKEY.
+for iOS: DRMType.FAIRPLAY
+
+## Common Usage Scenarios
+
+### Send cookies to license server
+
+You can send Cookies to the license server via `headers` prop. Example:
+
+```js
+drm: {
+    type: DRMType.WIDEVINE
+    licenseServer: 'https://drm-widevine-licensing.axtest.net/AcquireLicense',
+    headers: {
+        'Cookie': 'PHPSESSID=etcetc; csrftoken=mytoken; _gat=1; foo=bar'
+    },
+}
+```
+
+### Custom License Acquisition (only iOS for now)
+
+```js
+drm: {
+    type: DRMType.FAIRPLAY,
+    getLicense: (spcString) => {
+        const base64spc = Base64.encode(spcString);
+        return fetch('YOUR LICENSE SERVER HERE', {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/json',
+                Accept: 'application/json',
+            },
+            body: JSON.stringify({
+                getFairplayLicense: {
+                    foo: 'bar',
+                    spcMessage: base64spc,
+                }
+            })
+        })
+            .then(response => response.json())
+            .then((response) => {
+                if (response && response.getFairplayLicenseResponse
+                    && response.getFairplayLicenseResponse.ckcResponse) {
+                    return response.getFairplayLicenseResponse.ckcResponse;
+                }
+                throw new Error('No correct response');
+            })
+            .catch((error) => {
+                console.error('CKC error', error);
+            });
+    }
+}
+```
diff --git a/node_modules/react-native-video/docs/PROJECTS.md b/node_modules/react-native-video/docs/PROJECTS.md
new file mode 100644
index 0000000..fca3201
--- /dev/null
+++ b/node_modules/react-native-video/docs/PROJECTS.md
@@ -0,0 +1,9 @@
+This page links other open source projects which can be usefull for your player implementation
+
+# UI over react-native-video
+ - [react-native-video-controls](https://github.com/itsnubix/react-native-video-controls): First reference player UI
+ - [react-native-media-console](https://github.com/criszz77/react-native-media-console): React-native-video-controls updated and rewritten in typescript
+ - [react-native-corner-video](https://github.com/Lg0gs/react-native-corner-video): A floating video player
+
+# Other tools
+ - [react-native-music-control](https://github.com/tanguyantoine/react-native-music-control): A toolbox to control player over media session
diff --git a/node_modules/react-native-video/docs/caching.md b/node_modules/react-native-video/docs/caching.md
new file mode 100644
index 0000000..c2b8df9
--- /dev/null
+++ b/node_modules/react-native-video/docs/caching.md
@@ -0,0 +1,22 @@
+# Caching
+
+Caching is currently only supported on `iOS` platforms with a CocoaPods setup.
+
+# Technology
+
+The cache is backed by [SPTPersistentCache](https://github.com/spotify/SPTPersistentCache) and [DVAssetLoaderDelegate](https://github.com/vdugnist/DVAssetLoaderDelegate).
+
+# How Does It Work
+
+The caching is based on the url of the asset.
+SPTPersistentCache is a LRU ([Least Recently Used](https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU))) cache.
+
+# Restrictions
+
+Currently, caching is only supported for URLs that end in a `.mp4`, `.m4v`, or `.mov` extension. In future versions, URLs that end in a query string (e.g. test.mp4?resolution=480p) will be support once dependencies allow access to the `Content-Type` header.  At this time, HLS playlists (.m3u8) and videos that sideload text tracks are not supported and will bypass the cache.
+
+You will also receive warnings in the Xcode logs by using the `debug` mode. So if you are not 100% sure if your video is cached, check your Xcode logs!
+
+By default files expire after 30 days and the maxmimum cache size is 100mb.
+
+In a future release the cache might have more configurable options.
diff --git a/node_modules/react-native-video/docs/tvOS-step-1.jpg b/node_modules/react-native-video/docs/tvOS-step-1.jpg
new file mode 100644
index 0000000..742304d
Binary files /dev/null and b/node_modules/react-native-video/docs/tvOS-step-1.jpg differ
diff --git a/node_modules/react-native-video/docs/tvOS-step-2.jpg b/node_modules/react-native-video/docs/tvOS-step-2.jpg
new file mode 100644
index 0000000..3e95505
Binary files /dev/null and b/node_modules/react-native-video/docs/tvOS-step-2.jpg differ
diff --git a/node_modules/react-native-video/docs/tvOS-step-3.jpg b/node_modules/react-native-video/docs/tvOS-step-3.jpg
new file mode 100644
index 0000000..395cd37
Binary files /dev/null and b/node_modules/react-native-video/docs/tvOS-step-3.jpg differ
diff --git a/node_modules/react-native-video/docs/tvOS-step-4.jpg b/node_modules/react-native-video/docs/tvOS-step-4.jpg
new file mode 100644
index 0000000..c709618
Binary files /dev/null and b/node_modules/react-native-video/docs/tvOS-step-4.jpg differ
diff --git a/node_modules/react-native-video/dom/LICENSE.md b/node_modules/react-native-video/dom/LICENSE.md
deleted file mode 100644
index aa185c8..0000000
--- a/node_modules/react-native-video/dom/LICENSE.md
+++ /dev/null
@@ -1,9 +0,0 @@
-MIT License
-
-Copyright (c) 2018 Vincent Riemer
-
-Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/node_modules/react-native-video/dom/RCTVideo.js b/node_modules/react-native-video/dom/RCTVideo.js
deleted file mode 100644
index 3212897..0000000
--- a/node_modules/react-native-video/dom/RCTVideo.js
+++ /dev/null
@@ -1,278 +0,0 @@
-// @flow
-
-import { RCTEvent, RCTView, type RCTBridge } from "react-native-dom";
-import shaka from "shaka-player";
-
-import resizeModes from "./resizeModes";
-import type { VideoSource } from "./types";
-import RCTVideoEvent from "./RCTVideoEvent";
-
-class RCTVideo extends RCTView {
-  playPromise: Promise<void> = Promise.resolve();
-  progressTimer: number;
-  videoElement: HTMLVideoElement;
-
-  onEnd: boolean = false;
-  onLoad: boolean = false;
-  onLoadStart: boolean = false;
-  onProgress: boolean = false;
-
-  _paused: boolean = false;
-  _progressUpdateInterval: number = 250.0;
-  _savedVolume: number = 1.0;
-
-  constructor(bridge: RCTBridge) {
-    super(bridge);
-
-    this.eventDispatcher = bridge.getModuleByName("EventDispatcher");
-
-    shaka.polyfill.installAll();
-
-    this.onEnd = this.onEnd.bind(this);
-    this.onLoad = this.onLoad.bind(this);
-    this.onLoadStart = this.onLoadStart.bind(this);
-    this.onPlay = this.onPlay.bind(this);
-    this.onProgress = this.onProgress.bind(this);
-
-    this.videoElement = this.initializeVideoElement();
-    this.videoElement.addEventListener("ended", this.onEnd);
-    this.videoElement.addEventListener("loadeddata", this.onLoad);
-    this.videoElement.addEventListener("canplay", this.onReadyForDisplay);
-    this.videoElement.addEventListener("loadstart", this.onLoadStart);
-    this.videoElement.addEventListener("pause", this.onPause);
-    this.videoElement.addEventListener("play", this.onPlay);
-    this.player = new shaka.Player(this.videoElement);
-
-    this.muted = false;
-    this.rate = 1.0;
-    this.volume = 1.0;
-    this.childContainer.appendChild(this.videoElement);
-  }
-
-  detachFromView(view: UIView) {
-    this.videoElement.removeEventListener("ended", this.onEnd);
-    this.videoElement.removeEventListener("loadeddata", this.onLoad);
-    this.videoElement.removeEventListener("canplay", this.onReadyForDisplay);
-    this.videoElement.removeEventListener("loadstart", this.onLoadStart);
-    this.videoElement.removeEventListener("pause", this.onPause);
-    this.videoElement.removeEventListener("play", this.onPlay);
-
-    this.stopProgressTimer();
-  }
-
-  initializeVideoElement() {
-    const elem = document.createElement("video");
-
-    Object.assign(elem.style, {
-      display: "block",
-      position: "absolute",
-      top: "0",
-      left: "0",
-      width: "100%",
-      height: "100%"
-    });
-
-    return elem;
-  }
-
-  presentFullscreenPlayer() {
-    this.videoElement.webkitRequestFullScreen();
-  }
-
-  set controls(value: boolean) {
-    this.videoElement.controls = value;
-    this.videoElement.style.pointerEvents = value ? "auto" : "";
-  }
-
-  set id(value: string) {
-    this.videoElement.id = value;
-  }
-
-  set muted(value: boolean) {
-    this.videoElement.muted = true;
-  }
-
-  set paused(value: boolean) {
-    if (value) {
-      this.videoElement.pause();
-    } else {
-      this.requestPlay();
-    }
-    this._paused = value;
-  }
-
-  set progressUpdateInterval(value: number) {
-    this._progressUpdateInterval = value;
-    this.stopProgressTimer();
-    if (!this._paused) {
-      this.startProgressTimer();
-    }
-  }
-
-  set rate(value: number) {
-    this.videoElement.defaultPlaybackRate = value; // playbackRate doesn't work on Chrome
-    this.videoElement.playbackRate = value;
-  }
-
-  set repeat(value: boolean) {
-    this.videoElement.loop = value;
-  }
-
-  set resizeMode(value: number) {
-    switch (value) {
-      case resizeModes.ScaleNone: {
-        this.videoElement.style.objectFit = "none";
-        break;
-      }
-      case resizeModes.ScaleToFill: {
-        this.videoElement.style.objectFit = "fill";
-        break;
-      }
-      case resizeModes.ScaleAspectFit: {
-        this.videoElement.style.objectFit = "contain";
-        break;
-      }
-      case resizeModes.ScaleAspectFill: {
-        this.videoElement.style.objectFit = "cover";
-        break;
-      }
-    }
-  }
-
-  set seek(value: number) {
-    this.videoElement.currentTime = value;
-  }
-
-  set source(value: VideoSource) {
-    let uri = value.uri;
-
-    if (uri.startsWith("blob:")) {
-      let blob = this.bridge.blobManager.resolveURL(uri);
-      if (blob.type === "text/xml") {
-        blob = new Blob([blob], { type: "video/mp4" });
-      }
-      uri = URL.createObjectURL(blob);
-    }
-
-    if (!shaka.Player.isBrowserSupported()) { // primarily iOS WebKit
-      this.videoElement.setAttribute("src", uri);
-      if (!this._paused) {
-        this.requestPlay();
-      }
-    } else {
-      this.player.load(uri)
-        .then(() => {
-          if (!this._paused) {
-            this.requestPlay();
-          }
-        })
-        .catch(this.onError);
-    }
-  }
-
-  set volume(value: number) {
-    if (value === 0) {
-      this.muted = true;
-    } else {
-      this.videoElement.volume = value;
-      this.muted = false;
-    }
-  }
-
-  onEnd = () => {
-    this.onProgress();
-    this.sendEvent("topVideoEnd", null);
-    this.stopProgressTimer();    
-  }
-
-  onError = error => {
-    console.warn("topVideoError", error);
-  }
-
-  onLoad = () => {
-    // height & width are safe with audio, will be 0
-    const height = this.videoElement.videoHeight;
-    const width = this.videoElement.videoWidth;
-    const payload = {
-      currentPosition: this.videoElement.currentTime,
-      duration: this.videoElement.duration,
-      naturalSize: {
-        width,
-        height,
-        orientation: width >= height ? "landscape" : "portrait"
-      }
-    };
-    this.sendEvent("topVideoLoad", payload);
-  }
-
-  onReadyForDisplay = () => {
-    this.sendEvent("onReadyForDisplay");
-  }
-
-  onLoadStart = () => {
-    const src = this.videoElement.currentSrc;
-    const payload = {
-      isNetwork: !src.match(/^https?:\/\/localhost/), // require is served from localhost
-      uri: this.videoElement.currentSrc
-    };
-    this.sendEvent("topVideoLoadStart", payload);
-  }
-
-  onPause = () => {
-    this.stopProgressTimer();
-  }
-
-  onPlay = () => {
-    this.startProgressTimer();
-  }
-
-  onProgress = () => {
-    const payload = {
-      currentTime: this.videoElement.currentTime,
-      seekableDuration: this.videoElement.duration
-    };
-    this.sendEvent("topVideoProgress", payload);
-  }
-
-  onRejectedAutoplay = () => {
-    this.sendEvent("topVideoRejectedAutoplay", null);
-  }
-
-  requestPlay() {
-    const playPromise = this.videoElement.play();
-    if (playPromise) {
-      playPromise
-        .then(() => {})
-        .catch(e => {
-          /* This is likely one of:
-           * name: NotAllowedError - autoplay is not supported
-           * name: NotSupportedError - format is not supported
-           */
-          this.onError({ code: e.name, message: e.message });
-        });
-    }
-  }
-
-  sendEvent(eventName, payload) {
-    const event = new RCTVideoEvent(eventName, this.reactTag, 0, payload);
-    this.eventDispatcher.sendEvent(event);
-  }
-
-  startProgressTimer() {
-    if (!this.progressTimer && this._progressUpdateInterval) {
-      this.onProgress();
-      this.progressTimer = setInterval(this.onProgress, this._progressUpdateInterval);
-    }
-  }
-
-  stopProgressTimer() {
-    if (this.progressTimer) {
-      clearInterval(this.progressTimer);
-      this.progressTimer = null;
-    }
-  }
-}
-
-customElements.define("rct-video", RCTVideo);
-
-export default RCTVideo;
diff --git a/node_modules/react-native-video/dom/RCTVideoEvent.js b/node_modules/react-native-video/dom/RCTVideoEvent.js
deleted file mode 100644
index 699a88c..0000000
--- a/node_modules/react-native-video/dom/RCTVideoEvent.js
+++ /dev/null
@@ -1,56 +0,0 @@
-// import { RCTEvent } from "react-native-dom";
-
-interface RCTEvent {
-    viewTag: number;
-    eventName: string;
-    coalescingKey: number;
-  
-    canCoalesce(): boolean;
-    coalesceWithEvent(event: RCTEvent): RCTEvent;
-  
-    moduleDotMethod(): string;
-    arguments(): Array<any>;
-  }
-
-export default class RCTVideoEvent implements RCTEvent {
-  viewTag: number;
-  eventName: string;
-  coalescingKey: number;
-
-  constructor(
-    eventName: string,
-    reactTag: number,
-    coalescingKey: number,
-    data: ?Object
-  ) {
-    this.viewTag = reactTag;
-    this.eventName = eventName;
-    this.coalescingKey = coalescingKey;
-    this.data = data;
-  }
-
-  canCoalesce(): boolean {
-    return false;
-  }
-
-  coalesceWithEvent(event: RCTEvent): RCTEvent {
-    return;
-  }
-
-  moduleDotMethod(): string {
-    return "RCTEventEmitter.receiveEvent";
-  }
-
-  arguments(): Array<any> {
-    const args = [
-      this.viewTag,
-      this.eventName,
-      this.data
-    ];
-    return args;
-  }
-
-  coalescingKey(): number {
-    return this.coalescingKey;
-  }
-}
diff --git a/node_modules/react-native-video/dom/RCTVideoManager.js b/node_modules/react-native-video/dom/RCTVideoManager.js
deleted file mode 100644
index 2eb5309..0000000
--- a/node_modules/react-native-video/dom/RCTVideoManager.js
+++ /dev/null
@@ -1,87 +0,0 @@
-// @flow
-
-import { RCTViewManager } from "react-native-dom";
-
-import RCTVideo from "./RCTVideo";
-import resizeModes from "./resizeModes";
-
-import type { VideoSource } from "./types";
-
-class RCTVideoManager extends RCTViewManager {
-  static moduleName = "RCTVideoManager";
-
-  view() {
-    return new RCTVideo(this.bridge);
-  }
-
-  describeProps() {
-    return super
-      .describeProps()
-      .addBooleanProp("controls", this.setControls)
-      .addStringProp("id", this.setId)
-      .addBooleanProp("muted", this.setMuted)
-      .addBooleanProp("paused", this.setPaused)
-      .addNumberProp("progressUpdateInterval", this.setProgressUpdateInterval)
-      .addBooleanProp("rate", this.setRate)
-      .addBooleanProp("repeat", this.setRepeat)
-      .addNumberProp("resizeMode", this.setResizeMode)
-      .addNumberProp("seek", this.setSeek)
-      .addObjectProp("src", this.setSource)
-      .addNumberProp("volume", this.setVolume)
-      .addDirectEvent("onVideoEnd")
-      .addDirectEvent("onVideoError")
-      .addDirectEvent("onVideoLoad")
-      .addDirectEvent("onVideoLoadStart")
-      .addDirectEvent("onVideoProgress");
-  }
-
-  dismissFullscreenPlayer() {
-    // not currently working
-  }
-
-  presentFullscreenPlayer() {
-    // not currently working
-  }
-
-  setControls(view: RCTVideo, value: boolean) {
-    view.controls = value;
-  }
-
-  setId(view: RCTVideo, value: string) {
-    view.id = value;
-  }
-
-  setMuted(view: RCTVideo, value: boolean) {
-    view.muted = value;
-  }
-
-  setPaused(view: RCTVideo, value: boolean) {
-    view.paused = value;
-  }
-
-  setRate(view: RCTVideo, value: number) {
-    view.rate = value;
-  }
-
-  setRepeat(view: RCTVideo, value: boolean) {
-    view.repeat = value;
-  }
-
-  setResizeMode(view: RCTVideo, value: number) {
-    view.resizeMode = value;
-  }
-
-  setSeek(view: RCTVideo, value: number) {
-    view.seek = value;
-  }
-
-  setSource(view: RCTVideo, value: VideoSource) {
-    view.source = value;
-  }
-
-  constantsToExport() {
-    return { ...resizeModes };
-  }
-}
-
-export default RCTVideoManager;
diff --git a/node_modules/react-native-video/dom/index.js b/node_modules/react-native-video/dom/index.js
deleted file mode 100644
index d68d5bb..0000000
--- a/node_modules/react-native-video/dom/index.js
+++ /dev/null
@@ -1,3 +0,0 @@
-// @flow
-
-module.exports = require("./RCTVideoManager");
diff --git a/node_modules/react-native-video/dom/resizeModes.js b/node_modules/react-native-video/dom/resizeModes.js
deleted file mode 100644
index 5f569e0..0000000
--- a/node_modules/react-native-video/dom/resizeModes.js
+++ /dev/null
@@ -1,8 +0,0 @@
-// @flow
-
-export default {
-  ScaleNone: 0,
-  ScaleToFill: 1,
-  ScaleAspectFit: 2,
-  ScaleAspectFill: 3,
-};
diff --git a/node_modules/react-native-video/dom/types.js b/node_modules/react-native-video/dom/types.js
deleted file mode 100644
index fe1d1a1..0000000
--- a/node_modules/react-native-video/dom/types.js
+++ /dev/null
@@ -1,10 +0,0 @@
-// @flow
-
-export type VideoSource = {
-  uri: string,
-  type: string,
-  mainVer: number,
-  patchVer: number,
-  isNetwork: boolean,
-  isAsset: boolean,
-};
diff --git a/node_modules/react-native-video/examples/basic/windows/VideoPlayer/Bundle/.npmignore b/node_modules/react-native-video/examples/basic/windows/VideoPlayer/Bundle/.npmignore
deleted file mode 100644
index 005717e..0000000
--- a/node_modules/react-native-video/examples/basic/windows/VideoPlayer/Bundle/.npmignore
+++ /dev/null
@@ -1,2 +0,0 @@
-*
-!.gitignore
diff --git a/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.pbxproj b/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.pbxproj
index 4e675ac..1665197 100644
--- a/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.pbxproj
+++ b/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.pbxproj
@@ -7,14 +7,12 @@
 	objects = {
 
 /* Begin PBXBuildFile section */
-		D1107C0A2110259000073188 /* UIView+FindUIViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = D1107C032110259000073188 /* UIView+FindUIViewController.m */; };
-		D1107C0B2110259000073188 /* UIView+FindUIViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = D1107C032110259000073188 /* UIView+FindUIViewController.m */; };
-		D1107C0C2110259000073188 /* RCTVideo.m in Sources */ = {isa = PBXBuildFile; fileRef = D1107C052110259000073188 /* RCTVideo.m */; };
-		D1107C0D2110259000073188 /* RCTVideo.m in Sources */ = {isa = PBXBuildFile; fileRef = D1107C052110259000073188 /* RCTVideo.m */; };
-		D1107C0E2110259000073188 /* RCTVideoManager.m in Sources */ = {isa = PBXBuildFile; fileRef = D1107C062110259000073188 /* RCTVideoManager.m */; };
-		D1107C0F2110259000073188 /* RCTVideoManager.m in Sources */ = {isa = PBXBuildFile; fileRef = D1107C062110259000073188 /* RCTVideoManager.m */; };
-		D1107C102110259000073188 /* RCTVideoPlayerViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = D1107C082110259000073188 /* RCTVideoPlayerViewController.m */; };
-		D1107C112110259000073188 /* RCTVideoPlayerViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = D1107C082110259000073188 /* RCTVideoPlayerViewController.m */; };
+		0177D39A27170A7A00F5BE18 /* RCTVideoManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0177D39227170A7A00F5BE18 /* RCTVideoManager.swift */; };
+		0177D39B27170A7A00F5BE18 /* UIView+FindUIViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0177D39327170A7A00F5BE18 /* UIView+FindUIViewController.swift */; };
+		0177D39C27170A7A00F5BE18 /* RCTVideoPlayerViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0177D39427170A7A00F5BE18 /* RCTVideoPlayerViewController.swift */; };
+		0177D39D27170A7A00F5BE18 /* RCTVideoPlayerViewControllerDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0177D39627170A7A00F5BE18 /* RCTVideoPlayerViewControllerDelegate.swift */; };
+		0177D39E27170A7A00F5BE18 /* RCTVideoManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 0177D39727170A7A00F5BE18 /* RCTVideoManager.m */; };
+		0177D39F27170A7A00F5BE18 /* RCTVideo.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0177D39927170A7A00F5BE18 /* RCTVideo.swift */; };
 /* End PBXBuildFile section */
 
 /* Begin PBXCopyFilesBuildPhase section */
@@ -39,17 +37,18 @@
 /* End PBXCopyFilesBuildPhase section */
 
 /* Begin PBXFileReference section */
+		01450CB5271D5738005D8F6B /* libRCTVideo.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libRCTVideo.a; sourceTree = BUILT_PRODUCTS_DIR; };
+		01489050272001A100E69940 /* DataStructures */ = {isa = PBXFileReference; lastKnownFileType = folder; name = DataStructures; path = Video/DataStructures; sourceTree = "<group>"; };
+		01489051272001A100E69940 /* Features */ = {isa = PBXFileReference; lastKnownFileType = folder; name = Features; path = Video/Features; sourceTree = "<group>"; };
+		0177D39227170A7A00F5BE18 /* RCTVideoManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; name = RCTVideoManager.swift; path = Video/RCTVideoManager.swift; sourceTree = "<group>"; };
+		0177D39327170A7A00F5BE18 /* UIView+FindUIViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; name = "UIView+FindUIViewController.swift"; path = "Video/UIView+FindUIViewController.swift"; sourceTree = "<group>"; };
+		0177D39427170A7A00F5BE18 /* RCTVideoPlayerViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; name = RCTVideoPlayerViewController.swift; path = Video/RCTVideoPlayerViewController.swift; sourceTree = "<group>"; };
+		0177D39527170A7A00F5BE18 /* RCTSwiftLog */ = {isa = PBXFileReference; lastKnownFileType = folder; name = RCTSwiftLog; path = Video/RCTSwiftLog; sourceTree = "<group>"; };
+		0177D39627170A7A00F5BE18 /* RCTVideoPlayerViewControllerDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; name = RCTVideoPlayerViewControllerDelegate.swift; path = Video/RCTVideoPlayerViewControllerDelegate.swift; sourceTree = "<group>"; };
+		0177D39727170A7A00F5BE18 /* RCTVideoManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = RCTVideoManager.m; path = Video/RCTVideoManager.m; sourceTree = "<group>"; };
+		0177D39827170A7A00F5BE18 /* RCTVideo-Bridging-Header.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "RCTVideo-Bridging-Header.h"; path = "Video/RCTVideo-Bridging-Header.h"; sourceTree = "<group>"; };
+		0177D39927170A7A00F5BE18 /* RCTVideo.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; name = RCTVideo.swift; path = Video/RCTVideo.swift; sourceTree = "<group>"; };
 		134814201AA4EA6300B7C361 /* libRCTVideo.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libRCTVideo.a; sourceTree = BUILT_PRODUCTS_DIR; };
-		641E28441F0EEC8500443AF6 /* libRCTVideo.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libRCTVideo.a; sourceTree = BUILT_PRODUCTS_DIR; };
-		D1107C012110259000073188 /* RCTVideoPlayerViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RCTVideoPlayerViewController.h; path = Video/RCTVideoPlayerViewController.h; sourceTree = "<group>"; };
-		D1107C022110259000073188 /* RCTVideoPlayerViewControllerDelegate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RCTVideoPlayerViewControllerDelegate.h; path = Video/RCTVideoPlayerViewControllerDelegate.h; sourceTree = "<group>"; };
-		D1107C032110259000073188 /* UIView+FindUIViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = "UIView+FindUIViewController.m"; path = "Video/UIView+FindUIViewController.m"; sourceTree = "<group>"; };
-		D1107C042110259000073188 /* UIView+FindUIViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "UIView+FindUIViewController.h"; path = "Video/UIView+FindUIViewController.h"; sourceTree = "<group>"; };
-		D1107C052110259000073188 /* RCTVideo.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = RCTVideo.m; path = Video/RCTVideo.m; sourceTree = "<group>"; };
-		D1107C062110259000073188 /* RCTVideoManager.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = RCTVideoManager.m; path = Video/RCTVideoManager.m; sourceTree = "<group>"; };
-		D1107C072110259000073188 /* RCTVideo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RCTVideo.h; path = Video/RCTVideo.h; sourceTree = "<group>"; };
-		D1107C082110259000073188 /* RCTVideoPlayerViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = RCTVideoPlayerViewController.m; path = Video/RCTVideoPlayerViewController.m; sourceTree = "<group>"; };
-		D1107C092110259000073188 /* RCTVideoManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RCTVideoManager.h; path = Video/RCTVideoManager.h; sourceTree = "<group>"; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
@@ -88,18 +87,19 @@
 		58B511D21A9E6C8500147676 = {
 			isa = PBXGroup;
 			children = (
-				D1107C072110259000073188 /* RCTVideo.h */,
-				D1107C052110259000073188 /* RCTVideo.m */,
-				D1107C092110259000073188 /* RCTVideoManager.h */,
-				D1107C062110259000073188 /* RCTVideoManager.m */,
-				D1107C012110259000073188 /* RCTVideoPlayerViewController.h */,
-				D1107C082110259000073188 /* RCTVideoPlayerViewController.m */,
-				D1107C022110259000073188 /* RCTVideoPlayerViewControllerDelegate.h */,
-				D1107C042110259000073188 /* UIView+FindUIViewController.h */,
-				D1107C032110259000073188 /* UIView+FindUIViewController.m */,
+				01489050272001A100E69940 /* DataStructures */,
+				01489051272001A100E69940 /* Features */,
+				0177D39527170A7A00F5BE18 /* RCTSwiftLog */,
+				0177D39927170A7A00F5BE18 /* RCTVideo.swift */,
+				0177D39727170A7A00F5BE18 /* RCTVideoManager.m */,
+				0177D39227170A7A00F5BE18 /* RCTVideoManager.swift */,
+				0177D39427170A7A00F5BE18 /* RCTVideoPlayerViewController.swift */,
+				0177D39627170A7A00F5BE18 /* RCTVideoPlayerViewControllerDelegate.swift */,
+				0177D39327170A7A00F5BE18 /* UIView+FindUIViewController.swift */,
+				0177D39827170A7A00F5BE18 /* RCTVideo-Bridging-Header.h */,
 				134814211AA4EA7D00B7C361 /* Products */,
-				641E28441F0EEC8500443AF6 /* libRCTVideo.a */,
 				49E995712048B4CE00EA7890 /* Frameworks */,
+				01450CB5271D5738005D8F6B /* libRCTVideo.a */,
 			);
 			sourceTree = "<group>";
 		};
@@ -137,7 +137,7 @@
 			);
 			name = "RCTVideo-tvOS";
 			productName = "RCTVideo-tvOS";
-			productReference = 641E28441F0EEC8500443AF6 /* libRCTVideo.a */;
+			productReference = 01450CB5271D5738005D8F6B /* libRCTVideo.a */;
 			productType = "com.apple.product-type.library.static";
 		};
 /* End PBXNativeTarget section */
@@ -151,9 +151,11 @@
 				TargetAttributes = {
 					58B511DA1A9E6C8500147676 = {
 						CreatedOnToolsVersion = 6.1.1;
+						LastSwiftMigration = 1300;
 					};
 					641E28431F0EEC8500443AF6 = {
 						CreatedOnToolsVersion = 8.3.3;
+						LastSwiftMigration = 1300;
 						ProvisioningStyle = Automatic;
 					};
 				};
@@ -163,6 +165,7 @@
 			developmentRegion = English;
 			hasScannedForEncodings = 0;
 			knownRegions = (
+				English,
 				en,
 			);
 			mainGroup = 58B511D21A9E6C8500147676;
@@ -181,10 +184,12 @@
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				D1107C0A2110259000073188 /* UIView+FindUIViewController.m in Sources */,
-				D1107C102110259000073188 /* RCTVideoPlayerViewController.m in Sources */,
-				D1107C0E2110259000073188 /* RCTVideoManager.m in Sources */,
-				D1107C0C2110259000073188 /* RCTVideo.m in Sources */,
+				0177D39D27170A7A00F5BE18 /* RCTVideoPlayerViewControllerDelegate.swift in Sources */,
+				0177D39C27170A7A00F5BE18 /* RCTVideoPlayerViewController.swift in Sources */,
+				0177D39B27170A7A00F5BE18 /* UIView+FindUIViewController.swift in Sources */,
+				0177D39F27170A7A00F5BE18 /* RCTVideo.swift in Sources */,
+				0177D39E27170A7A00F5BE18 /* RCTVideoManager.m in Sources */,
+				0177D39A27170A7A00F5BE18 /* RCTVideoManager.swift in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -192,10 +197,6 @@
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				D1107C0B2110259000073188 /* UIView+FindUIViewController.m in Sources */,
-				D1107C112110259000073188 /* RCTVideoPlayerViewController.m in Sources */,
-				D1107C0F2110259000073188 /* RCTVideoManager.m in Sources */,
-				D1107C0D2110259000073188 /* RCTVideo.m in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -236,7 +237,7 @@
 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
 				GCC_WARN_UNUSED_FUNCTION = YES;
 				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
+				IPHONEOS_DEPLOYMENT_TARGET = 9.0;
 				MTL_ENABLE_DEBUG_INFO = YES;
 				ONLY_ACTIVE_ARCH = YES;
 				SDKROOT = iphoneos;
@@ -270,7 +271,7 @@
 				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
 				GCC_WARN_UNUSED_FUNCTION = YES;
 				GCC_WARN_UNUSED_VARIABLE = YES;
-				IPHONEOS_DEPLOYMENT_TARGET = 7.0;
+				IPHONEOS_DEPLOYMENT_TARGET = 9.0;
 				MTL_ENABLE_DEBUG_INFO = NO;
 				SDKROOT = iphoneos;
 				VALIDATE_PRODUCT = YES;
@@ -280,30 +281,39 @@
 		58B511F01A9E6C8500147676 /* Debug */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				CLANG_ENABLE_MODULES = YES;
 				HEADER_SEARCH_PATHS = (
 					"$(inherited)",
 					/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include,
 					"$(SRCROOT)/Vendor/SPTPersistentCache/include/**",
 				);
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks @loader_path/Frameworks";
 				LIBRARY_SEARCH_PATHS = "$(inherited)";
 				OTHER_LDFLAGS = "-ObjC";
 				PRODUCT_NAME = RCTVideo;
 				SKIP_INSTALL = YES;
+				SWIFT_OBJC_BRIDGING_HEADER = "Video/RCTVideo-Bridging-Header.h";
+				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+				SWIFT_VERSION = 5.0;
 			};
 			name = Debug;
 		};
 		58B511F11A9E6C8500147676 /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				CLANG_ENABLE_MODULES = YES;
 				HEADER_SEARCH_PATHS = (
 					"$(inherited)",
 					/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include,
 					"$(SRCROOT)/Vendor/SPTPersistentCache/include/**",
 				);
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks @loader_path/Frameworks";
 				LIBRARY_SEARCH_PATHS = "$(inherited)";
 				OTHER_LDFLAGS = "-ObjC";
 				PRODUCT_NAME = RCTVideo;
 				SKIP_INSTALL = YES;
+				SWIFT_OBJC_BRIDGING_HEADER = "Video/RCTVideo-Bridging-Header.h";
+				SWIFT_VERSION = 5.0;
 			};
 			name = Release;
 		};
@@ -312,15 +322,19 @@
 			buildSettings = {
 				CLANG_ANALYZER_NONNULL = YES;
 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
+				CLANG_ENABLE_MODULES = YES;
 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
 				CLANG_WARN_INFINITE_RECURSION = YES;
 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
 				DEBUG_INFORMATION_FORMAT = dwarf;
 				GCC_NO_COMMON_BLOCKS = YES;
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/../Frameworks";
 				OTHER_LDFLAGS = "-ObjC";
 				PRODUCT_NAME = RCTVideo;
 				SDKROOT = appletvos;
 				SKIP_INSTALL = YES;
+				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
+				SWIFT_VERSION = 5.0;
 				TVOS_DEPLOYMENT_TARGET = 10.2;
 			};
 			name = Debug;
@@ -330,16 +344,19 @@
 			buildSettings = {
 				CLANG_ANALYZER_NONNULL = YES;
 				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
+				CLANG_ENABLE_MODULES = YES;
 				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
 				CLANG_WARN_INFINITE_RECURSION = YES;
 				CLANG_WARN_SUSPICIOUS_MOVE = YES;
 				COPY_PHASE_STRIP = NO;
 				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
 				GCC_NO_COMMON_BLOCKS = YES;
+				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/../Frameworks @loader_path/../Frameworks";
 				OTHER_LDFLAGS = "-ObjC";
 				PRODUCT_NAME = RCTVideo;
 				SDKROOT = appletvos;
 				SKIP_INSTALL = YES;
+				SWIFT_VERSION = 5.0;
 				TVOS_DEPLOYMENT_TARGET = 10.2;
 			};
 			name = Release;
diff --git a/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.xcworkspace/contents.xcworkspacedata b/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.xcworkspace/contents.xcworkspacedata
new file mode 100644
index 0000000..919434a
--- /dev/null
+++ b/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.xcworkspace/contents.xcworkspacedata
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Workspace
+   version = "1.0">
+   <FileRef
+      location = "self:">
+   </FileRef>
+</Workspace>
diff --git a/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist b/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
new file mode 100644
index 0000000..18d9810
--- /dev/null
+++ b/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>IDEDidComputeMac32BitWarning</key>
+	<true/>
+</dict>
+</plist>
diff --git a/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.xcworkspace/xcuserdata/olivier.xcuserdatad/UserInterfaceState.xcuserstate b/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.xcworkspace/xcuserdata/olivier.xcuserdatad/UserInterfaceState.xcuserstate
new file mode 100644
index 0000000..9772d7c
Binary files /dev/null and b/node_modules/react-native-video/ios/RCTVideo.xcodeproj/project.xcworkspace/xcuserdata/olivier.xcuserdatad/UserInterfaceState.xcuserstate differ
diff --git a/node_modules/react-native-video/ios/RCTVideo.xcodeproj/xcuserdata/olivier.xcuserdatad/xcschemes/xcschememanagement.plist b/node_modules/react-native-video/ios/RCTVideo.xcodeproj/xcuserdata/olivier.xcuserdatad/xcschemes/xcschememanagement.plist
new file mode 100644
index 0000000..2af12c9
--- /dev/null
+++ b/node_modules/react-native-video/ios/RCTVideo.xcodeproj/xcuserdata/olivier.xcuserdatad/xcschemes/xcschememanagement.plist
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>SchemeUserState</key>
+	<dict>
+		<key>RCTVideo-tvOS.xcscheme_^#shared#^_</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>0</integer>
+		</dict>
+		<key>RCTVideo.xcscheme_^#shared#^_</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>1</integer>
+		</dict>
+	</dict>
+</dict>
+</plist>
diff --git a/node_modules/react-native-video/ios/Video/DataStructures/DRMParams.swift b/node_modules/react-native-video/ios/Video/DataStructures/DRMParams.swift
new file mode 100644
index 0000000..64add7e
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/DataStructures/DRMParams.swift
@@ -0,0 +1,30 @@
+struct DRMParams {
+    let type: String?
+    let licenseServer: String?
+    let headers: Dictionary<String,Any>?
+    let contentId: String?
+    let certificateUrl: String?
+    let base64Certificate: Bool?
+    
+    let json: NSDictionary?
+    
+    init(_ json: NSDictionary!) {
+        guard json != nil else {
+            self.json = nil
+            self.type = nil
+            self.licenseServer = nil
+            self.contentId = nil
+            self.certificateUrl = nil
+            self.base64Certificate = nil
+            self.headers = nil
+            return
+        }
+        self.json = json
+        self.type = json["type"] as? String
+        self.licenseServer = json["licenseServer"] as? String
+        self.contentId = json["contentId"] as? String
+        self.certificateUrl = json["certificateUrl"] as? String
+        self.base64Certificate = json["base64Certificate"] as? Bool
+        self.headers = json["headers"] as? Dictionary<String,Any>
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/DataStructures/SelectedTrackCriteria.swift b/node_modules/react-native-video/ios/Video/DataStructures/SelectedTrackCriteria.swift
new file mode 100644
index 0000000..7d97b8f
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/DataStructures/SelectedTrackCriteria.swift
@@ -0,0 +1,18 @@
+struct SelectedTrackCriteria {
+    let type: String
+    let value: Any?
+    
+    let json: NSDictionary?
+    
+    init(_ json: NSDictionary!) {
+        guard json != nil else {
+            self.json = nil
+            self.type = ""
+            self.value = nil
+            return
+        }
+        self.json = json
+        self.type = json["type"] as? String ?? ""
+        self.value = json["value"]
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/DataStructures/TextTrack.swift b/node_modules/react-native-video/ios/Video/DataStructures/TextTrack.swift
new file mode 100644
index 0000000..b0bdad8
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/DataStructures/TextTrack.swift
@@ -0,0 +1,25 @@
+
+struct TextTrack {
+    let type: String
+    let language: String
+    let title: String
+    let uri: String
+    
+    let json: NSDictionary?
+    
+    init(_ json: NSDictionary!) {
+        guard json != nil else {
+            self.json = nil
+            self.type = ""
+            self.language = ""
+            self.title = ""
+            self.uri = ""
+            return
+        }
+        self.json = json
+        self.type = json["type"] as? String ?? ""
+        self.language = json["language"] as? String ?? ""
+        self.title = json["title"] as? String ?? ""
+        self.uri = json["uri"] as? String ?? ""
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/DataStructures/VideoSource.swift b/node_modules/react-native-video/ios/Video/DataStructures/VideoSource.swift
new file mode 100644
index 0000000..7cb7c38
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/DataStructures/VideoSource.swift
@@ -0,0 +1,37 @@
+
+struct VideoSource {
+    let type: String?
+    let uri: String?
+    let isNetwork: Bool
+    let isAsset: Bool
+    let shouldCache: Bool
+    let requestHeaders: Dictionary<String,Any>?
+    let startTime: Int64?
+    let endTime: Int64?
+    
+    let json: NSDictionary?
+    
+    init(_ json: NSDictionary!) {
+        guard json != nil else {
+            self.json = nil
+            self.type = nil
+            self.uri = nil
+            self.isNetwork = false
+            self.isAsset = false
+            self.shouldCache = false
+            self.requestHeaders = nil
+            self.startTime = nil
+            self.endTime = nil
+            return
+        }
+        self.json = json
+        self.type = json["type"] as? String
+        self.uri = json["uri"] as? String
+        self.isNetwork = json["isNetwork"] as? Bool ?? false
+        self.isAsset = json["isAsset"] as? Bool ?? false
+        self.shouldCache = json["shouldCache"] as? Bool ?? false
+        self.requestHeaders = json["requestHeaders"] as? Dictionary<String,Any>
+        self.startTime = json["startTime"] as? Int64
+        self.endTime = json["endTime"] as? Int64
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/Features/RCTIMAAdsManager.swift b/node_modules/react-native-video/ios/Video/Features/RCTIMAAdsManager.swift
new file mode 100644
index 0000000..d069af7
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/Features/RCTIMAAdsManager.swift
@@ -0,0 +1,196 @@
+#if USE_GOOGLE_IMA
+import Foundation
+import GoogleInteractiveMediaAds
+
+class RCTIMAAdsManager: NSObject, IMAAdsLoaderDelegate, IMAAdsManagerDelegate {
+
+    private weak var _video: RCTVideo?
+
+    /* Entry point for the SDK. Used to make ad requests. */
+    private var adsLoader: IMAAdsLoader!
+    /* Main point of interaction with the SDK. Created by the SDK as the result of an ad request. */
+    private var adsManager: IMAAdsManager!
+
+    init(video:RCTVideo!) {
+        _video = video
+
+        super.init()
+    }
+
+    func setUpAdsLoader() {
+        adsLoader = IMAAdsLoader(settings: nil)
+        adsLoader.delegate = self
+    }
+
+    func requestAds() {
+        guard let _video = _video else {return}
+        // Create ad display container for ad rendering.
+        let adDisplayContainer = IMAAdDisplayContainer(adContainer: _video, viewController: _video.reactViewController())
+
+        let adTagUrl = _video.getAdTagUrl()
+        let contentPlayhead = _video.getContentPlayhead()
+
+        if adTagUrl != nil && contentPlayhead != nil {
+            // Create an ad request with our ad tag, display container, and optional user context.
+            let request = IMAAdsRequest(
+                adTagUrl: adTagUrl!,
+                adDisplayContainer: adDisplayContainer,
+                contentPlayhead: contentPlayhead,
+                userContext: nil)
+
+            adsLoader.requestAds(with: request)
+        }
+    }
+
+    // MARK: - Getters
+
+    func getAdsLoader() -> IMAAdsLoader? {
+        return adsLoader
+    }
+
+    func getAdsManager() -> IMAAdsManager? {
+        return adsManager
+    }
+
+    // MARK: - IMAAdsLoaderDelegate
+
+    func adsLoader(_ loader: IMAAdsLoader, adsLoadedWith adsLoadedData: IMAAdsLoadedData) {
+        guard let _video = _video else {return}
+        // Grab the instance of the IMAAdsManager and set yourself as the delegate.
+        adsManager = adsLoadedData.adsManager
+        adsManager?.delegate = self
+
+
+        // Create ads rendering settings and tell the SDK to use the in-app browser.
+        let adsRenderingSettings: IMAAdsRenderingSettings = IMAAdsRenderingSettings();
+        adsRenderingSettings.linkOpenerPresentingController = _video.reactViewController();
+
+        adsManager.initialize(with: adsRenderingSettings)
+    }
+
+    func adsLoader(_ loader: IMAAdsLoader, failedWith adErrorData: IMAAdLoadingErrorData) {
+        if adErrorData.adError.message != nil {
+            print("Error loading ads: " + adErrorData.adError.message!)
+        }
+
+        _video?.setPaused(false)
+    }
+
+    // MARK: - IMAAdsManagerDelegate
+
+    func adsManager(_ adsManager: IMAAdsManager, didReceive event: IMAAdEvent) {
+        guard let _video = _video else {return}
+        // Mute ad if the main player is muted
+        if (_video.isMuted()) {
+            adsManager.volume = 0;
+        }
+        // Play each ad once it has been loaded
+        if event.type == IMAAdEventType.LOADED {
+            adsManager.start()
+        }
+
+        if _video.onReceiveAdEvent != nil {
+            let type = convertEventToString(event: event.type)
+
+            _video.onReceiveAdEvent?([
+                "event": type,
+                "target": _video.reactTag!
+            ]);
+        }
+    }
+
+    func adsManager(_ adsManager: IMAAdsManager, didReceive error: IMAAdError) {
+        if error.message != nil {
+            print("AdsManager error: " + error.message!)
+        }
+
+        // Fall back to playing content
+        _video?.setPaused(false)
+    }
+
+    func adsManagerDidRequestContentPause(_ adsManager: IMAAdsManager) {
+        // Pause the content for the SDK to play ads.
+        _video?.setPaused(true)
+        _video?.setAdPlaying(true)
+    }
+
+    func adsManagerDidRequestContentResume(_ adsManager: IMAAdsManager) {
+        // Resume the content since the SDK is done playing ads (at least for now).
+        _video?.setAdPlaying(false)
+        _video?.setPaused(false)
+    }
+
+    // MARK: - Helpers
+
+    func convertEventToString(event: IMAAdEventType!) -> String {
+        var result = "UNKNOWN";
+
+        switch(event) {
+            case .AD_BREAK_READY:
+                result = "AD_BREAK_READY";
+                break;
+            case .AD_BREAK_ENDED:
+                result = "AD_BREAK_ENDED";
+                break;
+            case .AD_BREAK_STARTED:
+                result = "AD_BREAK_STARTED";
+                break;
+            case .AD_PERIOD_ENDED:
+                result = "AD_PERIOD_ENDED";
+                break;
+            case .AD_PERIOD_STARTED:
+                result = "AD_PERIOD_STARTED";
+                break;
+            case .ALL_ADS_COMPLETED:
+                result = "ALL_ADS_COMPLETED";
+                break;
+            case .CLICKED:
+                result = "CLICK";
+                break;
+            case .COMPLETE:
+                result = "COMPLETE";
+                break;
+            case .CUEPOINTS_CHANGED:
+                result = "CUEPOINTS_CHANGED";
+                break;
+            case .FIRST_QUARTILE:
+                result = "FIRST_QUARTILE";
+                break;
+            case .LOADED:
+                result = "LOADED";
+                break;
+            case .LOG:
+                result = "LOG";
+                break;
+            case .MIDPOINT:
+                result = "MIDPOINT";
+                break;
+            case .PAUSE:
+                result = "PAUSED";
+                break;
+            case .RESUME:
+                result = "RESUMED";
+                break;
+            case .SKIPPED:
+                result = "SKIPPED";
+                break;
+            case .STARTED:
+                result = "STARTED";
+                break;
+            case .STREAM_LOADED:
+                result = "STREAM_LOADED";
+                break;
+            case .TAPPED:
+                result = "TAPPED";
+                break;
+            case .THIRD_QUARTILE:
+                result = "THIRD_QUARTILE";
+                break;
+            default:
+                result = "UNKNOWN";
+        }
+
+        return result;
+    }
+}
+#endif
diff --git a/node_modules/react-native-video/ios/Video/Features/RCTPictureInPicture.swift b/node_modules/react-native-video/ios/Video/Features/RCTPictureInPicture.swift
new file mode 100644
index 0000000..4525df0
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/Features/RCTPictureInPicture.swift
@@ -0,0 +1,75 @@
+import AVFoundation
+import AVKit
+import MediaAccessibility
+import React
+import Foundation
+
+#if TARGET_OS_IOS
+class RCTPictureInPicture: NSObject, AVPictureInPictureControllerDelegate {
+    private var _onPictureInPictureStatusChanged: RCTDirectEventBlock?
+    private var _onRestoreUserInterfaceForPictureInPictureStop: RCTDirectEventBlock?
+    private var _restoreUserInterfaceForPIPStopCompletionHandler:((Bool) -> Void)? = nil
+    private var _pipController:AVPictureInPictureController?
+    private var _isActive:Bool = false
+    
+    init(_ onPictureInPictureStatusChanged: @escaping RCTDirectEventBlock, _ onRestoreUserInterfaceForPictureInPictureStop: @escaping RCTDirectEventBlock) {
+        _onPictureInPictureStatusChanged = onPictureInPictureStatusChanged
+        _onRestoreUserInterfaceForPictureInPictureStop = onRestoreUserInterfaceForPictureInPictureStop
+    }
+    
+    func pictureInPictureControllerDidStartPictureInPicture(_ pictureInPictureController: AVPictureInPictureController) {
+        guard let _onPictureInPictureStatusChanged = _onPictureInPictureStatusChanged else { return }
+        
+        _onPictureInPictureStatusChanged([ "isActive": NSNumber(value: true)])
+    }
+    
+    func pictureInPictureControllerDidStopPictureInPicture(_ pictureInPictureController: AVPictureInPictureController) {
+        guard let _onPictureInPictureStatusChanged = _onPictureInPictureStatusChanged else { return }
+        
+        _onPictureInPictureStatusChanged([ "isActive": NSNumber(value: false)])
+    }
+    
+    func pictureInPictureController(_ pictureInPictureController: AVPictureInPictureController, restoreUserInterfaceForPictureInPictureStopWithCompletionHandler completionHandler: @escaping (Bool) -> Void) {
+        
+        assert(_restoreUserInterfaceForPIPStopCompletionHandler == nil, "restoreUserInterfaceForPIPStopCompletionHandler was not called after picture in picture was exited.")
+        
+        guard let _onRestoreUserInterfaceForPictureInPictureStop = _onRestoreUserInterfaceForPictureInPictureStop else { return }
+        
+        _onRestoreUserInterfaceForPictureInPictureStop([:])
+        
+        _restoreUserInterfaceForPIPStopCompletionHandler = completionHandler
+    }
+    
+    func setRestoreUserInterfaceForPIPStopCompletionHandler(_ restore:Bool) {
+        guard let _restoreUserInterfaceForPIPStopCompletionHandler = _restoreUserInterfaceForPIPStopCompletionHandler else { return }
+        _restoreUserInterfaceForPIPStopCompletionHandler(restore)
+        self._restoreUserInterfaceForPIPStopCompletionHandler = nil
+    }
+    
+    func setupPipController(_ playerLayer: AVPlayerLayer?) {
+        guard playerLayer != nil && AVPictureInPictureController.isPictureInPictureSupported() && _isActive else { return }
+        // Create new controller passing reference to the AVPlayerLayer
+        _pipController = AVPictureInPictureController(playerLayer:playerLayer!)
+        _pipController?.delegate = self
+    }
+    
+    func setPictureInPicture(_ isActive:Bool) {
+        if _isActive == isActive {
+            return
+        }
+        _isActive = isActive
+        
+        guard let _pipController = _pipController else { return }
+        
+        if _isActive && !_pipController.isPictureInPictureActive {
+            DispatchQueue.main.async(execute: {
+                _pipController.startPictureInPicture()
+            })
+        } else if !_isActive && _pipController.isPictureInPictureActive {
+            DispatchQueue.main.async(execute: {
+                _pipController.stopPictureInPicture()
+            })
+        }
+    }
+}
+#endif
diff --git a/node_modules/react-native-video/ios/Video/Features/RCTPlayerObserver.swift b/node_modules/react-native-video/ios/Video/Features/RCTPlayerObserver.swift
new file mode 100644
index 0000000..9e798dc
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/Features/RCTPlayerObserver.swift
@@ -0,0 +1,214 @@
+import AVFoundation
+import AVKit
+import Foundation
+
+@objc
+protocol RCTPlayerObserverHandlerObjc {
+    func handleDidFailToFinishPlaying(notification:NSNotification!)
+    func handlePlaybackStalled(notification:NSNotification!)
+    func handlePlayerItemDidReachEnd(notification:NSNotification!)
+    // unused
+//    func handleAVPlayerAccess(notification:NSNotification!)
+}
+
+protocol RCTPlayerObserverHandler: RCTPlayerObserverHandlerObjc {
+    func handleTimeUpdate(time:CMTime)
+    func handleReadyForDisplay(changeObject: Any, change:NSKeyValueObservedChange<Bool>)
+    func handleTimeMetadataChange(playerItem:AVPlayerItem, change:NSKeyValueObservedChange<[AVMetadataItem]?>)
+    func handlePlayerItemStatusChange(playerItem:AVPlayerItem, change:NSKeyValueObservedChange<AVPlayerItem.Status>)
+    func handlePlaybackBufferKeyEmpty(playerItem:AVPlayerItem, change:NSKeyValueObservedChange<Bool>)
+    func handlePlaybackLikelyToKeepUp(playerItem:AVPlayerItem, change:NSKeyValueObservedChange<Bool>)
+    func handlePlaybackRateChange(player: AVPlayer, change: NSKeyValueObservedChange<Float>)
+    func handleExternalPlaybackActiveChange(player: AVPlayer, change: NSKeyValueObservedChange<Bool>)
+    func handleViewControllerOverlayViewFrameChange(overlayView:UIView, change:NSKeyValueObservedChange<CGRect>)
+}
+
+class RCTPlayerObserver: NSObject {
+
+    weak var _handlers: RCTPlayerObserverHandler?
+    
+    var player:AVPlayer? {
+        willSet {
+            removePlayerObservers()
+            removePlayerTimeObserver()
+        }
+        didSet {
+            if player != nil {
+                addPlayerObservers()
+                addPlayerTimeObserver()
+            }
+        }
+    }
+    var playerItem:AVPlayerItem? {
+        willSet {
+            removePlayerItemObservers()
+        }
+        didSet {
+            if playerItem != nil {
+                addPlayerItemObservers()
+            }
+        }
+    }
+    var playerViewController:AVPlayerViewController? {
+        willSet {
+            removePlayerViewControllerObservers()
+        }
+        didSet {
+            if playerViewController != nil {
+                addPlayerViewControllerObservers()
+            }
+        }
+    }
+    var playerLayer:AVPlayerLayer? {
+        willSet {
+            removePlayerLayerObserver()
+        }
+        didSet {
+            if playerLayer != nil {
+                addPlayerLayerObserver()
+            }
+        }
+    }
+    
+    private var _progressUpdateInterval:TimeInterval = 250
+    private var _timeObserver:Any?
+    
+    private var _playerRateChangeObserver:NSKeyValueObservation?
+    private var _playerExpernalPlaybackActiveObserver:NSKeyValueObservation?
+    private var _playerItemStatusObserver:NSKeyValueObservation?
+    private var _playerPlaybackBufferEmptyObserver:NSKeyValueObservation?
+    private var _playerPlaybackLikelyToKeepUpObserver:NSKeyValueObservation?
+    private var _playerTimedMetadataObserver:NSKeyValueObservation?
+    private var _playerViewControllerReadyForDisplayObserver:NSKeyValueObservation?
+    private var _playerLayerReadyForDisplayObserver:NSKeyValueObservation?
+    private var _playerViewControllerOverlayFrameObserver:NSKeyValueObservation?
+    
+    deinit {
+        if let _handlers = _handlers {
+            NotificationCenter.default.removeObserver(_handlers)
+        }
+    }
+    
+    func addPlayerObservers() {
+        guard let player = player, let _handlers = _handlers else {
+            return
+        }
+        
+        _playerRateChangeObserver = player.observe(\.rate, changeHandler: _handlers.handlePlaybackRateChange)
+        _playerExpernalPlaybackActiveObserver = player.observe(\.isExternalPlaybackActive, changeHandler: _handlers.handleExternalPlaybackActiveChange)
+    }
+    
+    func removePlayerObservers() {
+        _playerRateChangeObserver?.invalidate()
+        _playerExpernalPlaybackActiveObserver?.invalidate()
+    }
+    
+    func addPlayerItemObservers() {
+        guard let playerItem = playerItem, let _handlers = _handlers else { return }
+
+        _playerItemStatusObserver = playerItem.observe(\.status, options:  [.new, .old], changeHandler: _handlers.handlePlayerItemStatusChange)
+        _playerPlaybackBufferEmptyObserver = playerItem.observe(\.isPlaybackBufferEmpty, options:  [.new, .old], changeHandler: _handlers.handlePlaybackBufferKeyEmpty)
+        _playerPlaybackLikelyToKeepUpObserver = playerItem.observe(\.isPlaybackLikelyToKeepUp, options:  [.new, .old], changeHandler: _handlers.handlePlaybackLikelyToKeepUp)
+        _playerTimedMetadataObserver = playerItem.observe(\.timedMetadata, options:  [.new], changeHandler: _handlers.handleTimeMetadataChange)
+    }
+    
+    func removePlayerItemObservers() {
+        _playerItemStatusObserver?.invalidate()
+        _playerPlaybackBufferEmptyObserver?.invalidate()
+        _playerPlaybackLikelyToKeepUpObserver?.invalidate()
+        _playerTimedMetadataObserver?.invalidate()
+    }
+
+    func addPlayerViewControllerObservers() {
+        guard let playerViewController = playerViewController, let _handlers = _handlers else { return }
+        
+        _playerViewControllerReadyForDisplayObserver = playerViewController.observe(\.isReadyForDisplay, options:  [.new], changeHandler: _handlers.handleReadyForDisplay)
+        
+        _playerViewControllerOverlayFrameObserver = playerViewController.contentOverlayView?.observe(\.frame, options:  [.new, .old], changeHandler: _handlers.handleViewControllerOverlayViewFrameChange)
+    }
+    
+    func removePlayerViewControllerObservers() {
+        _playerViewControllerReadyForDisplayObserver?.invalidate()
+        _playerViewControllerOverlayFrameObserver?.invalidate()
+    }
+    
+    func addPlayerLayerObserver() {
+        guard let _handlers = _handlers else {return}
+        _playerLayerReadyForDisplayObserver = playerLayer?.observe(\.isReadyForDisplay, options:  [.new], changeHandler: _handlers.handleReadyForDisplay)
+    }
+    
+    func removePlayerLayerObserver() {
+        _playerLayerReadyForDisplayObserver?.invalidate()
+    }
+    
+    func addPlayerTimeObserver() {
+        guard let _handlers = _handlers else {return}
+        removePlayerTimeObserver()
+        let progressUpdateIntervalMS:Float64 = _progressUpdateInterval / 1000
+        // @see endScrubbing in AVPlayerDemoPlaybackViewController.m
+        // of https://developer.apple.com/library/ios/samplecode/AVPlayerDemo/Introduction/Intro.html
+        _timeObserver = player?.addPeriodicTimeObserver(
+            forInterval: CMTimeMakeWithSeconds(progressUpdateIntervalMS, preferredTimescale: Int32(NSEC_PER_SEC)),
+            queue:nil,
+            using:_handlers.handleTimeUpdate
+        )
+    }
+    
+    /* Cancels the previously registered time observer. */
+    func removePlayerTimeObserver() {
+        if _timeObserver != nil {
+            player?.removeTimeObserver(_timeObserver)
+            _timeObserver = nil
+        }
+    }
+    
+    func addTimeObserverIfNotSet() {
+        if (_timeObserver == nil) {
+            addPlayerTimeObserver()
+        }
+    }
+    
+    func replaceTimeObserverIfSet(_ newUpdateInterval:Float64? = nil) {
+        if let newUpdateInterval = newUpdateInterval {
+            _progressUpdateInterval = newUpdateInterval
+        }
+        if (_timeObserver != nil) {
+            addPlayerTimeObserver()
+        }
+    }
+    
+    func attachPlayerEventListeners() {
+        guard let _handlers = _handlers else {return}
+
+        NotificationCenter.default.removeObserver(_handlers,
+                                                  name:NSNotification.Name.AVPlayerItemDidPlayToEndTime,
+                                                  object:player?.currentItem)
+        NotificationCenter.default.addObserver(_handlers,
+                                               selector:#selector(RCTPlayerObserverHandler.handlePlayerItemDidReachEnd(notification:)),
+                                               name:NSNotification.Name.AVPlayerItemDidPlayToEndTime,
+                                               object:player?.currentItem)
+        
+        NotificationCenter.default.removeObserver(_handlers,
+                                                  name:NSNotification.Name.AVPlayerItemPlaybackStalled,
+                                                  object:nil)
+        NotificationCenter.default.addObserver(_handlers,
+                                               selector:#selector(RCTPlayerObserverHandler.handlePlaybackStalled(notification:)),
+                                               name:NSNotification.Name.AVPlayerItemPlaybackStalled,
+                                               object:nil)
+        NotificationCenter.default.removeObserver(_handlers,
+                                                  name: NSNotification.Name.AVPlayerItemFailedToPlayToEndTime,
+                                                  object:nil)
+        NotificationCenter.default.addObserver(_handlers,
+                                               selector:#selector(RCTPlayerObserverHandler.handleDidFailToFinishPlaying(notification:)),
+                                               name: NSNotification.Name.AVPlayerItemFailedToPlayToEndTime,
+                                               object:nil)
+    }
+    
+    func clearPlayer() {
+        player = nil
+        playerItem = nil
+        if let _handlers = _handlers {
+            NotificationCenter.default.removeObserver(_handlers)
+        }
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/Features/RCTPlayerOperations.swift b/node_modules/react-native-video/ios/Video/Features/RCTPlayerOperations.swift
new file mode 100644
index 0000000..a615644
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/Features/RCTPlayerOperations.swift
@@ -0,0 +1,243 @@
+import AVFoundation
+import MediaAccessibility
+import Promises
+
+let RCTVideoUnset = -1
+
+/*!
+ * Collection of mutating functions
+ */
+enum RCTPlayerOperations {
+    
+    static func setSideloadedText(player:AVPlayer?, textTracks:[TextTrack]?, criteria:SelectedTrackCriteria?) {
+        let type = criteria?.type
+        let textTracks:[TextTrack]! = textTracks ?? RCTVideoUtils.getTextTrackInfo(player)
+        let trackCount:Int! = player?.currentItem?.tracks.count ?? 0
+
+        // The first few tracks will be audio & video track
+        var firstTextIndex:Int = 0
+        for i in 0..<(trackCount) {
+            if player?.currentItem?.tracks[i].assetTrack?.hasMediaCharacteristic(.legible) ?? false {
+                firstTextIndex = i
+                break
+            }
+        }
+        
+        var selectedTrackIndex:Int = RCTVideoUnset
+        
+        if (type == "disabled") {
+            // Select the last text index which is the disabled text track
+            selectedTrackIndex = trackCount - firstTextIndex
+        } else if (type == "language") {
+            let selectedValue = criteria?.value as? String
+            for i in 0..<textTracks.count {
+                let currentTextTrack = textTracks[i]
+                if (selectedValue == currentTextTrack.language) {
+                    selectedTrackIndex = i
+                    break
+                }
+            }
+        } else if (type == "title") {
+            let selectedValue = criteria?.value as? String
+            for i in 0..<textTracks.count {
+                let currentTextTrack = textTracks[i]
+                if (selectedValue == currentTextTrack.title) {
+                    selectedTrackIndex = i
+                    break
+                }
+            }
+        } else if (type == "index") {
+            if let value = criteria?.value, let index = value as? Int {
+                if textTracks.count > index {
+                    selectedTrackIndex = index
+                }
+            }
+        }
+        
+        // in the situation that a selected text track is not available (eg. specifies a textTrack not available)
+        if (type != "disabled") && selectedTrackIndex == RCTVideoUnset {
+            let captioningMediaCharacteristics = MACaptionAppearanceCopyPreferredCaptioningMediaCharacteristics(.user)
+            let captionSettings = captioningMediaCharacteristics as? [AnyHashable]
+            if ((captionSettings?.contains(AVMediaCharacteristic.transcribesSpokenDialogForAccessibility)) != nil) {
+                selectedTrackIndex = 0 // If we can't find a match, use the first available track
+                let systemLanguage = NSLocale.preferredLanguages.first
+                for i in 0..<textTracks.count {
+                    let currentTextTrack = textTracks[i]
+                    if systemLanguage == currentTextTrack.language {
+                        selectedTrackIndex = i
+                        break
+                    }
+                }
+            }
+        }
+                
+        for i in firstTextIndex..<(trackCount) {
+            var isEnabled = false
+            if selectedTrackIndex != RCTVideoUnset {
+                isEnabled = i == selectedTrackIndex + firstTextIndex
+            }
+            player?.currentItem?.tracks[i].isEnabled = isEnabled
+        }
+    }
+    
+    // UNUSED
+    static func setStreamingText(player:AVPlayer?, criteria:SelectedTrackCriteria?) {
+        let type = criteria?.type
+        let group:AVMediaSelectionGroup! = player?.currentItem?.asset.mediaSelectionGroup(forMediaCharacteristic: AVMediaCharacteristic.legible)
+        var mediaOption:AVMediaSelectionOption!
+        
+        if (type == "disabled") {
+            // Do nothing. We want to ensure option is nil
+        } else if (type == "language") || (type == "title") {
+            let value = criteria?.value as? String
+            for i in 0..<group.options.count {
+                let currentOption:AVMediaSelectionOption! = group.options[i]
+                var optionValue:String!
+                if (type == "language") {
+                    optionValue = currentOption.extendedLanguageTag
+                } else {
+                    optionValue = currentOption.commonMetadata.map(\.value)[0] as! String
+                }
+                if (value == optionValue) {
+                    mediaOption = currentOption
+                    break
+                }
+            }
+            //} else if ([type isEqualToString:@"default"]) {
+            //  option = group.defaultOption; */
+        } else if (type == "index") {
+            if let value = criteria?.value, let index = value as? Int {
+                if group.options.count > index {
+                    mediaOption = group.options[index]
+                }
+            }
+        } else { // default. invalid type or "system"
+            #if TARGET_OS_TV
+                // Do noting. Fix for tvOS native audio menu language selector
+            #else
+                player?.currentItem?.selectMediaOptionAutomatically(in: group)
+                return
+            #endif
+        }
+        
+        #if TARGET_OS_TV
+            // Do noting. Fix for tvOS native audio menu language selector
+        #else
+            // If a match isn't found, option will be nil and text tracks will be disabled
+            player?.currentItem?.select(mediaOption, in:group)
+        #endif
+    }
+    
+    static func setMediaSelectionTrackForCharacteristic(player:AVPlayer?, characteristic:AVMediaCharacteristic, criteria:SelectedTrackCriteria?) {
+        let type = criteria?.type
+        let group:AVMediaSelectionGroup! = player?.currentItem?.asset.mediaSelectionGroup(forMediaCharacteristic: characteristic)
+        var mediaOption:AVMediaSelectionOption!
+
+        guard group != nil else { return }
+        
+        if (type == "disabled") {
+            // Do nothing. We want to ensure option is nil
+        } else if (type == "language") || (type == "title") {
+            let value = criteria?.value as? String
+            for i in 0..<group.options.count {
+                let currentOption:AVMediaSelectionOption! = group.options[i]
+                var optionValue:String!
+                if (type == "language") {
+                    optionValue = currentOption.extendedLanguageTag
+                } else {
+                    optionValue = currentOption.commonMetadata.map(\.value)[0] as? String
+                }
+                if (value == optionValue) {
+                    mediaOption = currentOption
+                    break
+                }
+            }
+            //} else if ([type isEqualToString:@"default"]) {
+            //  option = group.defaultOption; */
+        } else if type == "index" {
+            if let value = criteria?.value, let index = value as? Int {
+                if group.options.count > index {
+                    mediaOption = group.options[index]
+                }
+            }
+        } else if let group = group { // default. invalid type or "system"
+            player?.currentItem?.selectMediaOptionAutomatically(in: group)
+            return
+        }
+        
+        if let group = group {
+            // If a match isn't found, option will be nil and text tracks will be disabled
+            player?.currentItem?.select(mediaOption, in:group)
+        }
+        
+    }
+
+    static func seek(player: AVPlayer, playerItem:AVPlayerItem, paused:Bool, seekTime:Float, seekTolerance:Float) -> Promise<Bool> {
+        let timeScale:Int = 1000
+        let cmSeekTime:CMTime = CMTimeMakeWithSeconds(Float64(seekTime), preferredTimescale: Int32(timeScale))
+        let current:CMTime = playerItem.currentTime()
+        let tolerance:CMTime = CMTimeMake(value: Int64(seekTolerance), timescale: Int32(timeScale))
+        
+        return Promise<Bool>(on: .global()) { fulfill, reject in
+            guard CMTimeCompare(current, cmSeekTime) != 0 else {
+                reject(NSError(domain: "", code: 0, userInfo: nil))
+                return
+            }
+            if !paused { player.pause() }
+
+            player.seek(to: cmSeekTime, toleranceBefore:tolerance, toleranceAfter:tolerance, completionHandler:{ (finished:Bool) in
+                fulfill(finished)
+            })
+        }
+    }
+    
+    static func configureAudio(ignoreSilentSwitch:String, mixWithOthers:String) {
+        let audioSession:AVAudioSession! = AVAudioSession.sharedInstance()
+        var category:AVAudioSession.Category? = nil
+        var options:AVAudioSession.CategoryOptions? = nil
+
+        if (ignoreSilentSwitch == "ignore") {
+            category = AVAudioSession.Category.playback
+        } else if (ignoreSilentSwitch == "obey") {
+            category = AVAudioSession.Category.ambient
+        }
+
+        if (mixWithOthers == "mix") {
+            options = .mixWithOthers
+        } else if (mixWithOthers == "duck") {
+            options = .duckOthers
+        }
+
+        if let category = category, let options = options {
+            do {
+                try audioSession.setCategory(category, options: options)
+            } catch {
+                debugPrint("[RCTPlayerOperations] Problem setting up AVAudioSession category and options. Error: \(error).")
+                // Handle specific set category and option combination error
+                // setCategory:AVAudioSessionCategoryPlayback withOptions:mixWithOthers || duckOthers
+                // Failed to set category, error: 'what' Error Domain=NSOSStatusErrorDomain
+                // https://developer.apple.com/forums/thread/714598
+                if #available(iOS 16.0, *) {
+                    do {
+                        debugPrint("[RCTPlayerOperations] Reseting AVAudioSession category to playAndRecord with defaultToSpeaker options.")
+                        try audioSession.setCategory(AVAudioSession.Category.playAndRecord, options: AVAudioSession.CategoryOptions.defaultToSpeaker)
+                    } catch {
+                        debugPrint("[RCTPlayerOperations] Reseting AVAudioSession category and options problem. Error: \(error).")
+                    }
+                }
+            }
+        } else if let category = category, options == nil {
+            do {
+                try audioSession.setCategory(category)
+            } catch {
+                debugPrint("[RCTPlayerOperations] Problem setting up AVAudioSession category. Error: \(error).")
+            }
+        } else if category == nil, let options = options {
+            do {
+                try audioSession.setCategory(audioSession.category, options: options)
+            } catch {
+                debugPrint("[RCTPlayerOperations] Problem setting up AVAudioSession options. Error: \(error).")
+            }
+        }
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/Features/RCTResourceLoaderDelegate.swift b/node_modules/react-native-video/ios/Video/Features/RCTResourceLoaderDelegate.swift
new file mode 100644
index 0000000..5222851
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/Features/RCTResourceLoaderDelegate.swift
@@ -0,0 +1,167 @@
+import AVFoundation
+import Promises
+
+class RCTResourceLoaderDelegate: NSObject, AVAssetResourceLoaderDelegate, URLSessionDelegate {
+    
+    private var _loadingRequest:AVAssetResourceLoadingRequest?
+    private var _requestingCertificate:Bool = false
+    private var _requestingCertificateErrored:Bool = false
+    private var _drm: DRMParams?
+    private var _localSourceEncryptionKeyScheme: String?
+    private var _reactTag: NSNumber?
+    private var _onVideoError: RCTDirectEventBlock?
+    private var _onGetLicense: RCTDirectEventBlock?
+    
+    
+    init(
+        asset: AVURLAsset,
+        drm: DRMParams?,
+        localSourceEncryptionKeyScheme: String?,
+        onVideoError: RCTDirectEventBlock?,
+        onGetLicense: RCTDirectEventBlock?,
+        reactTag: NSNumber
+    ) {
+        super.init()
+        let queue = DispatchQueue(label: "assetQueue")
+        asset.resourceLoader.setDelegate(self, queue: queue)
+        _reactTag = reactTag
+        _onVideoError = onVideoError
+        _onGetLicense = onGetLicense
+        _drm = drm
+        _localSourceEncryptionKeyScheme = localSourceEncryptionKeyScheme
+    }
+    
+    deinit {
+        _loadingRequest?.finishLoading()
+    }
+    
+    func resourceLoader(_ resourceLoader:AVAssetResourceLoader, shouldWaitForRenewalOfRequestedResource renewalRequest:AVAssetResourceRenewalRequest) -> Bool {
+        return loadingRequestHandling(renewalRequest)
+    }
+    
+    func resourceLoader(_ resourceLoader:AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource loadingRequest:AVAssetResourceLoadingRequest) -> Bool {
+        return loadingRequestHandling(loadingRequest)
+    }
+    
+    func resourceLoader(_ resourceLoader:AVAssetResourceLoader, didCancel loadingRequest:AVAssetResourceLoadingRequest) {
+        RCTLog("didCancelLoadingRequest")
+    }
+
+    func setLicenseResult(_ license:String!) {
+        guard let respondData = RCTVideoUtils.base64DataFromBase64String(base64String: license),
+              let _loadingRequest = _loadingRequest else {
+                  setLicenseResultError("No data from JS license response")
+                  return
+              }
+        let dataRequest:AVAssetResourceLoadingDataRequest! = _loadingRequest.dataRequest
+        dataRequest.respond(with: respondData)
+        _loadingRequest.finishLoading()
+    }
+    
+    func setLicenseResultError(_ error:String!) {
+        if _loadingRequest != nil {
+            self.finishLoadingWithError(error: RCTVideoErrorHandler.fromJSPart(error))
+        }
+    }
+    
+    func finishLoadingWithError(error:Error!) -> Bool {
+        if let _loadingRequest = _loadingRequest, let error = error {
+            _loadingRequest.finishLoading(with: error as! NSError)
+            
+            _onVideoError?([
+                "error": [
+                    "code": NSNumber(value: (error as NSError).code),
+                    "localizedDescription": error.localizedDescription == nil ? "" : error.localizedDescription,
+                    "localizedFailureReason": ((error as NSError).localizedFailureReason == nil ? "" : (error as NSError).localizedFailureReason) ?? "",
+                    "localizedRecoverySuggestion": ((error as NSError).localizedRecoverySuggestion == nil ? "" : (error as NSError).localizedRecoverySuggestion) ?? "",
+                    "domain": (error as NSError).domain
+                ],
+                "target": _reactTag
+            ])
+            
+        }
+        return false
+    }
+    
+    func loadingRequestHandling(_ loadingRequest:AVAssetResourceLoadingRequest!) -> Bool {
+        if handleEmbeddedKey(loadingRequest) {
+            return true
+        }
+        
+        if _drm != nil {
+            return handleDrm(loadingRequest)
+        }
+        
+       return false
+    }
+    
+    func handleEmbeddedKey(_ loadingRequest:AVAssetResourceLoadingRequest!) -> Bool {
+        guard let url = loadingRequest.request.url,
+              let _localSourceEncryptionKeyScheme = _localSourceEncryptionKeyScheme,
+              let persistentKeyData = RCTVideoUtils.extractDataFromCustomSchemeUrl(from: url, scheme: _localSourceEncryptionKeyScheme)
+        else {
+            return false
+        }
+        
+        loadingRequest.contentInformationRequest?.contentType = AVStreamingKeyDeliveryPersistentContentKeyType
+        loadingRequest.contentInformationRequest?.isByteRangeAccessSupported = true
+        loadingRequest.contentInformationRequest?.contentLength = Int64(persistentKeyData.count)
+        loadingRequest.dataRequest?.respond(with: persistentKeyData)
+        loadingRequest.finishLoading()
+        
+        return true
+    }
+    
+    func handleDrm(_ loadingRequest:AVAssetResourceLoadingRequest!) -> Bool {
+        if _requestingCertificate {
+            return true
+        } else if _requestingCertificateErrored {
+            return false
+        }
+        _loadingRequest = loadingRequest
+        
+        guard let _drm = _drm, let drmType = _drm.type, drmType == "fairplay" else {
+            return finishLoadingWithError(error: RCTVideoErrorHandler.noDRMData)
+        }
+        
+        var promise: Promise<Data>
+        if _onGetLicense != nil {
+            let contentId = _drm.contentId ?? loadingRequest.request.url?.host
+            promise = RCTVideoDRM.handleWithOnGetLicense(
+                loadingRequest:loadingRequest,
+                contentId:contentId,
+                certificateUrl:_drm.certificateUrl,
+                base64Certificate:_drm.base64Certificate
+            ) .then{ spcData -> Void in
+                self._requestingCertificate = true
+                self._onGetLicense?(["licenseUrl": self._drm?.licenseServer ?? "",
+                                     "contentId": contentId,
+                                     "spcBase64": spcData.base64EncodedString(options: []),
+                                     "target": self._reactTag])
+            }
+        } else {
+            promise = RCTVideoDRM.handleInternalGetLicense(
+                loadingRequest:loadingRequest,
+                contentId:_drm.contentId,
+                licenseServer:_drm.licenseServer,
+                certificateUrl:_drm.certificateUrl,
+                base64Certificate:_drm.base64Certificate,
+                headers:_drm.headers
+            ) .then{ data -> Void in
+                    guard let dataRequest = loadingRequest.dataRequest else {
+                        throw RCTVideoErrorHandler.noCertificateData
+                    }
+                    dataRequest.respond(with:data)
+                    loadingRequest.finishLoading()
+                }
+        }
+        
+        
+        promise.catch{ error in
+            self.finishLoadingWithError(error:error)
+            self._requestingCertificateErrored = true
+        }
+        
+        return true
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/Features/RCTVideoDRM.swift b/node_modules/react-native-video/ios/Video/Features/RCTVideoDRM.swift
new file mode 100644
index 0000000..d059bbc
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/Features/RCTVideoDRM.swift
@@ -0,0 +1,168 @@
+import AVFoundation
+import Promises
+
+struct RCTVideoDRM {
+    @available(*, unavailable) private init() {}
+
+    static func fetchLicense(
+        licenseServer: String,
+        spcData: Data?,
+        contentId: String,
+        headers: [String:Any]?
+    ) -> Promise<Data> {
+        let request = createLicenseRequest(licenseServer:licenseServer, spcData:spcData, contentId:contentId, headers:headers)
+        
+        return Promise<Data>(on: .global()) { fulfill, reject in
+            let postDataTask = URLSession.shared.dataTask(with: request as URLRequest, completionHandler:{ (data:Data!,response:URLResponse!,error:Error!) in
+                
+                let httpResponse:HTTPURLResponse! = (response as! HTTPURLResponse)
+
+                guard error == nil else {
+                    print("Error getting license from \(licenseServer), HTTP status code \(httpResponse.statusCode)")
+                    reject(error)
+                    return
+                }
+                guard httpResponse.statusCode == 200 else {
+                    print("Error getting license from \(licenseServer), HTTP status code \(httpResponse.statusCode)")
+                    reject(RCTVideoErrorHandler.licenseRequestNotOk(httpResponse.statusCode))
+                    return
+                }
+                
+                guard data != nil, let decodedData = Data(base64Encoded: data, options: []) else {
+                    reject(RCTVideoErrorHandler.noDataFromLicenseRequest)
+                    return
+                }
+                
+                fulfill(decodedData)
+            })
+            postDataTask.resume()
+        }
+    }
+    
+    static func createLicenseRequest(
+        licenseServer: String,
+        spcData: Data?,
+        contentId: String,
+        headers: [String:Any]?
+    ) -> URLRequest {
+        var request = URLRequest(url: URL(string: licenseServer)!)
+        request.httpMethod = "POST"
+        
+        if let headers = headers {
+            for item in headers {
+                guard let key = item.key as? String, let value = item.value as? String else {
+                    continue
+                }
+                request.setValue(value, forHTTPHeaderField: key)
+            }
+        }
+        
+        let spcEncoded = spcData?.base64EncodedString(options: [])
+        let spcUrlEncoded = CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, spcEncoded as? CFString? as! CFString, nil, "?=&+" as CFString, CFStringBuiltInEncodings.UTF8.rawValue) as? String
+        let post = String(format:"spc=%@&%@", spcUrlEncoded as! CVarArg, contentId)
+        let postData = post.data(using: String.Encoding.utf8, allowLossyConversion:true)
+        request.httpBody = postData
+        
+        return request
+    }
+    
+    static func fetchSpcData(
+        loadingRequest: AVAssetResourceLoadingRequest,
+        certificateData: Data,
+        contentIdData: Data
+    ) -> Promise<Data> {
+        return Promise<Data>(on: .global()) { fulfill, reject in
+            var spcError:NSError!
+            var spcData: Data?
+            do {
+                spcData = try loadingRequest.streamingContentKeyRequestData(forApp: certificateData, contentIdentifier: contentIdData as Data, options: nil)
+            } catch _ {
+                print("SPC error")
+            }
+            
+            if spcError != nil {
+                reject(spcError)
+            }
+            
+            guard let spcData = spcData else {
+                reject(RCTVideoErrorHandler.noSPC)
+                return
+            }
+            
+            fulfill(spcData)
+        }
+    }
+    
+    static func createCertificateData(certificateStringUrl:String?, base64Certificate:Bool?) -> Promise<Data> {
+        return Promise<Data>(on: .global()) { fulfill, reject in
+
+            guard let certificateStringUrl = certificateStringUrl,
+                  let certificateURL = URL(string: certificateStringUrl.addingPercentEncoding(withAllowedCharacters: .urlFragmentAllowed) ?? "") else {
+                      reject(RCTVideoErrorHandler.noCertificateURL)
+                return
+            }
+
+            var certificateData:Data?
+            do {
+               certificateData = try Data(contentsOf: certificateURL)
+                if (base64Certificate != nil) {
+                    certificateData = Data(base64Encoded: certificateData! as Data, options: .ignoreUnknownCharacters)
+                }
+            } catch {}
+            
+            guard let certificateData = certificateData else {
+                reject(RCTVideoErrorHandler.noCertificateData)
+                return
+            }
+            
+            fulfill(certificateData)
+        }
+    }
+    
+    static func handleWithOnGetLicense(loadingRequest: AVAssetResourceLoadingRequest, contentId:String?, certificateUrl:String?, base64Certificate:Bool?) -> Promise<Data> {
+        let contentIdData = contentId?.data(using: .utf8)
+        
+        return RCTVideoDRM.createCertificateData(certificateStringUrl:certificateUrl, base64Certificate:base64Certificate)
+            .then{ certificateData -> Promise<Data> in
+                guard let contentIdData = contentIdData else {
+                    throw RCTVideoError.invalidContentId as! Error
+                }
+                
+                return RCTVideoDRM.fetchSpcData(
+                    loadingRequest:loadingRequest,
+                    certificateData:certificateData,
+                    contentIdData:contentIdData
+                )
+            }
+    }
+    
+    static func handleInternalGetLicense(loadingRequest: AVAssetResourceLoadingRequest, contentId:String?, licenseServer:String?, certificateUrl:String?, base64Certificate:Bool?, headers: [String:Any]?) -> Promise<Data> {
+        let url = loadingRequest.request.url
+        
+        guard let contentId = contentId ?? url?.absoluteString.replacingOccurrences(of: "skd://", with:"") else {
+            return Promise(RCTVideoError.invalidContentId as! Error)
+        }
+        
+        let contentIdData = NSData(bytes: contentId.cString(using: String.Encoding.utf8), length:contentId.lengthOfBytes(using: String.Encoding.utf8)) as Data
+        
+        return RCTVideoDRM.createCertificateData(certificateStringUrl:certificateUrl, base64Certificate:base64Certificate)
+            .then{ certificateData in
+                return RCTVideoDRM.fetchSpcData(
+                    loadingRequest:loadingRequest,
+                    certificateData:certificateData,
+                    contentIdData:contentIdData
+                )
+            }
+            .then{ spcData -> Promise<Data> in
+                guard let licenseServer = licenseServer else {
+                    throw RCTVideoError.noLicenseServerURL as! Error
+                }
+                return RCTVideoDRM.fetchLicense(
+                    licenseServer: licenseServer,
+                    spcData: spcData,
+                    contentId: contentId,
+                    headers: headers
+                )
+            }
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/Features/RCTVideoErrorHandling.swift b/node_modules/react-native-video/ios/Video/Features/RCTVideoErrorHandling.swift
new file mode 100644
index 0000000..e795aa2
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/Features/RCTVideoErrorHandling.swift
@@ -0,0 +1,103 @@
+enum RCTVideoError : Int {
+    case fromJSPart
+    case noLicenseServerURL
+    case licenseRequestNotOk
+    case noDataFromLicenseRequest
+    case noSPC
+    case noDataRequest
+    case noCertificateData
+    case noCertificateURL
+    case noFairplayDRM
+    case noDRMData
+    case invalidContentId
+}
+
+enum RCTVideoErrorHandler {
+    
+    static let noDRMData = NSError(
+        domain: "RCTVideo",
+        code: RCTVideoError.noDRMData.rawValue,
+        userInfo: [
+            NSLocalizedDescriptionKey: "Error obtaining DRM license.",
+            NSLocalizedFailureReasonErrorKey: "No drm object found.",
+            NSLocalizedRecoverySuggestionErrorKey: "Have you specified the 'drm' prop?"
+        ])
+    
+    static let noCertificateURL = NSError(
+        domain: "RCTVideo",
+        code: RCTVideoError.noCertificateURL.rawValue,
+        userInfo: [
+            NSLocalizedDescriptionKey: "Error obtaining DRM License.",
+            NSLocalizedFailureReasonErrorKey: "No certificate URL has been found.",
+            NSLocalizedRecoverySuggestionErrorKey: "Did you specified the prop certificateUrl?"
+        ])
+    
+    static let noCertificateData = NSError(
+        domain: "RCTVideo",
+        code: RCTVideoError.noCertificateData.rawValue,
+        userInfo: [
+            NSLocalizedDescriptionKey: "Error obtaining DRM license.",
+            NSLocalizedFailureReasonErrorKey: "No certificate data obtained from the specificied url.",
+            NSLocalizedRecoverySuggestionErrorKey: "Have you specified a valid 'certificateUrl'?"
+        ])
+    
+    static let noSPC = NSError(
+        domain: "RCTVideo",
+        code: RCTVideoError.noSPC.rawValue,
+        userInfo: [
+            NSLocalizedDescriptionKey: "Error obtaining license.",
+            NSLocalizedFailureReasonErrorKey: "No spc received.",
+            NSLocalizedRecoverySuggestionErrorKey: "Check your DRM config."
+        ])
+    
+    static let noLicenseServerURL = NSError(
+        domain: "RCTVideo",
+        code: RCTVideoError.noLicenseServerURL.rawValue,
+        userInfo: [
+            NSLocalizedDescriptionKey: "Error obtaining DRM License.",
+            NSLocalizedFailureReasonErrorKey: "No license server URL has been found.",
+            NSLocalizedRecoverySuggestionErrorKey: "Did you specified the prop licenseServer?"
+        ])
+    
+    static let noDataFromLicenseRequest = NSError(
+        domain: "RCTVideo",
+        code: RCTVideoError.noDataFromLicenseRequest.rawValue,
+        userInfo: [
+            NSLocalizedDescriptionKey: "Error obtaining DRM license.",
+            NSLocalizedFailureReasonErrorKey: "No data received from the license server.",
+            NSLocalizedRecoverySuggestionErrorKey: "Is the licenseServer ok?"
+        ])
+    
+    static func licenseRequestNotOk(_ statusCode: Int) -> NSError {
+        return NSError(
+            domain: "RCTVideo",
+            code: RCTVideoError.licenseRequestNotOk.rawValue,
+            userInfo: [
+                NSLocalizedDescriptionKey: "Error obtaining license.",
+                NSLocalizedFailureReasonErrorKey: String(
+                    format:"License server responded with status code %li",
+                    (statusCode)
+                ),
+                NSLocalizedRecoverySuggestionErrorKey: "Did you send the correct data to the license Server? Is the server ok?"
+            ])
+    }
+
+    static func fromJSPart(_ error: String) -> NSError {
+        return NSError(domain: "RCTVideo",
+            code: RCTVideoError.fromJSPart.rawValue,
+            userInfo: [
+                NSLocalizedDescriptionKey: error,
+                NSLocalizedFailureReasonErrorKey: error,
+                NSLocalizedRecoverySuggestionErrorKey: error
+            ])
+    }
+    
+    static let invalidContentId = NSError(
+        domain: "RCTVideo",
+        code: RCTVideoError.invalidContentId.rawValue,
+        userInfo: [
+            NSLocalizedDescriptionKey: "Error obtaining DRM license.",
+            NSLocalizedFailureReasonErrorKey: "No valide content Id received",
+            NSLocalizedRecoverySuggestionErrorKey: "Is the contentId and url ok?"
+        ])
+}
diff --git a/node_modules/react-native-video/ios/Video/Features/RCTVideoSave.swift b/node_modules/react-native-video/ios/Video/Features/RCTVideoSave.swift
new file mode 100644
index 0000000..ff8155e
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/Features/RCTVideoSave.swift
@@ -0,0 +1,75 @@
+import AVFoundation
+
+enum RCTVideoSave {
+
+    static func save(
+        options:NSDictionary!,
+        resolve: @escaping RCTPromiseResolveBlock,
+        reject:@escaping RCTPromiseRejectBlock,
+        
+        playerItem: AVPlayerItem?
+    ) {
+        let asset:AVAsset! = playerItem?.asset
+        
+        guard asset != nil else {
+            reject("ERROR_ASSET_NIL", "Asset is nil", nil)
+            return
+        }
+        
+        guard let exportSession = AVAssetExportSession(asset: asset, presetName:AVAssetExportPresetHighestQuality) else {
+            reject("ERROR_COULD_NOT_CREATE_EXPORT_SESSION", "Could not create export session", nil)
+            return
+        }
+        var path:String! = nil
+        path = RCTVideoSave.generatePathInDirectory(
+            directory: URL(fileURLWithPath: RCTVideoSave.cacheDirectoryPath() ?? "").appendingPathComponent("Videos").path,
+            withExtension: ".mp4")
+        let url:NSURL! = NSURL.fileURL(withPath: path) as NSURL
+        exportSession.outputFileType = AVFileType.mp4
+        exportSession.outputURL = url as URL?
+        exportSession.videoComposition = playerItem?.videoComposition
+        exportSession.shouldOptimizeForNetworkUse = true
+        exportSession.exportAsynchronously(completionHandler: {
+            
+            switch (exportSession.status) {
+            case .failed:
+                reject("ERROR_COULD_NOT_EXPORT_VIDEO", "Could not export video", exportSession.error)
+                break
+            case .cancelled:
+                reject("ERROR_EXPORT_SESSION_CANCELLED", "Export session was cancelled", exportSession.error)
+                break
+            default:
+                resolve(["uri": url.absoluteString])
+                break
+            }
+            
+        })
+    }
+    
+    static func generatePathInDirectory(directory: String?, withExtension `extension`: String?) -> String? {
+        let fileName = UUID().uuidString + (`extension` ?? "")
+        RCTVideoSave.ensureDirExists(withPath: directory)
+        return URL(fileURLWithPath: directory ?? "").appendingPathComponent(fileName).path
+    }
+    
+    static func cacheDirectoryPath() -> String? {
+        let array = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).map(\.path)
+        return array[0]
+    }
+    
+    static func ensureDirExists(withPath path: String?) -> Bool {
+        var isDir: ObjCBool = false
+        var error: Error?
+        let exists = FileManager.default.fileExists(atPath: path ?? "", isDirectory: &isDir)
+        if !(exists && isDir.boolValue) {
+            do {
+                try FileManager.default.createDirectory(atPath: path ?? "", withIntermediateDirectories: true, attributes: nil)
+            } catch {
+            }
+            if error != nil {
+                return false
+            }
+        }
+        return true
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/Features/RCTVideoUtils.swift b/node_modules/react-native-video/ios/Video/Features/RCTVideoUtils.swift
new file mode 100644
index 0000000..9916db3
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/Features/RCTVideoUtils.swift
@@ -0,0 +1,319 @@
+import AVFoundation
+import Promises
+import Photos
+
+/*!
+ * Collection of pure functions
+ */
+enum RCTVideoUtils {
+    
+    /*!
+     * Calculates and returns the playable duration of the current player item using its loaded time ranges.
+     *
+     * \returns The playable duration of the current player item in seconds.
+     */
+    static func calculatePlayableDuration(_ player:AVPlayer?, withSource source:VideoSource?) -> NSNumber {
+        guard let player = player,
+              let video:AVPlayerItem = player.currentItem,
+              video.status == AVPlayerItem.Status.readyToPlay else {
+            return 0
+        }
+        
+        if (source?.startTime != nil && source?.endTime != nil) {
+            return NSNumber(value: (Float64(source?.endTime ?? 0) - Float64(source?.startTime ?? 0)) / 1000)
+        }
+        
+        var effectiveTimeRange:CMTimeRange?
+        for (_, value) in video.loadedTimeRanges.enumerated() {
+            let timeRange:CMTimeRange = value.timeRangeValue
+            if CMTimeRangeContainsTime(timeRange, time: video.currentTime()) {
+                effectiveTimeRange = timeRange
+                break
+            }
+        }
+        
+        if let effectiveTimeRange = effectiveTimeRange {
+            let playableDuration:Float64 = CMTimeGetSeconds(CMTimeRangeGetEnd(effectiveTimeRange))
+            if playableDuration > 0 {
+                if (source?.startTime != nil) {
+                    return NSNumber(value: (playableDuration - Float64(source?.startTime ?? 0) / 1000))
+                }
+                
+                return playableDuration as NSNumber
+            }
+        }
+        
+        return 0
+    }
+
+    static func urlFilePath(filepath:NSString!, searchPath:FileManager.SearchPathDirectory) -> NSURL! {
+        if filepath.contains("file://") {
+            return NSURL(string: filepath as String)
+        }
+        
+        // if no file found, check if the file exists in the Document directory
+        let paths:[String]! = NSSearchPathForDirectoriesInDomains(searchPath, .userDomainMask, true)
+        var relativeFilePath:String! = filepath.lastPathComponent
+        // the file may be multiple levels below the documents directory
+        let directoryString:String! = searchPath == .cachesDirectory ? "Library/Caches/" : "Documents";
+        let fileComponents:[String]! = filepath.components(separatedBy: directoryString)
+        if fileComponents.count > 1 {
+            relativeFilePath = fileComponents[1]
+        }
+        
+        let path:String! = (paths.first! as NSString).appendingPathComponent(relativeFilePath)
+        if FileManager.default.fileExists(atPath: path) {
+            return NSURL.fileURL(withPath: path) as NSURL
+        }
+        return nil
+    }
+    
+    static func playerItemSeekableTimeRange(_ player:AVPlayer?) -> CMTimeRange {
+        if let playerItem = player?.currentItem,
+           playerItem.status == .readyToPlay,
+           let firstItem = playerItem.seekableTimeRanges.first {
+            return firstItem.timeRangeValue
+        }
+        
+        return (CMTimeRange.zero)
+    }
+    
+    static func playerItemDuration(_ player:AVPlayer?) -> CMTime {
+        if let playerItem = player?.currentItem,
+           playerItem.status == .readyToPlay {
+            return(playerItem.duration)
+        }
+        
+        return(CMTime.invalid)
+    }
+    
+    static func calculateSeekableDuration(_ player:AVPlayer?) -> NSNumber {
+        let timeRange:CMTimeRange = RCTVideoUtils.playerItemSeekableTimeRange(player)
+        if CMTIME_IS_NUMERIC(timeRange.duration)
+        {
+            return NSNumber(value: CMTimeGetSeconds(timeRange.duration))
+        }
+        return 0
+    }
+    
+    static func getAudioTrackInfo(_ player:AVPlayer?) -> [AnyObject]! {
+        guard let player = player else {
+            return []
+        }
+
+        let audioTracks:NSMutableArray! = NSMutableArray()
+        let group = player.currentItem?.asset.mediaSelectionGroup(forMediaCharacteristic: .audible)
+        for i in 0..<(group?.options.count ?? 0) {
+            let currentOption = group?.options[i]
+            var title = ""
+            let values = currentOption?.commonMetadata.map(\.value)
+            if (values?.count ?? 0) > 0, let value = values?[0] {
+                title = value as! String
+            }
+            let language:String! = currentOption?.extendedLanguageTag ?? ""
+
+            let selectedOption: AVMediaSelectionOption? = player.currentItem?.currentMediaSelection.selectedMediaOption(in: group!)
+
+            let audioTrack = [
+                "index": NSNumber(value: i),
+                "title": title,
+                "language": language ?? "",
+                "selected": currentOption?.displayName == selectedOption?.displayName
+            ] as [String : Any]
+            audioTracks.add(audioTrack)
+        }
+        return audioTracks as [AnyObject]?
+    }
+    
+    static func getTextTrackInfo(_ player:AVPlayer?) -> [TextTrack]! {
+        guard let player = player else {
+            return []
+        }
+
+        // if streaming video, we extract the text tracks
+        var textTracks:[TextTrack] = []
+        let group = player.currentItem?.asset.mediaSelectionGroup(forMediaCharacteristic: .legible)
+        for i in 0..<(group?.options.count ?? 0) {
+            let currentOption = group?.options[i]
+            var title = ""
+            let values = currentOption?.commonMetadata.map(\.value)
+            if (values?.count ?? 0) > 0, let value = values?[0] {
+                title = value as! String
+            }
+            let language:String! = currentOption?.extendedLanguageTag ?? ""
+            let selectedOpt = player.currentItem?.currentMediaSelection
+            let selectedOption: AVMediaSelectionOption? = player.currentItem?.currentMediaSelection.selectedMediaOption(in: group!)
+            let textTrack = TextTrack([
+                "index": NSNumber(value: i),
+                "title": title,
+                "language": language,
+                "selected": currentOption?.displayName == selectedOption?.displayName
+            ])
+            textTracks.append(textTrack)
+        }
+        return textTracks
+    }
+    
+    // UNUSED
+    static func getCurrentTime(playerItem:AVPlayerItem?) -> Float {
+        return Float(CMTimeGetSeconds(playerItem?.currentTime() ?? .zero))
+    }
+    
+    static func base64DataFromBase64String(base64String:String?) -> Data? {
+        if let base64String = base64String {
+            return Data(base64Encoded:base64String)
+        }
+        return nil
+    }
+
+    static func replaceURLScheme(url: URL, scheme: String?) -> URL? {
+        var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false)
+        urlComponents?.scheme = scheme
+
+        return urlComponents?.url
+    }
+
+    static func extractDataFromCustomSchemeUrl(from url: URL, scheme: String) -> Data? {
+        guard url.scheme == scheme,
+              let adoptURL = RCTVideoUtils.replaceURLScheme(url:url, scheme: nil) else { return nil }
+
+        return Data(base64Encoded: adoptURL.absoluteString)
+    }
+    
+    static func generateMixComposition(_ asset:AVAsset) -> AVMutableComposition {
+        let mixComposition:AVMutableComposition = AVMutableComposition()
+        
+        let videoAsset:AVAssetTrack! = asset.tracks(withMediaType: AVMediaType.video).first
+        let videoCompTrack:AVMutableCompositionTrack! = mixComposition.addMutableTrack(withMediaType: AVMediaType.video, preferredTrackID:kCMPersistentTrackID_Invalid)
+        do {
+            try videoCompTrack.insertTimeRange(
+                CMTimeRangeMake(start: .zero, duration: videoAsset.timeRange.duration),
+                of: videoAsset,
+                at: .zero)
+        } catch {
+        }
+        
+        let audioAsset:AVAssetTrack! = asset.tracks(withMediaType: AVMediaType.audio).first
+        let audioCompTrack:AVMutableCompositionTrack! = mixComposition.addMutableTrack(withMediaType: AVMediaType.audio, preferredTrackID:kCMPersistentTrackID_Invalid)
+        do {
+            try audioCompTrack.insertTimeRange(
+                CMTimeRangeMake(start: .zero, duration: videoAsset.timeRange.duration),
+                of: audioAsset,
+                at: .zero)
+        } catch {
+        }
+        
+        return mixComposition
+    }
+    
+    static func getValidTextTracks(asset:AVAsset, assetOptions:NSDictionary?, mixComposition:AVMutableComposition, textTracks:[TextTrack]?) -> [TextTrack] {
+        let videoAsset:AVAssetTrack! = asset.tracks(withMediaType: AVMediaType.video).first
+        var validTextTracks:[TextTrack] = []
+        
+        if let textTracks = textTracks, textTracks.count > 0 {
+            for i in 0..<textTracks.count {
+                var textURLAsset:AVURLAsset!
+                let textUri:String = textTracks[i].uri
+                if textUri.lowercased().hasPrefix("http") {
+                    textURLAsset = AVURLAsset(url: NSURL(string: textUri)! as URL, options:(assetOptions as! [String : Any]))
+                } else {
+                    let isDisabledTrack:Bool! = textTracks[i].type == "disabled"
+                    let searchPath:FileManager.SearchPathDirectory = isDisabledTrack ? .cachesDirectory : .documentDirectory;
+                    textURLAsset = AVURLAsset(url: RCTVideoUtils.urlFilePath(filepath: textUri as NSString?, searchPath: searchPath) as URL, options:nil)
+                }
+                let textTrackAsset:AVAssetTrack! = textURLAsset.tracks(withMediaType: AVMediaType.text).first
+                if (textTrackAsset == nil) {continue} // fix when there's no textTrackAsset
+                validTextTracks.append(textTracks[i])
+                let textCompTrack:AVMutableCompositionTrack! = mixComposition.addMutableTrack(withMediaType: AVMediaType.text,
+                                                                                              preferredTrackID:kCMPersistentTrackID_Invalid)
+                do {
+                    try textCompTrack.insertTimeRange(
+                        CMTimeRangeMake(start: .zero, duration: videoAsset.timeRange.duration),
+                        of: textTrackAsset,
+                        at: .zero)
+                } catch {
+                }
+            }
+        }
+        
+        let emptyVttFile:TextTrack? = self.createEmptyVttFile()
+        if (emptyVttFile != nil) {
+            validTextTracks.append(emptyVttFile!)
+        }
+        
+        return validTextTracks
+    }
+
+    /*
+     * Create an useless / almost empty VTT file in the list with available tracks. This track gets selected when you give type: "disabled" as the selectedTextTrack
+     * This is needed because there is a bug where sideloaded texttracks cannot be disabled in the AVPlayer. Loading this VTT file instead solves that problem.
+     * For more info see: https://github.com/react-native-community/react-native-video/issues/1144
+     */
+    static func createEmptyVttFile() -> TextTrack? {
+        let fileManager = FileManager.default
+        let cachesDirectoryUrl = fileManager.urls(for: .cachesDirectory, in: .userDomainMask)[0]
+        let filePath = cachesDirectoryUrl.appendingPathComponent("empty.vtt").path
+        
+        if !fileManager.fileExists(atPath: filePath) {
+            let stringToWrite = "WEBVTT\n\n1\n99:59:59.000 --> 99:59:59.001\n."
+
+            do {
+                try stringToWrite.write(to: URL(fileURLWithPath: filePath), atomically: true, encoding: String.Encoding.utf8)
+            } catch {
+                return nil
+            }
+        }
+        
+        return TextTrack([
+            "language": "disabled",
+            "title": "EmptyVttFile",
+            "type": "text/vtt",
+            "uri": filePath,
+        ])
+    }
+    
+    static func delay(seconds: Int = 0) -> Promise<Void> {
+        return Promise<Void>(on: .global()) { fulfill, reject in
+            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + Double(Int64(seconds)) / Double(NSEC_PER_SEC), execute: {
+                fulfill(())
+            })
+        }
+    }
+    
+    static func preparePHAsset(uri: String) -> Promise<AVAsset?> {
+        return Promise<AVAsset?>(on: .global()) { fulfill, reject in
+            let assetId = String(uri[uri.index(uri.startIndex, offsetBy: "ph://".count)...])
+            guard let phAsset = PHAsset.fetchAssets(withLocalIdentifiers: [assetId], options: nil).firstObject else {
+                reject(NSError(domain: "", code: 0, userInfo: nil))
+                return
+            }
+            let options = PHVideoRequestOptions()
+            options.isNetworkAccessAllowed = true
+            PHCachingImageManager().requestAVAsset(forVideo: phAsset, options: options) { data, _, _ in
+                fulfill(data)
+            }
+        }
+    }
+    
+    static func prepareAsset(source:VideoSource) -> (asset:AVURLAsset?, assetOptions:NSMutableDictionary?)? {
+        guard let sourceUri = source.uri, sourceUri != "" else { return nil }
+        var asset:AVURLAsset!
+        let bundlePath = Bundle.main.path(forResource: source.uri, ofType: source.type) ?? ""
+        let url = source.isNetwork || source.isAsset
+        ? URL(string: source.uri ?? "")
+        : URL(fileURLWithPath: bundlePath)
+        let assetOptions:NSMutableDictionary! = NSMutableDictionary()
+        
+        if source.isNetwork {
+            if let headers = source.requestHeaders, headers.count > 0 {
+                assetOptions.setObject(headers, forKey:"AVURLAssetHTTPHeaderFieldsKey" as NSCopying)
+            }
+            let cookies:[AnyObject]! = HTTPCookieStorage.shared.cookies
+            assetOptions.setObject(cookies, forKey:AVURLAssetHTTPCookiesKey as NSCopying)
+            asset = AVURLAsset(url: url!, options:assetOptions as! [String : Any])
+        } else {
+            asset = AVURLAsset(url: url!)
+        }
+        return (asset, assetOptions)
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/RCTVideo-Bridging-Header.h b/node_modules/react-native-video/ios/Video/RCTVideo-Bridging-Header.h
new file mode 100644
index 0000000..586eec1
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/RCTVideo-Bridging-Header.h
@@ -0,0 +1,8 @@
+#import <React/RCTViewManager.h>
+#import "RCTVideoSwiftLog.h"
+#import "RCTEventDispatcher.h"
+
+#if __has_include(<react-native-video/RCTVideoCache.h>)
+#import "RCTVideoCache.h"
+#endif
+
diff --git a/node_modules/react-native-video/ios/Video/RCTVideo.h b/node_modules/react-native-video/ios/Video/RCTVideo.h
deleted file mode 100644
index 6fee299..0000000
--- a/node_modules/react-native-video/ios/Video/RCTVideo.h
+++ /dev/null
@@ -1,67 +0,0 @@
-#import <AVFoundation/AVFoundation.h>
-#import "AVKit/AVKit.h"
-#import "UIView+FindUIViewController.h"
-#import "RCTVideoPlayerViewController.h"
-#import "RCTVideoPlayerViewControllerDelegate.h"
-#import <React/RCTComponent.h>
-#import <React/RCTBridgeModule.h>
-
-#if __has_include(<react-native-video/RCTVideoCache.h>)
-#import <react-native-video/RCTVideoCache.h>
-#import <DVAssetLoaderDelegate/DVURLAsset.h>
-#import <DVAssetLoaderDelegate/DVAssetLoaderDelegate.h>
-#endif
-
-@class RCTEventDispatcher;
-#if __has_include(<react-native-video/RCTVideoCache.h>)
-@interface RCTVideo : UIView <RCTVideoPlayerViewControllerDelegate, DVAssetLoaderDelegatesDelegate, AVAssetResourceLoaderDelegate>
-#elif TARGET_OS_TV
-@interface RCTVideo : UIView <RCTVideoPlayerViewControllerDelegate, AVAssetResourceLoaderDelegate>
-#else
-@interface RCTVideo : UIView <RCTVideoPlayerViewControllerDelegate, AVPictureInPictureControllerDelegate, AVAssetResourceLoaderDelegate>
-#endif
-
-@property (nonatomic, copy) RCTDirectEventBlock onVideoLoadStart;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoLoad;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoBuffer;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoError;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoProgress;
-@property (nonatomic, copy) RCTDirectEventBlock onBandwidthUpdate;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoSeek;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoEnd;
-@property (nonatomic, copy) RCTDirectEventBlock onTimedMetadata;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoAudioBecomingNoisy;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoFullscreenPlayerWillPresent;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoFullscreenPlayerDidPresent;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoFullscreenPlayerWillDismiss;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoFullscreenPlayerDidDismiss;
-@property (nonatomic, copy) RCTDirectEventBlock onReadyForDisplay;
-@property (nonatomic, copy) RCTDirectEventBlock onPlaybackStalled;
-@property (nonatomic, copy) RCTDirectEventBlock onPlaybackResume;
-@property (nonatomic, copy) RCTDirectEventBlock onPlaybackRateChange;
-@property (nonatomic, copy) RCTDirectEventBlock onVideoExternalPlaybackChange;
-@property (nonatomic, copy) RCTDirectEventBlock onPictureInPictureStatusChanged;
-@property (nonatomic, copy) RCTDirectEventBlock onRestoreUserInterfaceForPictureInPictureStop;
-@property (nonatomic, copy) RCTDirectEventBlock onGetLicense;
-
-typedef NS_ENUM(NSInteger, RCTVideoError) {
-    RCTVideoErrorFromJSPart,
-    RCTVideoErrorLicenseRequestNotOk,
-    RCTVideoErrorNoDataFromLicenseRequest,
-    RCTVideoErrorNoSPC,
-    RCTVideoErrorNoDataRequest,
-    RCTVideoErrorNoCertificateData,
-    RCTVideoErrorNoCertificateURL,
-    RCTVideoErrorNoFairplayDRM,
-    RCTVideoErrorNoDRMData
-};
-
-- (instancetype)initWithEventDispatcher:(RCTEventDispatcher *)eventDispatcher NS_DESIGNATED_INITIALIZER;
-
-- (AVPlayerViewController*)createPlayerViewController:(AVPlayer*)player withPlayerItem:(AVPlayerItem*)playerItem;
-
-- (void)save:(NSDictionary *)options resolve:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject;
-- (void)setLicenseResult:(NSString * )license;
-- (BOOL)setLicenseResultError:(NSString * )error;
-
-@end
diff --git a/node_modules/react-native-video/ios/Video/RCTVideo.m b/node_modules/react-native-video/ios/Video/RCTVideo.m
deleted file mode 100644
index a757c08..0000000
--- a/node_modules/react-native-video/ios/Video/RCTVideo.m
+++ /dev/null
@@ -1,2031 +0,0 @@
-#import <React/RCTConvert.h>
-#import "RCTVideo.h"
-#import <React/RCTBridgeModule.h>
-#import <React/RCTEventDispatcher.h>
-#import <React/UIView+React.h>
-#include <MediaAccessibility/MediaAccessibility.h>
-#include <AVFoundation/AVFoundation.h>
-
-static NSString *const statusKeyPath = @"status";
-static NSString *const playbackLikelyToKeepUpKeyPath = @"playbackLikelyToKeepUp";
-static NSString *const playbackBufferEmptyKeyPath = @"playbackBufferEmpty";
-static NSString *const readyForDisplayKeyPath = @"readyForDisplay";
-static NSString *const playbackRate = @"rate";
-static NSString *const timedMetadata = @"timedMetadata";
-static NSString *const externalPlaybackActive = @"externalPlaybackActive";
-
-static int const RCTVideoUnset = -1;
-
-#ifdef DEBUG
-    #define DebugLog(...) NSLog(__VA_ARGS__)
-#else
-    #define DebugLog(...) (void)0
-#endif
-
-@implementation RCTVideo
-{
-  AVPlayer *_player;
-  AVPlayerItem *_playerItem;
-  NSDictionary *_source;
-  BOOL _playerItemObserversSet;
-  BOOL _playerBufferEmpty;
-  AVPlayerLayer *_playerLayer;
-  BOOL _playerLayerObserverSet;
-  RCTVideoPlayerViewController *_playerViewController;
-  NSURL *_videoURL;
-  BOOL _requestingCertificate;
-  BOOL _requestingCertificateErrored;
-  
-  /* DRM */
-  NSDictionary *_drm;
-  AVAssetResourceLoadingRequest *_loadingRequest;
-  
-  /* Required to publish events */
-  RCTEventDispatcher *_eventDispatcher;
-  BOOL _playbackRateObserverRegistered;
-  BOOL _isExternalPlaybackActiveObserverRegistered;
-  BOOL _videoLoadStarted;
-  
-  bool _pendingSeek;
-  float _pendingSeekTime;
-  float _lastSeekTime;
-  
-  /* For sending videoProgress events */
-  Float64 _progressUpdateInterval;
-  BOOL _controls;
-  id _timeObserver;
-  
-  /* Keep track of any modifiers, need to be applied after each play */
-  float _volume;
-  float _rate;
-  float _maxBitRate;
-
-  BOOL _automaticallyWaitsToMinimizeStalling;
-  BOOL _muted;
-  BOOL _paused;
-  BOOL _repeat;
-  BOOL _allowsExternalPlayback;
-  NSArray * _textTracks;
-  NSDictionary * _selectedTextTrack;
-  NSDictionary * _selectedAudioTrack;
-  BOOL _playbackStalled;
-  BOOL _playInBackground;
-  BOOL _preventsDisplaySleepDuringVideoPlayback;
-  float _preferredForwardBufferDuration;
-  BOOL _playWhenInactive;
-  BOOL _pictureInPicture;
-  NSString * _ignoreSilentSwitch;
-  NSString * _mixWithOthers;
-  NSString * _resizeMode;
-  BOOL _fullscreen;
-  BOOL _fullscreenAutorotate;
-  NSString * _fullscreenOrientation;
-  BOOL _fullscreenPlayerPresented;
-  NSString *_filterName;
-  BOOL _filterEnabled;
-  UIViewController * _presentingViewController;
-#if __has_include(<react-native-video/RCTVideoCache.h>)
-  RCTVideoCache * _videoCache;
-#endif
-#if TARGET_OS_IOS
-  void (^__strong _Nonnull _restoreUserInterfaceForPIPStopCompletionHandler)(BOOL);
-  AVPictureInPictureController *_pipController;
-#endif
-}
-
-- (instancetype)initWithEventDispatcher:(RCTEventDispatcher *)eventDispatcher
-{
-  if ((self = [super init])) {
-    _eventDispatcher = eventDispatcher;
-	  _automaticallyWaitsToMinimizeStalling = YES;
-    _playbackRateObserverRegistered = NO;
-    _isExternalPlaybackActiveObserverRegistered = NO;
-    _playbackStalled = NO;
-    _rate = 1.0;
-    _volume = 1.0;
-    _resizeMode = @"AVLayerVideoGravityResizeAspectFill";
-    _fullscreenAutorotate = YES;
-    _fullscreenOrientation = @"all";
-    _pendingSeek = false;
-    _pendingSeekTime = 0.0f;
-    _lastSeekTime = 0.0f;
-    _progressUpdateInterval = 250;
-    _controls = NO;
-    _playerBufferEmpty = YES;
-    _playInBackground = false;
-    _preventsDisplaySleepDuringVideoPlayback = true;
-    _preferredForwardBufferDuration = 0.0f;
-    _allowsExternalPlayback = YES;
-    _playWhenInactive = false;
-    _pictureInPicture = false;
-    _ignoreSilentSwitch = @"inherit"; // inherit, ignore, obey
-    _mixWithOthers = @"inherit"; // inherit, mix, duck
-#if TARGET_OS_IOS
-    _restoreUserInterfaceForPIPStopCompletionHandler = NULL;
-#endif
-#if __has_include(<react-native-video/RCTVideoCache.h>)
-    _videoCache = [RCTVideoCache sharedInstance];
-#endif
-    [[NSNotificationCenter defaultCenter] addObserver:self
-                                             selector:@selector(applicationWillResignActive:)
-                                                 name:UIApplicationWillResignActiveNotification
-                                               object:nil];
-    
-    [[NSNotificationCenter defaultCenter] addObserver:self
-                                             selector:@selector(applicationDidEnterBackground:)
-                                                 name:UIApplicationDidEnterBackgroundNotification
-                                               object:nil];
-    
-    [[NSNotificationCenter defaultCenter] addObserver:self
-                                             selector:@selector(applicationWillEnterForeground:)
-                                                 name:UIApplicationWillEnterForegroundNotification
-                                               object:nil];
-    
-    [[NSNotificationCenter defaultCenter] addObserver:self
-                                             selector:@selector(audioRouteChanged:)
-                                                 name:AVAudioSessionRouteChangeNotification
-                                               object:nil];
-  }
-  
-  return self;
-}
-
-- (RCTVideoPlayerViewController*)createPlayerViewController:(AVPlayer*)player
-                                             withPlayerItem:(AVPlayerItem*)playerItem {
-  RCTVideoPlayerViewController* viewController = [[RCTVideoPlayerViewController alloc] init];
-  viewController.showsPlaybackControls = YES;
-  viewController.rctDelegate = self;
-  viewController.preferredOrientation = _fullscreenOrientation;
-  
-  viewController.view.frame = self.bounds;
-  viewController.player = player;
-  return viewController;
-}
-
-/* ---------------------------------------------------------
- **  Get the duration for a AVPlayerItem.
- ** ------------------------------------------------------- */
-
-- (CMTime)playerItemDuration
-{
-  AVPlayerItem *playerItem = [_player currentItem];
-  if (playerItem.status == AVPlayerItemStatusReadyToPlay)
-  {
-    return([playerItem duration]);
-  }
-  
-  return(kCMTimeInvalid);
-}
-
-- (CMTimeRange)playerItemSeekableTimeRange
-{
-  AVPlayerItem *playerItem = [_player currentItem];
-  if (playerItem.status == AVPlayerItemStatusReadyToPlay)
-  {
-    return [playerItem seekableTimeRanges].firstObject.CMTimeRangeValue;
-  }
-  
-  return (kCMTimeRangeZero);
-}
-
--(void)addPlayerTimeObserver
-{
-  const Float64 progressUpdateIntervalMS = _progressUpdateInterval / 1000;
-  // @see endScrubbing in AVPlayerDemoPlaybackViewController.m
-  // of https://developer.apple.com/library/ios/samplecode/AVPlayerDemo/Introduction/Intro.html
-  __weak RCTVideo *weakSelf = self;
-  _timeObserver = [_player addPeriodicTimeObserverForInterval:CMTimeMakeWithSeconds(progressUpdateIntervalMS, NSEC_PER_SEC)
-                                                        queue:NULL
-                                                   usingBlock:^(CMTime time) { [weakSelf sendProgressUpdate]; }
-                   ];
-}
-
-/* Cancels the previously registered time observer. */
--(void)removePlayerTimeObserver
-{
-  if (_timeObserver)
-  {
-    [_player removeTimeObserver:_timeObserver];
-    _timeObserver = nil;
-  }
-}
-
-#pragma mark - Progress
-
-- (void)dealloc
-{
-  [[NSNotificationCenter defaultCenter] removeObserver:self];
-  [self removePlayerLayer];
-  [self removePlayerItemObservers];
-  [_player removeObserver:self forKeyPath:playbackRate context:nil];
-  [_player removeObserver:self forKeyPath:externalPlaybackActive context: nil];
-}
-
-#pragma mark - App lifecycle handlers
-
-- (void)applicationWillResignActive:(NSNotification *)notification
-{
-  if (_playInBackground || _playWhenInactive || _paused) return;
-  
-  [_player pause];
-  [_player setRate:0.0];
-}
-
-- (void)applicationDidEnterBackground:(NSNotification *)notification
-{
-  if (_playInBackground) {
-    // Needed to play sound in background. See https://developer.apple.com/library/ios/qa/qa1668/_index.html
-    [_playerLayer setPlayer:nil];
-    [_playerViewController setPlayer:nil];
-  }
-}
-
-- (void)applicationWillEnterForeground:(NSNotification *)notification
-{
-  [self applyModifiers];
-  if (_playInBackground) {
-    [_playerLayer setPlayer:_player];
-    [_playerViewController setPlayer:_player];
-  }
-}
-
-#pragma mark - Audio events
-
-- (void)audioRouteChanged:(NSNotification *)notification
-{
-  NSNumber *reason = [[notification userInfo] objectForKey:AVAudioSessionRouteChangeReasonKey];
-  NSNumber *previousRoute = [[notification userInfo] objectForKey:AVAudioSessionRouteChangePreviousRouteKey];
-  if (reason.unsignedIntValue == AVAudioSessionRouteChangeReasonOldDeviceUnavailable) {
-    self.onVideoAudioBecomingNoisy(@{@"target": self.reactTag});
-  }
-}
-
-#pragma mark - Progress
-
-- (void)sendProgressUpdate
-{
-  AVPlayerItem *video = [_player currentItem];
-  if (video == nil || video.status != AVPlayerItemStatusReadyToPlay) {
-    return;
-  }
-  
-  CMTime playerDuration = [self playerItemDuration];
-  if (CMTIME_IS_INVALID(playerDuration)) {
-    return;
-  }
-  
-  CMTime currentTime = _player.currentTime;
-  NSDate *currentPlaybackTime = _player.currentItem.currentDate;
-  const Float64 duration = CMTimeGetSeconds(playerDuration);
-  const Float64 currentTimeSecs = CMTimeGetSeconds(currentTime);
-  
-  [[NSNotificationCenter defaultCenter] postNotificationName:@"RCTVideo_progress" object:nil userInfo:@{@"progress": [NSNumber numberWithDouble: currentTimeSecs / duration]}];
-  
-  if( currentTimeSecs >= 0 && self.onVideoProgress) {
-    self.onVideoProgress(@{
-                           @"currentTime": [NSNumber numberWithFloat:CMTimeGetSeconds(currentTime)],
-                           @"playableDuration": [self calculatePlayableDuration],
-                           @"atValue": [NSNumber numberWithLongLong:currentTime.value],
-                           @"atTimescale": [NSNumber numberWithInt:currentTime.timescale],
-                           @"currentPlaybackTime": [NSNumber numberWithLongLong:[@(floor([currentPlaybackTime timeIntervalSince1970] * 1000)) longLongValue]],
-                           @"target": self.reactTag,
-                           @"seekableDuration": [self calculateSeekableDuration],
-                           });
-  }
-}
-
-/*!
- * Calculates and returns the playable duration of the current player item using its loaded time ranges.
- *
- * \returns The playable duration of the current player item in seconds.
- */
-- (NSNumber *)calculatePlayableDuration
-{
-  AVPlayerItem *video = _player.currentItem;
-  if (video.status == AVPlayerItemStatusReadyToPlay) {
-    __block CMTimeRange effectiveTimeRange;
-    [video.loadedTimeRanges enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
-      CMTimeRange timeRange = [obj CMTimeRangeValue];
-      if (CMTimeRangeContainsTime(timeRange, video.currentTime)) {
-        effectiveTimeRange = timeRange;
-        *stop = YES;
-      }
-    }];
-    Float64 playableDuration = CMTimeGetSeconds(CMTimeRangeGetEnd(effectiveTimeRange));
-    if (playableDuration > 0) {
-      return [NSNumber numberWithFloat:playableDuration];
-    }
-  }
-  return [NSNumber numberWithInteger:0];
-}
-
-- (NSNumber *)calculateSeekableDuration
-{
-  CMTimeRange timeRange = [self playerItemSeekableTimeRange];
-  if (CMTIME_IS_NUMERIC(timeRange.duration))
-  {
-    return [NSNumber numberWithFloat:CMTimeGetSeconds(timeRange.duration)];
-  }
-  return [NSNumber numberWithInteger:0];
-}
-
-- (void)addPlayerItemObservers
-{
-  [_playerItem addObserver:self forKeyPath:statusKeyPath options:0 context:nil];
-  [_playerItem addObserver:self forKeyPath:playbackBufferEmptyKeyPath options:0 context:nil];
-  [_playerItem addObserver:self forKeyPath:playbackLikelyToKeepUpKeyPath options:0 context:nil];
-  [_playerItem addObserver:self forKeyPath:timedMetadata options:NSKeyValueObservingOptionNew context:nil];
-  _playerItemObserversSet = YES;
-}
-
-/* Fixes https://github.com/brentvatne/react-native-video/issues/43
- * Crashes caused when trying to remove the observer when there is no
- * observer set */
-- (void)removePlayerItemObservers
-{
-  if (_playerItemObserversSet) {
-    [_playerItem removeObserver:self forKeyPath:statusKeyPath];
-    [_playerItem removeObserver:self forKeyPath:playbackBufferEmptyKeyPath];
-    [_playerItem removeObserver:self forKeyPath:playbackLikelyToKeepUpKeyPath];
-    [_playerItem removeObserver:self forKeyPath:timedMetadata];
-    _playerItemObserversSet = NO;
-  }
-}
-
-#pragma mark - Player and source
-
-- (void)setSrc:(NSDictionary *)source
-{
-  _source = source;
-  [self removePlayerLayer];
-  [self removePlayerTimeObserver];
-  [self removePlayerItemObservers];
-  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t) 0), dispatch_get_main_queue(), ^{
-    
-    // perform on next run loop, otherwise other passed react-props may not be set
-    [self playerItemForSource:self->_source withCallback:^(AVPlayerItem * playerItem) {
-      self->_playerItem = playerItem;
-      _playerItem = playerItem;
-      [self setPreferredForwardBufferDuration:_preferredForwardBufferDuration];
-      [self addPlayerItemObservers];
-      [self setFilter:self->_filterName];
-      [self setMaxBitRate:self->_maxBitRate];
-      
-      [_player pause];
-        
-      if (_playbackRateObserverRegistered) {
-        [_player removeObserver:self forKeyPath:playbackRate context:nil];
-        _playbackRateObserverRegistered = NO;
-      }
-      if (self->_isExternalPlaybackActiveObserverRegistered) {
-        [self->_player removeObserver:self forKeyPath:externalPlaybackActive context:nil];
-        self->_isExternalPlaybackActiveObserverRegistered = NO;
-      }
-      
-      self->_player = [AVPlayer playerWithPlayerItem:self->_playerItem];
-      self->_player.actionAtItemEnd = AVPlayerActionAtItemEndNone;
-      
-      [self->_player addObserver:self forKeyPath:playbackRate options:0 context:nil];
-      self->_playbackRateObserverRegistered = YES;
-      
-      [self->_player addObserver:self forKeyPath:externalPlaybackActive options:0 context:nil];
-      self->_isExternalPlaybackActiveObserverRegistered = YES;
-      
-      [self addPlayerTimeObserver];
-      if (@available(iOS 10.0, *)) {
-        [self setAutomaticallyWaitsToMinimizeStalling:_automaticallyWaitsToMinimizeStalling];
-      }
-
-      //Perform on next run loop, otherwise onVideoLoadStart is nil
-      if (self.onVideoLoadStart) {
-        id uri = [self->_source objectForKey:@"uri"];
-        id type = [self->_source objectForKey:@"type"];
-        self.onVideoLoadStart(@{@"src": @{
-                                    @"uri": uri ? uri : [NSNull null],
-                                    @"type": type ? type : [NSNull null],
-                                    @"isNetwork": [NSNumber numberWithBool:(bool)[self->_source objectForKey:@"isNetwork"]]},
-                                @"drm": self->_drm ? self->_drm : [NSNull null],
-                                @"target": self.reactTag
-                                });
-      }
-    }];
-  });
-  _videoLoadStarted = YES;
-}
-
-- (void)setDrm:(NSDictionary *)drm {
-  _drm = drm;
-}
-
-- (NSURL*) urlFilePath:(NSString*) filepath {
-  if ([filepath containsString:@"file://"]) {
-    return [NSURL URLWithString:filepath];
-  }
-  
-  // if no file found, check if the file exists in the Document directory
-  NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
-  NSString* relativeFilePath = [filepath lastPathComponent];
-  // the file may be multiple levels below the documents directory
-  NSArray* fileComponents = [filepath componentsSeparatedByString:@"Documents/"];
-  if (fileComponents.count > 1) {
-    relativeFilePath = [fileComponents objectAtIndex:1];
-  }
-  
-  NSString *path = [paths.firstObject stringByAppendingPathComponent:relativeFilePath];
-  if ([[NSFileManager defaultManager] fileExistsAtPath:path]) {
-    return [NSURL fileURLWithPath:path];
-  }
-  return nil;
-}
-
-- (void)playerItemPrepareText:(AVAsset *)asset assetOptions:(NSDictionary * __nullable)assetOptions withCallback:(void(^)(AVPlayerItem *))handler
-{
-  if (!_textTracks || _textTracks.count==0) {
-    handler([AVPlayerItem playerItemWithAsset:asset]);
-    return;
-  }
-  
-  // AVPlayer can't airplay AVMutableCompositions
-  _allowsExternalPlayback = NO;
-  
-  // sideload text tracks
-  AVMutableComposition *mixComposition = [[AVMutableComposition alloc] init];
-  
-  AVAssetTrack *videoAsset = [asset tracksWithMediaType:AVMediaTypeVideo].firstObject;
-  AVMutableCompositionTrack *videoCompTrack = [mixComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];
-  [videoCompTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset.timeRange.duration)
-                          ofTrack:videoAsset
-                           atTime:kCMTimeZero
-                            error:nil];
-  
-  AVAssetTrack *audioAsset = [asset tracksWithMediaType:AVMediaTypeAudio].firstObject;
-  AVMutableCompositionTrack *audioCompTrack = [mixComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];
-  [audioCompTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset.timeRange.duration)
-                          ofTrack:audioAsset
-                           atTime:kCMTimeZero
-                            error:nil];
-  
-  NSMutableArray* validTextTracks = [NSMutableArray array];
-  for (int i = 0; i < _textTracks.count; ++i) {
-    AVURLAsset *textURLAsset;
-    NSString *textUri = [_textTracks objectAtIndex:i][@"uri"];
-    if ([[textUri lowercaseString] hasPrefix:@"http"]) {
-      textURLAsset = [AVURLAsset URLAssetWithURL:[NSURL URLWithString:textUri] options:assetOptions];
-    } else {
-      textURLAsset = [AVURLAsset URLAssetWithURL:[self urlFilePath:textUri] options:nil];
-    }
-    AVAssetTrack *textTrackAsset = [textURLAsset tracksWithMediaType:AVMediaTypeText].firstObject;
-    if (!textTrackAsset) continue; // fix when there's no textTrackAsset
-    [validTextTracks addObject:[_textTracks objectAtIndex:i]];
-    AVMutableCompositionTrack *textCompTrack = [mixComposition
-                                                addMutableTrackWithMediaType:AVMediaTypeText
-                                                preferredTrackID:kCMPersistentTrackID_Invalid];
-    [textCompTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset.timeRange.duration)
-                           ofTrack:textTrackAsset
-                            atTime:kCMTimeZero
-                             error:nil];
-  }
-  if (validTextTracks.count != _textTracks.count) {
-    [self setTextTracks:validTextTracks];
-  }
-  
-  handler([AVPlayerItem playerItemWithAsset:mixComposition]);
-}
-
-- (void)playerItemForSource:(NSDictionary *)source withCallback:(void(^)(AVPlayerItem *))handler
-{
-  bool isNetwork = [RCTConvert BOOL:[source objectForKey:@"isNetwork"]];
-  bool isAsset = [RCTConvert BOOL:[source objectForKey:@"isAsset"]];
-  bool shouldCache = [RCTConvert BOOL:[source objectForKey:@"shouldCache"]];
-  NSString *uri = [source objectForKey:@"uri"];
-  NSString *type = [source objectForKey:@"type"];
-  AVURLAsset *asset;
-  if (!uri || [uri isEqualToString:@""]) {
-    DebugLog(@"Could not find video URL in source '%@'", source);
-    return;
-  }
-  
-  NSURL *url = isNetwork || isAsset
-    ? [NSURL URLWithString:uri]
-    : [[NSURL alloc] initFileURLWithPath:[[NSBundle mainBundle] pathForResource:uri ofType:type]];
-  NSMutableDictionary *assetOptions = [[NSMutableDictionary alloc] init];
-  
-  if (isNetwork) {
-    NSDictionary *headers = [source objectForKey:@"requestHeaders"];
-    if ([headers count] > 0) {
-      [assetOptions setObject:headers forKey:@"AVURLAssetHTTPHeaderFieldsKey"];
-    }
-    NSArray *cookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies];
-    [assetOptions setObject:cookies forKey:AVURLAssetHTTPCookiesKey];
-    
-#if __has_include(<react-native-video/RCTVideoCache.h>)
-    if (shouldCache && (!_textTracks || !_textTracks.count)) {
-      /* The DVURLAsset created by cache doesn't have a tracksWithMediaType property, so trying
-       * to bring in the text track code will crash. I suspect this is because the asset hasn't fully loaded.
-       * Until this is fixed, we need to bypass caching when text tracks are specified.
-       */
-      DebugLog(@"Caching is not supported for uri '%@' because text tracks are not compatible with the cache. Checkout https://github.com/react-native-community/react-native-video/blob/master/docs/caching.md", uri);
-      [self playerItemForSourceUsingCache:uri assetOptions:assetOptions withCallback:handler];
-      return;
-    }
-#endif
-    
-    asset = [AVURLAsset URLAssetWithURL:url options:assetOptions];
-  } else if (isAsset) {
-    asset = [AVURLAsset URLAssetWithURL:url options:nil];
-  } else {
-    asset = [AVURLAsset URLAssetWithURL:[[NSURL alloc] initFileURLWithPath:[[NSBundle mainBundle] pathForResource:uri ofType:type]] options:nil];
-  }
-  // Reset _loadingRequest
-  if (_loadingRequest != nil) {
-    [_loadingRequest finishLoading];
-  }
-  _requestingCertificate = NO;
-  _requestingCertificateErrored = NO;
-  // End Reset _loadingRequest
-  if (self->_drm != nil) {
-    dispatch_queue_t queue = dispatch_queue_create("assetQueue", nil);
-    [asset.resourceLoader setDelegate:self queue:queue];
-  }
-  
-  [self playerItemPrepareText:asset assetOptions:assetOptions withCallback:handler];
-}
-
-#if __has_include(<react-native-video/RCTVideoCache.h>)
-
-- (void)playerItemForSourceUsingCache:(NSString *)uri assetOptions:(NSDictionary *)options withCallback:(void(^)(AVPlayerItem *))handler {
-  NSURL *url = [NSURL URLWithString:uri];
-  [_videoCache getItemForUri:uri withCallback:^(RCTVideoCacheStatus videoCacheStatus, AVAsset * _Nullable cachedAsset) {
-    switch (videoCacheStatus) {
-      case RCTVideoCacheStatusMissingFileExtension: {
-        DebugLog(@"Could not generate cache key for uri '%@'. It is currently not supported to cache urls that do not include a file extension. The video file will not be cached. Checkout https://github.com/react-native-community/react-native-video/blob/master/docs/caching.md", uri);
-        AVURLAsset *asset = [AVURLAsset URLAssetWithURL:url options:options];
-        [self playerItemPrepareText:asset assetOptions:options withCallback:handler];
-        return;
-      }
-      case RCTVideoCacheStatusUnsupportedFileExtension: {
-        DebugLog(@"Could not generate cache key for uri '%@'. The file extension of that uri is currently not supported. The video file will not be cached. Checkout https://github.com/react-native-community/react-native-video/blob/master/docs/caching.md", uri);
-        AVURLAsset *asset = [AVURLAsset URLAssetWithURL:url options:options];
-        [self playerItemPrepareText:asset assetOptions:options withCallback:handler];
-        return;
-      }
-      default:
-        if (cachedAsset) {
-          DebugLog(@"Playing back uri '%@' from cache", uri);
-          // See note in playerItemForSource about not being able to support text tracks & caching
-          handler([AVPlayerItem playerItemWithAsset:cachedAsset]);
-          return;
-        }
-    }
-    
-    DVURLAsset *asset = [[DVURLAsset alloc] initWithURL:url options:options networkTimeout:10000];
-    asset.loaderDelegate = self;
-    
-    /* More granular code to have control over the DVURLAsset
-     DVAssetLoaderDelegate *resourceLoaderDelegate = [[DVAssetLoaderDelegate alloc] initWithURL:url];
-     resourceLoaderDelegate.delegate = self;
-     NSURLComponents *components = [[NSURLComponents alloc] initWithURL:url resolvingAgainstBaseURL:NO];
-     components.scheme = [DVAssetLoaderDelegate scheme];
-     AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:[components URL] options:options];
-     [asset.resourceLoader setDelegate:resourceLoaderDelegate queue:dispatch_get_main_queue()];
-     */
-    
-    handler([AVPlayerItem playerItemWithAsset:asset]);
-  }];
-}
-
-#pragma mark - DVAssetLoaderDelegate
-
-- (void)dvAssetLoaderDelegate:(DVAssetLoaderDelegate *)loaderDelegate
-                  didLoadData:(NSData *)data
-                       forURL:(NSURL *)url {
-  [_videoCache storeItem:data forUri:[url absoluteString] withCallback:^(BOOL success) {
-    DebugLog(@"Cache data stored successfully 🎉");
-  }];
-}
-
-#endif
-
-- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
-{
-
-  if([keyPath isEqualToString:readyForDisplayKeyPath] && [change objectForKey:NSKeyValueChangeNewKey] && self.onReadyForDisplay) {
-    self.onReadyForDisplay(@{@"target": self.reactTag});
-    return;
-  }
-  if (object == _playerItem) {
-    // When timeMetadata is read the event onTimedMetadata is triggered
-    if ([keyPath isEqualToString:timedMetadata]) {
-      NSArray<AVMetadataItem *> *items = [change objectForKey:@"new"];
-      if (items && ![items isEqual:[NSNull null]] && items.count > 0) {
-        NSMutableArray *array = [NSMutableArray new];
-        for (AVMetadataItem *item in items) {
-          NSString *value = (NSString *)item.value;
-          NSString *identifier = item.identifier;
-          
-          if (![value isEqual: [NSNull null]]) {
-            NSDictionary *dictionary = [[NSDictionary alloc] initWithObjects:@[value, identifier] forKeys:@[@"value", @"identifier"]];
-            
-            [array addObject:dictionary];
-          }
-        }
-        
-        self.onTimedMetadata(@{
-                               @"target": self.reactTag,
-                               @"metadata": array
-                               });
-      }
-    }
-    
-    if ([keyPath isEqualToString:statusKeyPath]) {
-      // Handle player item status change.
-      if (_playerItem.status == AVPlayerItemStatusReadyToPlay) {
-        float duration = CMTimeGetSeconds(_playerItem.asset.duration);
-        
-        if (isnan(duration)) {
-          duration = 0.0;
-        }
-        
-        NSObject *width = @"undefined";
-        NSObject *height = @"undefined";
-        NSString *orientation = @"undefined";
-        
-        if ([_playerItem.asset tracksWithMediaType:AVMediaTypeVideo].count > 0) {
-          AVAssetTrack *videoTrack = [[_playerItem.asset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];
-          width = [NSNumber numberWithFloat:videoTrack.naturalSize.width];
-          height = [NSNumber numberWithFloat:videoTrack.naturalSize.height];
-          CGAffineTransform preferredTransform = [videoTrack preferredTransform];
-          
-          if ((videoTrack.naturalSize.width == preferredTransform.tx
-               && videoTrack.naturalSize.height == preferredTransform.ty)
-              || (preferredTransform.tx == 0 && preferredTransform.ty == 0))
-          {
-            orientation = @"landscape";
-          } else {
-            orientation = @"portrait";
-          }
-        } else if (_playerItem.presentationSize.height) {
-          width = [NSNumber numberWithFloat:_playerItem.presentationSize.width];
-          height = [NSNumber numberWithFloat:_playerItem.presentationSize.height];
-          orientation = _playerItem.presentationSize.width > _playerItem.presentationSize.height ? @"landscape" : @"portrait";
-        }
-
-        if (_pendingSeek) {
-          [self setCurrentTime:_pendingSeekTime];
-          _pendingSeek = false;
-        }
-        
-        if (self.onVideoLoad && _videoLoadStarted) {
-          self.onVideoLoad(@{@"duration": [NSNumber numberWithFloat:duration],
-                             @"currentTime": [NSNumber numberWithFloat:CMTimeGetSeconds(_playerItem.currentTime)],
-                             @"canPlayReverse": [NSNumber numberWithBool:_playerItem.canPlayReverse],
-                             @"canPlayFastForward": [NSNumber numberWithBool:_playerItem.canPlayFastForward],
-                             @"canPlaySlowForward": [NSNumber numberWithBool:_playerItem.canPlaySlowForward],
-                             @"canPlaySlowReverse": [NSNumber numberWithBool:_playerItem.canPlaySlowReverse],
-                             @"canStepBackward": [NSNumber numberWithBool:_playerItem.canStepBackward],
-                             @"canStepForward": [NSNumber numberWithBool:_playerItem.canStepForward],
-                             @"naturalSize": @{
-                                 @"width": width,
-                                 @"height": height,
-                                 @"orientation": orientation
-                                 },
-                             @"audioTracks": [self getAudioTrackInfo],
-                             @"textTracks": [self getTextTrackInfo],
-                             @"target": self.reactTag});
-        }
-        _videoLoadStarted = NO;
-        
-        [self attachListeners];
-        [self applyModifiers];
-      } else if (_playerItem.status == AVPlayerItemStatusFailed && self.onVideoError) {
-        self.onVideoError(@{@"error": @{@"code": [NSNumber numberWithInteger: _playerItem.error.code],
-                                        @"localizedDescription": [_playerItem.error localizedDescription] == nil ? @"" : [_playerItem.error localizedDescription],
-                                        @"localizedFailureReason": [_playerItem.error localizedFailureReason] == nil ? @"" : [_playerItem.error localizedFailureReason],
-                                        @"localizedRecoverySuggestion": [_playerItem.error localizedRecoverySuggestion] == nil ? @"" : [_playerItem.error localizedRecoverySuggestion],
-                                        @"domain": _playerItem != nil && _playerItem.error != nil ? _playerItem.error.domain : @"RTCVideo"},
-                            @"target": self.reactTag});
-      }
-    } else if ([keyPath isEqualToString:playbackBufferEmptyKeyPath]) {
-      _playerBufferEmpty = YES;
-      self.onVideoBuffer(@{@"isBuffering": @(YES), @"target": self.reactTag});
-    } else if ([keyPath isEqualToString:playbackLikelyToKeepUpKeyPath]) {
-      // Continue playing (or not if paused) after being paused due to hitting an unbuffered zone.
-      if ((!(_controls || _fullscreenPlayerPresented) || _playerBufferEmpty) && _playerItem.playbackLikelyToKeepUp) {
-        [self setPaused:_paused];
-      }
-      _playerBufferEmpty = NO;
-      self.onVideoBuffer(@{@"isBuffering": @(NO), @"target": self.reactTag});
-    }
-  } else if (object == _player) {
-    if([keyPath isEqualToString:playbackRate]) {
-      if (_player.rate > 0 && _rate > 0 && _player.rate != _rate) {
-        // Playback is resuming, apply rate modifer.
-        [_player setRate:_rate];
-      } else if(self.onPlaybackRateChange) {
-        self.onPlaybackRateChange(@{@"playbackRate": [NSNumber numberWithFloat:_player.rate],
-                                    @"target": self.reactTag});
-      }
-      if(_playbackStalled && _player.rate > 0) {
-        if(self.onPlaybackResume) {
-          self.onPlaybackResume(@{@"playbackRate": [NSNumber numberWithFloat:_player.rate],
-                                  @"target": self.reactTag});
-        }
-        _playbackStalled = NO;
-      }
-    }
-    else if([keyPath isEqualToString:externalPlaybackActive]) {
-      if(self.onVideoExternalPlaybackChange) {
-        self.onVideoExternalPlaybackChange(@{@"isExternalPlaybackActive": [NSNumber numberWithBool:_player.isExternalPlaybackActive],
-                                             @"target": self.reactTag});
-      }
-    }
-  } else if (object == _playerViewController.contentOverlayView) {
-      // when controls==true, this is a hack to reset the rootview when rotation happens in fullscreen
-      if ([keyPath isEqualToString:@"frame"]) {
-
-        CGRect oldRect = [change[NSKeyValueChangeOldKey] CGRectValue];
-        CGRect newRect = [change[NSKeyValueChangeNewKey] CGRectValue];
-
-        if (!CGRectEqualToRect(oldRect, newRect)) {
-          if (CGRectEqualToRect(newRect, [UIScreen mainScreen].bounds)) {
-            NSLog(@"in fullscreen");
-
-            [self.reactViewController.view setFrame:[UIScreen mainScreen].bounds];
-            [self.reactViewController.view setNeedsLayout];
-          } else NSLog(@"not fullscreen");
-        }
-
-        return;
-      }
-  }
-}
-
-- (void)attachListeners
-{
-  // listen for end of file
-  [[NSNotificationCenter defaultCenter] removeObserver:self
-                                                  name:AVPlayerItemDidPlayToEndTimeNotification
-                                                object:[_player currentItem]];
-  [[NSNotificationCenter defaultCenter] addObserver:self
-                                           selector:@selector(playerItemDidReachEnd:)
-                                               name:AVPlayerItemDidPlayToEndTimeNotification
-                                             object:[_player currentItem]];
-  
-  [[NSNotificationCenter defaultCenter] removeObserver:self
-                                                  name:AVPlayerItemPlaybackStalledNotification
-                                                object:nil];
-  [[NSNotificationCenter defaultCenter] addObserver:self
-                                           selector:@selector(playbackStalled:)
-                                               name:AVPlayerItemPlaybackStalledNotification
-                                             object:nil];
-  
-  [[NSNotificationCenter defaultCenter] removeObserver:self
-                                                  name:AVPlayerItemNewAccessLogEntryNotification
-                                                object:nil];
-  [[NSNotificationCenter defaultCenter] addObserver:self
-                                           selector:@selector(handleAVPlayerAccess:)
-                                               name:AVPlayerItemNewAccessLogEntryNotification
-                                             object:nil];
-  [[NSNotificationCenter defaultCenter] removeObserver:self
-                                                  name: AVPlayerItemFailedToPlayToEndTimeNotification
-                                                object:nil];
-  [[NSNotificationCenter defaultCenter] addObserver:self
-                                           selector:@selector(didFailToFinishPlaying:)
-                                               name: AVPlayerItemFailedToPlayToEndTimeNotification
-                                             object:nil];
-  
-}
-
-- (void)handleAVPlayerAccess:(NSNotification *)notification {
-  AVPlayerItemAccessLog *accessLog = [((AVPlayerItem *)notification.object) accessLog];
-  AVPlayerItemAccessLogEvent *lastEvent = accessLog.events.lastObject;
-  
-  /* TODO: get this working
-   if (self.onBandwidthUpdate) {
-   self.onBandwidthUpdate(@{@"bitrate": [NSNumber numberWithFloat:lastEvent.observedBitrate]});
-   }
-   */
-}
-
-- (void)didFailToFinishPlaying:(NSNotification *)notification {
-  NSError *error = notification.userInfo[AVPlayerItemFailedToPlayToEndTimeErrorKey];
-  self.onVideoError(@{@"error": @{@"code": [NSNumber numberWithInteger: error.code],
-                                  @"localizedDescription": [error localizedDescription] == nil ? @"" : [error localizedDescription],
-                                  @"localizedFailureReason": [error localizedFailureReason] == nil ? @"" : [error localizedFailureReason],
-                                  @"localizedRecoverySuggestion": [error localizedRecoverySuggestion] == nil ? @"" : [error localizedRecoverySuggestion],
-                                  @"domain": error.domain},
-                      @"target": self.reactTag});
-}
-
-- (void)playbackStalled:(NSNotification *)notification
-{
-  if(self.onPlaybackStalled) {
-    self.onPlaybackStalled(@{@"target": self.reactTag});
-  }
-  _playbackStalled = YES;
-}
-
-- (void)playerItemDidReachEnd:(NSNotification *)notification
-{
-  if(self.onVideoEnd) {
-    self.onVideoEnd(@{@"target": self.reactTag});
-  }
-  
-  if (_repeat) {
-    AVPlayerItem *item = [notification object];
-    [item seekToTime:kCMTimeZero];
-    [self applyModifiers];
-  } else {
-    [self removePlayerTimeObserver];
-  }
-}
-
-#pragma mark - Prop setters
-
-- (void)setResizeMode:(NSString*)mode
-{
-  if( _controls )
-  {
-    _playerViewController.videoGravity = mode;
-  }
-  else
-  {
-    _playerLayer.videoGravity = mode;
-  }
-  _resizeMode = mode;
-}
-
-- (void)setPlayInBackground:(BOOL)playInBackground
-{
-  _playInBackground = playInBackground;
-}
-
-- (void)setPreventsDisplaySleepDuringVideoPlayback:(BOOL)preventsDisplaySleepDuringVideoPlayback
-{
-    _preventsDisplaySleepDuringVideoPlayback = preventsDisplaySleepDuringVideoPlayback;
-    [self applyModifiers];
-}
-
-- (void)setAllowsExternalPlayback:(BOOL)allowsExternalPlayback
-{
-  _allowsExternalPlayback = allowsExternalPlayback;
-  _player.allowsExternalPlayback = _allowsExternalPlayback;
-}
-
-- (void)setPlayWhenInactive:(BOOL)playWhenInactive
-{
-  _playWhenInactive = playWhenInactive;
-}
-
-- (void)setPictureInPicture:(BOOL)pictureInPicture
-{
-  #if TARGET_OS_IOS
-  if (_pictureInPicture == pictureInPicture) {
-    return;
-  }
-  
-  _pictureInPicture = pictureInPicture;
-  if (_pipController && _pictureInPicture && ![_pipController isPictureInPictureActive]) {
-    dispatch_async(dispatch_get_main_queue(), ^{
-      [_pipController startPictureInPicture];
-    });
-  } else if (_pipController && !_pictureInPicture && [_pipController isPictureInPictureActive]) {
-    dispatch_async(dispatch_get_main_queue(), ^{
-      [_pipController stopPictureInPicture];
-    });
-  }
-  #endif
-}
-
-#if TARGET_OS_IOS
-- (void)setRestoreUserInterfaceForPIPStopCompletionHandler:(BOOL)restore
-{
-  if (_restoreUserInterfaceForPIPStopCompletionHandler != NULL) {
-    _restoreUserInterfaceForPIPStopCompletionHandler(restore);
-    _restoreUserInterfaceForPIPStopCompletionHandler = NULL;
-  }
-}
-
-- (void)setupPipController {
-  if (!_pipController && _playerLayer && [AVPictureInPictureController isPictureInPictureSupported]) {
-    // Create new controller passing reference to the AVPlayerLayer
-    _pipController = [[AVPictureInPictureController alloc] initWithPlayerLayer:_playerLayer];
-    _pipController.delegate = self;
-  }
-}
-#endif
-
-- (void)setIgnoreSilentSwitch:(NSString *)ignoreSilentSwitch
-{
-  _ignoreSilentSwitch = ignoreSilentSwitch;
-  [self configureAudio];
-  [self applyModifiers];
-}
-
-- (void)setMixWithOthers:(NSString *)mixWithOthers
-{
-  _mixWithOthers = mixWithOthers;
-  [self applyModifiers];
-}
-
-- (void)setPaused:(BOOL)paused
-{
-  if (paused) {
-    [_player pause];
-    [_player setRate:0.0];
-  } else {
-
-    [self configureAudio];
-
-    if (@available(iOS 10.0, *) && !_automaticallyWaitsToMinimizeStalling) {
-      [_player playImmediatelyAtRate:_rate];
-    } else {
-      [_player play];
-      [_player setRate:_rate];
-    }
-    [_player setRate:_rate];
-  }
-  
-  _paused = paused;
-}
-
-- (float)getCurrentTime
-{
-  return _playerItem != NULL ? CMTimeGetSeconds(_playerItem.currentTime) : 0;
-}
-
-- (void)setCurrentTime:(float)currentTime
-{
-  NSDictionary *info = @{
-                         @"time": [NSNumber numberWithFloat:currentTime],
-                         @"tolerance": [NSNumber numberWithInt:100]
-                         };
-  [self setSeek:info];
-}
-
-- (void)setSeek:(NSDictionary *)info
-{
-  NSNumber *seekTime = info[@"time"];
-  NSNumber *seekTolerance = info[@"tolerance"];
-  
-  int timeScale = 1000;
-  
-  AVPlayerItem *item = _player.currentItem;
-  if (item && item.status == AVPlayerItemStatusReadyToPlay) {
-    // TODO check loadedTimeRanges
-    
-    CMTime cmSeekTime = CMTimeMakeWithSeconds([seekTime floatValue], timeScale);
-    CMTime current = item.currentTime;
-    // TODO figure out a good tolerance level
-    CMTime tolerance = CMTimeMake([seekTolerance floatValue], timeScale);
-    BOOL wasPaused = _paused;
-    
-    if (CMTimeCompare(current, cmSeekTime) != 0) {
-      if (!wasPaused) [_player pause];
-      [_player seekToTime:cmSeekTime toleranceBefore:tolerance toleranceAfter:tolerance completionHandler:^(BOOL finished) {
-        if (!_timeObserver) {
-          [self addPlayerTimeObserver];
-        }
-        if (!wasPaused) {
-          [self setPaused:false];
-        }
-        if(self.onVideoSeek) {
-          self.onVideoSeek(@{@"currentTime": [NSNumber numberWithFloat:CMTimeGetSeconds(item.currentTime)],
-                             @"seekTime": seekTime,
-                             @"target": self.reactTag});
-        }
-      }];
-      
-      _pendingSeek = false;
-    }
-    
-  } else {
-    _pendingSeek = true;
-    _pendingSeekTime = [seekTime floatValue];
-  }
-}
-
-- (void)setRate:(float)rate
-{
-  _rate = rate;
-  [self applyModifiers];
-}
-
-- (void)setMuted:(BOOL)muted
-{
-  _muted = muted;
-  [self applyModifiers];
-}
-
-- (void)setVolume:(float)volume
-{
-  _volume = volume;
-  [self applyModifiers];
-}
-
-- (void)setMaxBitRate:(float) maxBitRate {
-  _maxBitRate = maxBitRate;
-  _playerItem.preferredPeakBitRate = maxBitRate;
-}
-
-- (void)setPreferredForwardBufferDuration:(float) preferredForwardBufferDuration
-{
-  _preferredForwardBufferDuration = preferredForwardBufferDuration;
-  _playerItem.preferredForwardBufferDuration = preferredForwardBufferDuration;
-}
-
-- (void)setAutomaticallyWaitsToMinimizeStalling:(BOOL)waits
-{
-	_automaticallyWaitsToMinimizeStalling = waits;
-	_player.automaticallyWaitsToMinimizeStalling = waits;
-}
-
-
-- (void)applyModifiers
-{
-  if (_muted) {
-    if (!_controls) {
-      [_player setVolume:0];
-    }
-    [_player setMuted:YES];
-  } else {
-    [_player setVolume:_volume];
-    [_player setMuted:NO];
-  }
-
-  if (@available(iOS 12.0, *)) {
-      self->_player.preventsDisplaySleepDuringVideoPlayback = _preventsDisplaySleepDuringVideoPlayback;
-  } else {
-      // Fallback on earlier versions
-  }
-  
-  [self setMaxBitRate:_maxBitRate];
-  [self setSelectedAudioTrack:_selectedAudioTrack];
-  [self setSelectedTextTrack:_selectedTextTrack];
-  [self setResizeMode:_resizeMode];
-  [self setRepeat:_repeat];
-  [self setPaused:_paused];
-  [self setControls:_controls];
-  [self setAllowsExternalPlayback:_allowsExternalPlayback];
-}
-
-- (void)configureAudio
-{
-    AVAudioSession *session = [AVAudioSession sharedInstance];
-    AVAudioSessionCategory category = nil;
-    AVAudioSessionCategoryOptions options = nil;
-
-    if([_ignoreSilentSwitch isEqualToString:@"ignore"]) {
-      category = AVAudioSessionCategoryPlayback;
-    } else if([_ignoreSilentSwitch isEqualToString:@"obey"]) {
-      category = AVAudioSessionCategoryAmbient;
-    }
-
-    if([_mixWithOthers isEqualToString:@"mix"]) {
-      options = AVAudioSessionCategoryOptionMixWithOthers;
-    } else if([_mixWithOthers isEqualToString:@"duck"]) {
-      options = AVAudioSessionCategoryOptionDuckOthers;
-    }
-
-    if (category != nil && options != nil) {
-      [session setCategory:category withOptions:options error:nil];
-    } else if (category != nil && options == nil) {
-      [session setCategory:category error:nil];
-    } else if (category == nil && options != nil) {
-      [session setCategory:session.category withOptions:options error:nil];
-    }
-}
-
-- (void)setRepeat:(BOOL)repeat {
-  _repeat = repeat;
-}
-
-- (void)setMediaSelectionTrackForCharacteristic:(AVMediaCharacteristic)characteristic
-                                   withCriteria:(NSDictionary *)criteria
-{
-  NSString *type = criteria[@"type"];
-  AVMediaSelectionGroup *group = [_player.currentItem.asset
-                                  mediaSelectionGroupForMediaCharacteristic:characteristic];
-  AVMediaSelectionOption *mediaOption;
-  
-  if ([type isEqualToString:@"disabled"]) {
-    // Do nothing. We want to ensure option is nil
-  } else if ([type isEqualToString:@"language"] || [type isEqualToString:@"title"]) {
-    NSString *value = criteria[@"value"];
-    for (int i = 0; i < group.options.count; ++i) {
-      AVMediaSelectionOption *currentOption = [group.options objectAtIndex:i];
-      NSString *optionValue;
-      if ([type isEqualToString:@"language"]) {
-        optionValue = [currentOption extendedLanguageTag];
-      } else {
-        optionValue = [[[currentOption commonMetadata]
-                        valueForKey:@"value"]
-                       objectAtIndex:0];
-      }
-      if ([value isEqualToString:optionValue]) {
-        mediaOption = currentOption;
-        break;
-      }
-    }
-    //} else if ([type isEqualToString:@"default"]) {
-    //  option = group.defaultOption; */
-  } else if ([type isEqualToString:@"index"]) {
-    if ([criteria[@"value"] isKindOfClass:[NSNumber class]]) {
-      int index = [criteria[@"value"] intValue];
-      if (group.options.count > index) {
-        mediaOption = [group.options objectAtIndex:index];
-      }
-    }
-  } else { // default. invalid type or "system"
-    #if TARGET_OS_TV
-    // Do noting. Fix for tvOS native audio menu language selector
-    #else
-      [_player.currentItem selectMediaOptionAutomaticallyInMediaSelectionGroup:group];
-      return;
-    #endif
-  }
-
-    #if TARGET_OS_TV
-    // Do noting. Fix for tvOS native audio menu language selector
-    #else
-       // If a match isn't found, option will be nil and text tracks will be disabled
-       [_player.currentItem selectMediaOption:mediaOption inMediaSelectionGroup:group];
-    #endif
-}
-
-- (void)setSelectedAudioTrack:(NSDictionary *)selectedAudioTrack {
-  _selectedAudioTrack = selectedAudioTrack;
-  [self setMediaSelectionTrackForCharacteristic:AVMediaCharacteristicAudible
-                                   withCriteria:_selectedAudioTrack];
-}
-
-- (void)setSelectedTextTrack:(NSDictionary *)selectedTextTrack {
-  _selectedTextTrack = selectedTextTrack;
-  if (_textTracks) { // sideloaded text tracks
-    [self setSideloadedText];
-  } else { // text tracks included in the HLS playlist
-    [self setMediaSelectionTrackForCharacteristic:AVMediaCharacteristicLegible
-                                     withCriteria:_selectedTextTrack];
-  }
-}
-
-- (void) setSideloadedText {
-  NSString *type = _selectedTextTrack[@"type"];
-  NSArray *textTracks = [self getTextTrackInfo];
-  
-  // The first few tracks will be audio & video track
-  int firstTextIndex = 0;
-  for (firstTextIndex = 0; firstTextIndex < _player.currentItem.tracks.count; ++firstTextIndex) {
-    if ([_player.currentItem.tracks[firstTextIndex].assetTrack hasMediaCharacteristic:AVMediaCharacteristicLegible]) {
-      break;
-    }
-  }
-  
-  int selectedTrackIndex = RCTVideoUnset;
-  
-  if ([type isEqualToString:@"disabled"]) {
-    // Do nothing. We want to ensure option is nil
-  } else if ([type isEqualToString:@"language"]) {
-    NSString *selectedValue = _selectedTextTrack[@"value"];
-    for (int i = 0; i < textTracks.count; ++i) {
-      NSDictionary *currentTextTrack = [textTracks objectAtIndex:i];
-      if ([selectedValue isEqualToString:currentTextTrack[@"language"]]) {
-        selectedTrackIndex = i;
-        break;
-      }
-    }
-  } else if ([type isEqualToString:@"title"]) {
-    NSString *selectedValue = _selectedTextTrack[@"value"];
-    for (int i = 0; i < textTracks.count; ++i) {
-      NSDictionary *currentTextTrack = [textTracks objectAtIndex:i];
-      if ([selectedValue isEqualToString:currentTextTrack[@"title"]]) {
-        selectedTrackIndex = i;
-        break;
-      }
-    }
-  } else if ([type isEqualToString:@"index"]) {
-    if ([_selectedTextTrack[@"value"] isKindOfClass:[NSNumber class]]) {
-      int index = [_selectedTextTrack[@"value"] intValue];
-      if (textTracks.count > index) {
-        selectedTrackIndex = index;
-      }
-    }
-  }
-  
-  // in the situation that a selected text track is not available (eg. specifies a textTrack not available)
-  if (![type isEqualToString:@"disabled"] && selectedTrackIndex == RCTVideoUnset) {
-    CFArrayRef captioningMediaCharacteristics = MACaptionAppearanceCopyPreferredCaptioningMediaCharacteristics(kMACaptionAppearanceDomainUser);
-    NSArray *captionSettings = (__bridge NSArray*)captioningMediaCharacteristics;
-    if ([captionSettings containsObject:AVMediaCharacteristicTranscribesSpokenDialogForAccessibility]) {
-      selectedTrackIndex = 0; // If we can't find a match, use the first available track
-      NSString *systemLanguage = [[NSLocale preferredLanguages] firstObject];
-      for (int i = 0; i < textTracks.count; ++i) {
-        NSDictionary *currentTextTrack = [textTracks objectAtIndex:i];
-        if ([systemLanguage isEqualToString:currentTextTrack[@"language"]]) {
-          selectedTrackIndex = i;
-          break;
-        }
-      }
-    }
-  }
-  
-  for (int i = firstTextIndex; i < _player.currentItem.tracks.count; ++i) {
-    BOOL isEnabled = NO;
-    if (selectedTrackIndex != RCTVideoUnset) {
-      isEnabled = i == selectedTrackIndex + firstTextIndex;
-    }
-    [_player.currentItem.tracks[i] setEnabled:isEnabled];
-  }
-}
-
--(void) setStreamingText {
-  NSString *type = _selectedTextTrack[@"type"];
-  AVMediaSelectionGroup *group = [_player.currentItem.asset
-                                  mediaSelectionGroupForMediaCharacteristic:AVMediaCharacteristicLegible];
-  AVMediaSelectionOption *mediaOption;
-  
-  if ([type isEqualToString:@"disabled"]) {
-    // Do nothing. We want to ensure option is nil
-  } else if ([type isEqualToString:@"language"] || [type isEqualToString:@"title"]) {
-    NSString *value = _selectedTextTrack[@"value"];
-    for (int i = 0; i < group.options.count; ++i) {
-      AVMediaSelectionOption *currentOption = [group.options objectAtIndex:i];
-      NSString *optionValue;
-      if ([type isEqualToString:@"language"]) {
-        optionValue = [currentOption extendedLanguageTag];
-      } else {
-        optionValue = [[[currentOption commonMetadata]
-                        valueForKey:@"value"]
-                       objectAtIndex:0];
-      }
-      if ([value isEqualToString:optionValue]) {
-        mediaOption = currentOption;
-        break;
-      }
-    }
-    //} else if ([type isEqualToString:@"default"]) {
-    //  option = group.defaultOption; */
-  } else if ([type isEqualToString:@"index"]) {
-    if ([_selectedTextTrack[@"value"] isKindOfClass:[NSNumber class]]) {
-      int index = [_selectedTextTrack[@"value"] intValue];
-      if (group.options.count > index) {
-        mediaOption = [group.options objectAtIndex:index];
-      }
-    }
-  } else { // default. invalid type or "system"
-    [_player.currentItem selectMediaOptionAutomaticallyInMediaSelectionGroup:group];
-    return;
-  }
-  
-  // If a match isn't found, option will be nil and text tracks will be disabled
-  [_player.currentItem selectMediaOption:mediaOption inMediaSelectionGroup:group];
-}
-
-- (void)setTextTracks:(NSArray*) textTracks;
-{
-  _textTracks = textTracks;
-  
-  // in case textTracks was set after selectedTextTrack
-  if (_selectedTextTrack) [self setSelectedTextTrack:_selectedTextTrack];
-}
-
-- (NSArray *)getAudioTrackInfo
-{
-  NSMutableArray *audioTracks = [[NSMutableArray alloc] init];
-  AVMediaSelectionGroup *group = [_player.currentItem.asset
-                                  mediaSelectionGroupForMediaCharacteristic:AVMediaCharacteristicAudible];
-  for (int i = 0; i < group.options.count; ++i) {
-    AVMediaSelectionOption *currentOption = [group.options objectAtIndex:i];
-    NSString *title = @"";
-    NSArray *values = [[currentOption commonMetadata] valueForKey:@"value"];
-    if (values.count > 0) {
-      title = [values objectAtIndex:0];
-    }
-    NSString *language = [currentOption extendedLanguageTag] ? [currentOption extendedLanguageTag] : @"";
-    NSDictionary *audioTrack = @{
-                                 @"index": [NSNumber numberWithInt:i],
-                                 @"title": title,
-                                 @"language": language
-                                 };
-    [audioTracks addObject:audioTrack];
-  }
-  return audioTracks;
-}
-
-- (NSArray *)getTextTrackInfo
-{
-  // if sideloaded, textTracks will already be set
-  if (_textTracks) return _textTracks;
-  
-  // if streaming video, we extract the text tracks
-  NSMutableArray *textTracks = [[NSMutableArray alloc] init];
-  AVMediaSelectionGroup *group = [_player.currentItem.asset
-                                  mediaSelectionGroupForMediaCharacteristic:AVMediaCharacteristicLegible];
-  for (int i = 0; i < group.options.count; ++i) {
-    AVMediaSelectionOption *currentOption = [group.options objectAtIndex:i];
-    NSString *title = @"";
-    NSArray *values = [[currentOption commonMetadata] valueForKey:@"value"];
-    if (values.count > 0) {
-      title = [values objectAtIndex:0];
-    }
-    NSString *language = [currentOption extendedLanguageTag] ? [currentOption extendedLanguageTag] : @"";
-    NSDictionary *textTrack = @{
-                                @"index": [NSNumber numberWithInt:i],
-                                @"title": title,
-                                @"language": language
-                                };
-    [textTracks addObject:textTrack];
-  }
-  return textTracks;
-}
-
-- (BOOL)getFullscreen
-{
-  return _fullscreenPlayerPresented;
-}
-
-- (void)setFullscreen:(BOOL) fullscreen {
-  if( fullscreen && !_fullscreenPlayerPresented && _player )
-  {
-    // Ensure player view controller is not null
-    if( !_playerViewController )
-    {
-      [self usePlayerViewController];
-    }
-    // Set presentation style to fullscreen
-    [_playerViewController setModalPresentationStyle:UIModalPresentationFullScreen];
-    
-    // Find the nearest view controller
-    UIViewController *viewController = [self firstAvailableUIViewController];
-    if( !viewController )
-    {
-      UIWindow *keyWindow = [[UIApplication sharedApplication] keyWindow];
-      viewController = keyWindow.rootViewController;
-      if( viewController.childViewControllers.count > 0 )
-      {
-        viewController = viewController.childViewControllers.lastObject;
-      }
-    }
-    if( viewController )
-    {
-      _presentingViewController = viewController;
-      if(self.onVideoFullscreenPlayerWillPresent) {
-        self.onVideoFullscreenPlayerWillPresent(@{@"target": self.reactTag});
-      }
-      [viewController presentViewController:_playerViewController animated:true completion:^{
-        _playerViewController.showsPlaybackControls = YES;
-        _fullscreenPlayerPresented = fullscreen;
-        _playerViewController.autorotate = _fullscreenAutorotate;
-        if(self.onVideoFullscreenPlayerDidPresent) {
-          self.onVideoFullscreenPlayerDidPresent(@{@"target": self.reactTag});
-        }
-      }];
-    }
-  }
-  else if ( !fullscreen && _fullscreenPlayerPresented )
-  {
-    [self videoPlayerViewControllerWillDismiss:_playerViewController];
-    [_presentingViewController dismissViewControllerAnimated:true completion:^{
-      [self videoPlayerViewControllerDidDismiss:_playerViewController];
-    }];
-  }
-}
-
-- (void)setFullscreenAutorotate:(BOOL)autorotate {
-  _fullscreenAutorotate = autorotate;
-  if (_fullscreenPlayerPresented) {
-    _playerViewController.autorotate = autorotate;
-  }
-}
-
-- (void)setFullscreenOrientation:(NSString *)orientation {
-  _fullscreenOrientation = orientation;
-  if (_fullscreenPlayerPresented) {
-    _playerViewController.preferredOrientation = orientation;
-  }
-}
-
-- (void)usePlayerViewController
-{
-  if( _player )
-  {
-    if (!_playerViewController) {
-      _playerViewController = [self createPlayerViewController:_player withPlayerItem:_playerItem];
-    }
-    // to prevent video from being animated when resizeMode is 'cover'
-    // resize mode must be set before subview is added
-    [self setResizeMode:_resizeMode];
-    
-    if (_controls) {
-      UIViewController *viewController = [self reactViewController];
-      [viewController addChildViewController:_playerViewController];
-      [self addSubview:_playerViewController.view];
-    }
-      
-    [_playerViewController addObserver:self forKeyPath:readyForDisplayKeyPath options:NSKeyValueObservingOptionNew context:nil];
-    
-    [_playerViewController.contentOverlayView addObserver:self forKeyPath:@"frame" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL];
-  }
-}
-
-- (void)usePlayerLayer
-{
-  if( _player )
-  {
-    _playerLayer = [AVPlayerLayer playerLayerWithPlayer:_player];
-    _playerLayer.frame = self.bounds;
-    _playerLayer.needsDisplayOnBoundsChange = YES;
-    
-    // to prevent video from being animated when resizeMode is 'cover'
-    // resize mode must be set before layer is added
-    [self setResizeMode:_resizeMode];
-    [_playerLayer addObserver:self forKeyPath:readyForDisplayKeyPath options:NSKeyValueObservingOptionNew context:nil];
-    _playerLayerObserverSet = YES;
-    
-    [self.layer addSublayer:_playerLayer];
-    self.layer.needsDisplayOnBoundsChange = YES;
-    #if TARGET_OS_IOS
-    [self setupPipController];
-    #endif
-  }
-}
-
-- (void)setControls:(BOOL)controls
-{
-  if( _controls != controls || (!_playerLayer && !_playerViewController) )
-  {
-    _controls = controls;
-    if( _controls )
-    {
-      [self removePlayerLayer];
-      [self usePlayerViewController];
-    }
-    else
-    {
-      [_playerViewController.view removeFromSuperview];
-      _playerViewController = nil;
-      [self usePlayerLayer];
-    }
-  }
-}
-
-- (void)setProgressUpdateInterval:(float)progressUpdateInterval
-{
-  _progressUpdateInterval = progressUpdateInterval;
-  
-  if (_timeObserver) {
-    [self removePlayerTimeObserver];
-    [self addPlayerTimeObserver];
-  }
-}
-
-- (void)removePlayerLayer
-{
-  if (_loadingRequest != nil) {
-    [_loadingRequest finishLoading];
-  }
-  _requestingCertificate = NO;
-  _requestingCertificateErrored = NO;
-  [_playerLayer removeFromSuperlayer];
-  if (_playerLayerObserverSet) {
-    [_playerLayer removeObserver:self forKeyPath:readyForDisplayKeyPath];
-    _playerLayerObserverSet = NO;
-  }
-  _playerLayer = nil;
-}
-
-#pragma mark - RCTVideoPlayerViewControllerDelegate
-
-- (void)videoPlayerViewControllerWillDismiss:(AVPlayerViewController *)playerViewController
-{
-  if (_playerViewController == playerViewController && _fullscreenPlayerPresented && self.onVideoFullscreenPlayerWillDismiss)
-  {
-    @try{
-      [_playerViewController.contentOverlayView removeObserver:self forKeyPath:@"frame"];
-      [_playerViewController removeObserver:self forKeyPath:readyForDisplayKeyPath];
-    }@catch(id anException){
-    }
-    self.onVideoFullscreenPlayerWillDismiss(@{@"target": self.reactTag});
-  }
-}
-
-- (void)videoPlayerViewControllerDidDismiss:(AVPlayerViewController *)playerViewController
-{
-  if (_playerViewController == playerViewController && _fullscreenPlayerPresented)
-  {
-    _fullscreenPlayerPresented = false;
-    _presentingViewController = nil;
-    _playerViewController = nil;
-    [self applyModifiers];
-    if(self.onVideoFullscreenPlayerDidDismiss) {
-      self.onVideoFullscreenPlayerDidDismiss(@{@"target": self.reactTag});
-    }
-  }
-}
-
-- (void)setFilter:(NSString *)filterName {
-  _filterName = filterName;
-  
-  if (!_filterEnabled) {
-    return;
-  } else if ([[_source objectForKey:@"uri"] rangeOfString:@"m3u8"].location != NSNotFound) {
-    return; // filters don't work for HLS... return
-  } else if (!_playerItem.asset) {
-    return;
-  }
-  
-  CIFilter *filter = [CIFilter filterWithName:filterName];
-  _playerItem.videoComposition = [AVVideoComposition
-                                  videoCompositionWithAsset:_playerItem.asset
-                                  applyingCIFiltersWithHandler:^(AVAsynchronousCIImageFilteringRequest *_Nonnull request) {
-                                    if (filter == nil) {
-                                      [request finishWithImage:request.sourceImage context:nil];
-                                    } else {
-                                      CIImage *image = request.sourceImage.imageByClampingToExtent;
-                                      [filter setValue:image forKey:kCIInputImageKey];
-                                      CIImage *output = [filter.outputImage imageByCroppingToRect:request.sourceImage.extent];
-                                      [request finishWithImage:output context:nil];
-                                    }
-                                  }];
-}
-
-- (void)setFilterEnabled:(BOOL)filterEnabled {
-  _filterEnabled = filterEnabled;
-}
-
-#pragma mark - React View Management
-
-- (void)insertReactSubview:(UIView *)view atIndex:(NSInteger)atIndex
-{
-  // We are early in the game and somebody wants to set a subview.
-  // That can only be in the context of playerViewController.
-  if( !_controls && !_playerLayer && !_playerViewController )
-  {
-    [self setControls:true];
-  }
-  
-  if( _controls )
-  {
-    view.frame = self.bounds;
-    [_playerViewController.contentOverlayView insertSubview:view atIndex:atIndex];
-  }
-  else
-  {
-    RCTLogError(@"video cannot have any subviews");
-  }
-  return;
-}
-
-- (void)removeReactSubview:(UIView *)subview
-{
-  if( _controls )
-  {
-    [subview removeFromSuperview];
-  }
-  else
-  {
-    RCTLogError(@"video cannot have any subviews");
-  }
-  return;
-}
-
-- (void)layoutSubviews
-{
-  [super layoutSubviews];
-  if( _controls )
-  {
-    _playerViewController.view.frame = self.bounds;
-    
-    // also adjust all subviews of contentOverlayView
-    for (UIView* subview in _playerViewController.contentOverlayView.subviews) {
-      subview.frame = self.bounds;
-    }
-  }
-  else
-  {
-    [CATransaction begin];
-    [CATransaction setAnimationDuration:0];
-    _playerLayer.frame = self.bounds;
-    [CATransaction commit];
-  }
-}
-
-#pragma mark - Lifecycle
-
-- (void)removeFromSuperview
-{
-  [_player pause];
-  if (_playbackRateObserverRegistered) {
-    [_player removeObserver:self forKeyPath:playbackRate context:nil];
-    _playbackRateObserverRegistered = NO;
-  }
-  if (_isExternalPlaybackActiveObserverRegistered) {
-    [_player removeObserver:self forKeyPath:externalPlaybackActive context:nil];
-    _isExternalPlaybackActiveObserverRegistered = NO;
-  }
-  _player = nil;
-  
-  [self removePlayerLayer];
-  
-  [_playerViewController.contentOverlayView removeObserver:self forKeyPath:@"frame"];
-  [_playerViewController removeObserver:self forKeyPath:readyForDisplayKeyPath];
-  [_playerViewController.view removeFromSuperview];
-  _playerViewController.rctDelegate = nil;
-  _playerViewController.player = nil;
-  _playerViewController = nil;
-  
-  [self removePlayerTimeObserver];
-  [self removePlayerItemObservers];
-  
-  _eventDispatcher = nil;
-  [[NSNotificationCenter defaultCenter] removeObserver:self];
-  
-  [super removeFromSuperview];
-}
-
-#pragma mark - Export
-
-- (void)save:(NSDictionary *)options resolve:(RCTPromiseResolveBlock)resolve reject:(RCTPromiseRejectBlock)reject {
-  
-  AVAsset *asset = _playerItem.asset;
-  
-  if (asset != nil) {
-    
-    AVAssetExportSession *exportSession = [AVAssetExportSession
-                                           exportSessionWithAsset:asset presetName:AVAssetExportPresetHighestQuality];
-    
-    if (exportSession != nil) {
-      NSString *path = nil;
-      NSArray *array = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
-      path = [self generatePathInDirectory:[[self cacheDirectoryPath] stringByAppendingPathComponent:@"Videos"]
-                             withExtension:@".mp4"];
-      NSURL *url = [NSURL fileURLWithPath:path];
-      exportSession.outputFileType = AVFileTypeMPEG4;
-      exportSession.outputURL = url;
-      exportSession.videoComposition = _playerItem.videoComposition;
-      exportSession.shouldOptimizeForNetworkUse = true;
-      [exportSession exportAsynchronouslyWithCompletionHandler:^{
-        
-        switch ([exportSession status]) {
-          case AVAssetExportSessionStatusFailed:
-            reject(@"ERROR_COULD_NOT_EXPORT_VIDEO", @"Could not export video", exportSession.error);
-            break;
-          case AVAssetExportSessionStatusCancelled:
-            reject(@"ERROR_EXPORT_SESSION_CANCELLED", @"Export session was cancelled", exportSession.error);
-            break;
-          default:
-            resolve(@{@"uri": url.absoluteString});
-            break;
-        }
-        
-      }];
-      
-    } else {
-      
-      reject(@"ERROR_COULD_NOT_CREATE_EXPORT_SESSION", @"Could not create export session", nil);
-      
-    }
-    
-  } else {
-    
-    reject(@"ERROR_ASSET_NIL", @"Asset is nil", nil);
-    
-  }
-}
-
-- (void)setLicenseResult:(NSString *)license {
-  NSData *respondData = [self base64DataFromBase64String:license];
-  if (_loadingRequest != nil && respondData != nil) {
-    AVAssetResourceLoadingDataRequest *dataRequest = [_loadingRequest dataRequest];
-    [dataRequest respondWithData:respondData];
-    [_loadingRequest finishLoading];
-  } else {
-    [self setLicenseResultError:@"No data from JS license response"];
-  }
-}
-
-- (BOOL)setLicenseResultError:(NSString *)error {
-  if (_loadingRequest != nil) {
-    NSError *licenseError = [NSError errorWithDomain: @"RCTVideo"
-                                                code: RCTVideoErrorFromJSPart
-                                            userInfo: @{
-                                                        NSLocalizedDescriptionKey: error,
-                                                        NSLocalizedFailureReasonErrorKey: error,
-                                                        NSLocalizedRecoverySuggestionErrorKey: error
-                                                        }
-                             ];
-    [self finishLoadingWithError:licenseError];
-  }
-  return NO;
-}
-
-- (BOOL)finishLoadingWithError:(NSError *)error {
-  if (_loadingRequest && error != nil) {
-    NSError *licenseError = error;
-    [_loadingRequest finishLoadingWithError:licenseError];
-    if (self.onVideoError) {
-      self.onVideoError(@{@"error": @{@"code": [NSNumber numberWithInteger: error.code],
-                                      @"localizedDescription": [error localizedDescription] == nil ? @"" : [error localizedDescription],
-                                      @"localizedFailureReason": [error localizedFailureReason] == nil ? @"" : [error localizedFailureReason],
-                                      @"localizedRecoverySuggestion": [error localizedRecoverySuggestion] == nil ? @"" : [error localizedRecoverySuggestion],
-                                      @"domain": _playerItem.error == nil ? @"RCTVideo" : _playerItem.error.domain},
-                          @"target": self.reactTag});
-    }
-  }
-  return NO;
-}
-
-- (BOOL)ensureDirExistsWithPath:(NSString *)path {
-  BOOL isDir = NO;
-  NSError *error;
-  BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:path isDirectory:&isDir];
-  if (!(exists && isDir)) {
-    [[NSFileManager defaultManager] createDirectoryAtPath:path withIntermediateDirectories:YES attributes:nil error:&error];
-    if (error) {
-      return NO;
-    }
-  }
-  return YES;
-}
-
-- (NSString *)generatePathInDirectory:(NSString *)directory withExtension:(NSString *)extension {
-  NSString *fileName = [[[NSUUID UUID] UUIDString] stringByAppendingString:extension];
-  [self ensureDirExistsWithPath:directory];
-  return [directory stringByAppendingPathComponent:fileName];
-}
-
-- (NSString *)cacheDirectoryPath {
-  NSArray *array = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
-  return array[0];
-}
-
-#pragma mark - AVAssetResourceLoaderDelegate
-
-- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForRenewalOfRequestedResource:(AVAssetResourceRenewalRequest *)renewalRequest {
-  return [self loadingRequestHandling:renewalRequest];
-}
-
-- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest {
-  return [self loadingRequestHandling:loadingRequest];
-}
-
-- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader
-didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest {
-  NSLog(@"didCancelLoadingRequest");
-}
-
-- (BOOL)loadingRequestHandling:(AVAssetResourceLoadingRequest *)loadingRequest {
-  if (self->_requestingCertificate) {
-    return YES;
-  } else if (self->_requestingCertificateErrored) {
-    return NO;
-  }
-  _loadingRequest = loadingRequest;
-  NSURL *url = loadingRequest.request.URL;
-  if (self->_drm != nil) {
-    NSString *contentId;
-    NSString *contentIdOverride = (NSString *)[self->_drm objectForKey:@"contentId"];
-    if (contentIdOverride != nil) {
-      contentId = contentIdOverride;
-    } else if (self.onGetLicense) {
-      contentId = url.host;
-    } else {
-      contentId = [url.absoluteString stringByReplacingOccurrencesOfString:@"skd://" withString:@""];
-    }
-    NSString *drmType = (NSString *)[self->_drm objectForKey:@"type"];
-    if ([drmType isEqualToString:@"fairplay"]) {
-      NSString *certificateStringUrl = (NSString *)[self->_drm objectForKey:@"certificateUrl"];
-      if (certificateStringUrl != nil) {
-        NSURL *certificateURL = [NSURL URLWithString:[certificateStringUrl stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];
-        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-          NSData *certificateData = [NSData dataWithContentsOfURL:certificateURL];
-          if ([self->_drm objectForKey:@"base64Certificate"]) {
-            certificateData = [[NSData alloc] initWithBase64EncodedData:certificateData options:NSDataBase64DecodingIgnoreUnknownCharacters];
-          }
-          
-          if (certificateData != nil) {
-            NSData *contentIdData;
-            if(self.onGetLicense) {
-              contentIdData = [contentId dataUsingEncoding:NSUTF8StringEncoding];
-            } else {
-              contentIdData = [NSData dataWithBytes: [contentId cStringUsingEncoding:NSUTF8StringEncoding] length:[contentId lengthOfBytesUsingEncoding:NSUTF8StringEncoding]];
-            }
-            AVAssetResourceLoadingDataRequest *dataRequest = [loadingRequest dataRequest];
-            if (dataRequest != nil) {
-              NSError *spcError = nil;
-              NSData *spcData = [loadingRequest streamingContentKeyRequestDataForApp:certificateData contentIdentifier:contentIdData options:nil error:&spcError];
-              // Request CKC to the server
-              NSString *licenseServer = (NSString *)[self->_drm objectForKey:@"licenseServer"];
-              if (spcError != nil) {
-                [self finishLoadingWithError:spcError];
-                self->_requestingCertificateErrored = YES;
-              }
-              if (spcData != nil) {
-                if(self.onGetLicense) {
-                  NSString *base64Encoded = [spcData base64EncodedStringWithOptions:0];
-                  self->_requestingCertificate = YES;
-                  if (licenseServer == nil) {
-                    licenseServer = @"";
-                  }
-                  self.onGetLicense(@{@"licenseUrl": licenseServer,
-                                      @"contentId": contentId,
-                                      @"spcBase64": base64Encoded,
-                                      @"target": self.reactTag}
-                                    );
-                } else if(licenseServer != nil) {
-                  NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];
-                  [request setHTTPMethod:@"POST"];
-                  [request setURL:[NSURL URLWithString:licenseServer]];
-                  // HEADERS
-                  NSDictionary *headers = (NSDictionary *)[self->_drm objectForKey:@"headers"];
-                  if (headers != nil) {
-                    for (NSString *key in headers) {
-                      NSString *value = headers[key];
-                      [request setValue:value forHTTPHeaderField:key];
-                    }
-                  }
-
-                  if(self.onGetLicense) {
-                    [request setHTTPBody: spcData];
-                  } else {
-                    NSString *spcEncoded = [spcData base64EncodedStringWithOptions:0];
-                    NSString *spcUrlEncoded = (NSString *) CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (CFStringRef)spcEncoded, NULL, CFSTR("?=&+"), kCFStringEncodingUTF8));
-                    NSString *post = [NSString stringWithFormat:@"spc=%@&%@", spcUrlEncoded, contentId];
-                    NSData *postData = [post dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];
-                    [request setHTTPBody: postData];
-                  }
-                  
-                  NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
-                  NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];
-                  NSURLSessionDataTask *postDataTask = [session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
-                    NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;
-                    if (error != nil) {
-                      NSLog(@"Error getting license from %@, HTTP status code %li", url, (long)[httpResponse statusCode]);
-                      [self finishLoadingWithError:error];
-                      self->_requestingCertificateErrored = YES;
-                    } else {
-                      if([httpResponse statusCode] != 200){
-                        NSLog(@"Error getting license from %@, HTTP status code %li", url, (long)[httpResponse statusCode]);
-                        NSError *licenseError = [NSError errorWithDomain: @"RCTVideo"
-                                                                    code: RCTVideoErrorLicenseRequestNotOk
-                                                                userInfo: @{
-                                                                            NSLocalizedDescriptionKey: @"Error obtaining license.",
-                                                                            NSLocalizedFailureReasonErrorKey: [NSString stringWithFormat:@"License server responded with status code %li", (long)[httpResponse statusCode]],
-                                                                            NSLocalizedRecoverySuggestionErrorKey: @"Did you send the correct data to the license Server? Is the server ok?"
-                                                                            }
-                                                 ];
-                        [self finishLoadingWithError:licenseError];
-                        self->_requestingCertificateErrored = YES;
-                      } else if (data != nil) {
-                        if(self.onGetLicense) {
-                          [dataRequest respondWithData:data];
-                        } else {
-                          NSData *decodedData = [[NSData alloc] initWithBase64EncodedData:data options:0];
-                          [dataRequest respondWithData:decodedData];
-                        }
-                        [loadingRequest finishLoading];
-                      } else {
-                        NSError *licenseError = [NSError errorWithDomain: @"RCTVideo"
-                                                                    code: RCTVideoErrorNoDataFromLicenseRequest
-                                                                userInfo: @{
-                                                                            NSLocalizedDescriptionKey: @"Error obtaining DRM license.",
-                                                                            NSLocalizedFailureReasonErrorKey: @"No data received from the license server.",
-                                                                            NSLocalizedRecoverySuggestionErrorKey: @"Is the licenseServer ok?."
-                                                                            }
-                                                 ];
-                        [self finishLoadingWithError:licenseError];
-                        self->_requestingCertificateErrored = YES;
-                      }
-
-                    }
-                  }];
-                  [postDataTask resume];
-                }
-                
-              } else {
-                NSError *licenseError = [NSError errorWithDomain: @"RCTVideo"
-                                                            code: RCTVideoErrorNoSPC
-                                                        userInfo: @{
-                                                                    NSLocalizedDescriptionKey: @"Error obtaining license.",
-                                                                    NSLocalizedFailureReasonErrorKey: @"No spc received.",
-                                                                    NSLocalizedRecoverySuggestionErrorKey: @"Check your DRM config."
-                                                                    }
-                                         ];
-                [self finishLoadingWithError:licenseError];
-                self->_requestingCertificateErrored = YES;
-              }
-              
-            } else {
-              NSError *licenseError = [NSError errorWithDomain: @"RCTVideo"
-                                                          code: RCTVideoErrorNoDataRequest
-                                                      userInfo: @{
-                                                                  NSLocalizedDescriptionKey: @"Error obtaining DRM license.",
-                                                                  NSLocalizedFailureReasonErrorKey: @"No dataRequest found.",
-                                                                  NSLocalizedRecoverySuggestionErrorKey: @"Check your DRM configuration."
-                                                                  }
-                                       ];
-              [self finishLoadingWithError:licenseError];
-              self->_requestingCertificateErrored = YES;
-            }
-          } else {
-            NSError *licenseError = [NSError errorWithDomain: @"RCTVideo"
-                                                        code: RCTVideoErrorNoCertificateData
-                                                    userInfo: @{
-                                                                NSLocalizedDescriptionKey: @"Error obtaining DRM license.",
-                                                                NSLocalizedFailureReasonErrorKey: @"No certificate data obtained from the specificied url.",
-                                                                NSLocalizedRecoverySuggestionErrorKey: @"Have you specified a valid 'certificateUrl'?"
-                                                                }
-                                     ];
-            [self finishLoadingWithError:licenseError];
-            self->_requestingCertificateErrored = YES;
-          }
-        });
-        return YES;
-      } else {
-        NSError *licenseError = [NSError errorWithDomain: @"RCTVideo"
-                                                    code: RCTVideoErrorNoCertificateURL
-                                                userInfo: @{
-                                                            NSLocalizedDescriptionKey: @"Error obtaining DRM License.",
-                                                            NSLocalizedFailureReasonErrorKey: @"No certificate URL has been found.",
-                                                            NSLocalizedRecoverySuggestionErrorKey: @"Did you specified the prop certificateUrl?"
-                                                            }
-                                 ];
-        return [self finishLoadingWithError:licenseError];
-      }
-    } else {
-      NSError *licenseError = [NSError errorWithDomain: @"RCTVideo"
-                                                  code: RCTVideoErrorNoFairplayDRM
-                                              userInfo: @{
-                                                          NSLocalizedDescriptionKey: @"Error obtaining DRM license.",
-                                                          NSLocalizedFailureReasonErrorKey: @"Not a valid DRM Scheme has found",
-                                                          NSLocalizedRecoverySuggestionErrorKey: @"Have you specified the 'drm' 'type' as fairplay?"
-                                                          }
-                               ];
-      return [self finishLoadingWithError:licenseError];
-    }
-    
-  } else {
-    NSError *licenseError = [NSError errorWithDomain: @"RCTVideo"
-                                                code: RCTVideoErrorNoDRMData
-                                            userInfo: @{
-                                                        NSLocalizedDescriptionKey: @"Error obtaining DRM license.",
-                                                        NSLocalizedFailureReasonErrorKey: @"No drm object found.",
-                                                        NSLocalizedRecoverySuggestionErrorKey: @"Have you specified the 'drm' prop?"
-                                                        }
-                             ];
-    return [self finishLoadingWithError:licenseError];
-  }
-  
-  
-  return NO;
-}
-
-- (NSData *)base64DataFromBase64String: (NSString *)base64String {
-  if (base64String != nil) {
-    // NSData from the Base64 encoded str
-    NSData *base64Data = [[NSData alloc] initWithBase64EncodedString:base64String options:NSASCIIStringEncoding];
-    return base64Data;
-  }
-  return nil;
-}
-#pragma mark - Picture in Picture
-
-#if TARGET_OS_IOS
-- (void)pictureInPictureControllerDidStopPictureInPicture:(AVPictureInPictureController *)pictureInPictureController {
-  if (self.onPictureInPictureStatusChanged) {
-    self.onPictureInPictureStatusChanged(@{
-                                           @"isActive": [NSNumber numberWithBool:false]
-                                           });
-  }
-}
-
-- (void)pictureInPictureControllerDidStartPictureInPicture:(AVPictureInPictureController *)pictureInPictureController {
-  if (self.onPictureInPictureStatusChanged) {
-    self.onPictureInPictureStatusChanged(@{
-                                           @"isActive": [NSNumber numberWithBool:true]
-                                           });
-  }
-}
-
-- (void)pictureInPictureControllerWillStopPictureInPicture:(AVPictureInPictureController *)pictureInPictureController {
-  
-}
-
-- (void)pictureInPictureControllerWillStartPictureInPicture:(AVPictureInPictureController *)pictureInPictureController {
-  
-}
-
-- (void)pictureInPictureController:(AVPictureInPictureController *)pictureInPictureController failedToStartPictureInPictureWithError:(NSError *)error {
-  
-}
-
-- (void)pictureInPictureController:(AVPictureInPictureController *)pictureInPictureController restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:(void (^)(BOOL))completionHandler {
-  NSAssert(_restoreUserInterfaceForPIPStopCompletionHandler == NULL, @"restoreUserInterfaceForPIPStopCompletionHandler was not called after picture in picture was exited.");
-  if (self.onRestoreUserInterfaceForPictureInPictureStop) {
-    self.onRestoreUserInterfaceForPictureInPictureStop(@{});
-  }
-  _restoreUserInterfaceForPIPStopCompletionHandler = completionHandler;
-}
-#endif
-
-@end
diff --git a/node_modules/react-native-video/ios/Video/RCTVideo.swift b/node_modules/react-native-video/ios/Video/RCTVideo.swift
new file mode 100644
index 0000000..b07629d
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/RCTVideo.swift
@@ -0,0 +1,1199 @@
+import AVFoundation
+import AVKit
+import Foundation
+#if USE_GOOGLE_IMA
+import GoogleInteractiveMediaAds
+#endif
+import React
+import Promises
+
+class RCTVideo: UIView, RCTVideoPlayerViewControllerDelegate, RCTPlayerObserverHandler {
+
+    private var _player:AVPlayer?
+    private var _playerItem:AVPlayerItem?
+    private var _source:VideoSource?
+    private var _playerBufferEmpty:Bool = true
+    private var _playerLayer:AVPlayerLayer?
+
+    private var _playerViewController:RCTVideoPlayerViewController?
+    private var _videoURL:NSURL?
+
+    /* DRM */
+    private var _drm:DRMParams?
+    
+    /* videoOptions */
+    private var _videoOptions:NSDictionary?;
+
+    private var _localSourceEncryptionKeyScheme:String?
+
+    /* Required to publish events */
+    private var _eventDispatcher:RCTEventDispatcher?
+    private var _videoLoadStarted:Bool = false
+
+    private var _pendingSeek:Bool = false
+    private var _pendingSeekTime:Float = 0.0
+    private var _lastSeekTime:Float = 0.0
+
+    /* For sending videoProgress events */
+    private var _controls:Bool = false
+
+    /* Keep track of any modifiers, need to be applied after each play */
+    private var _volume:Float = 1.0
+    private var _rate:Float = 1.0
+    private var _maxBitRate:Float?
+
+    private var _automaticallyWaitsToMinimizeStalling:Bool = true
+    private var _muted:Bool = false
+    private var _paused:Bool = false
+    private var _repeat:Bool = false
+    private var _allowsExternalPlayback:Bool = true
+    private var _textTracks:[TextTrack]?
+    private var _selectedTextTrackCriteria:SelectedTrackCriteria?
+    private var _selectedAudioTrackCriteria:SelectedTrackCriteria?
+    private var _playbackStalled:Bool = false
+    private var _playInBackground:Bool = false
+    private var _preventsDisplaySleepDuringVideoPlayback:Bool = true
+    private var _preferredForwardBufferDuration:Float = 0.0
+    private var _playWhenInactive:Bool = false
+    private var _ignoreSilentSwitch:String! = "inherit" // inherit, ignore, obey
+    private var _mixWithOthers:String! = "inherit" // inherit, mix, duck
+    private var _resizeMode:String! = "AVLayerVideoGravityResizeAspectFill"
+    private var _fullscreen:Bool = false
+    private var _fullscreenAutorotate:Bool = true
+    private var _fullscreenOrientation:String! = "all"
+    private var _fullscreenPlayerPresented:Bool = false
+    private var _fullscreenUncontrolPlayerPresented:Bool = false // to call events switching full screen mode from player controls
+    private var _filterName:String!
+    private var _filterEnabled:Bool = false
+    private var _presentingViewController:UIViewController?
+
+    /* IMA Ads */
+    private var _adTagUrl:String?
+#if USE_GOOGLE_IMA
+    private var _imaAdsManager: RCTIMAAdsManager!
+    /* Playhead used by the SDK to track content video progress and insert mid-rolls. */
+    private var _contentPlayhead: IMAAVPlayerContentPlayhead?
+#endif
+    private var _didRequestAds:Bool = false
+    private var _adPlaying:Bool = false
+
+    private var _resouceLoaderDelegate: RCTResourceLoaderDelegate?
+    private var _playerObserver: RCTPlayerObserver = RCTPlayerObserver()
+
+#if canImport(RCTVideoCache)
+    private let _videoCache:RCTVideoCachingHandler = RCTVideoCachingHandler()
+#endif
+
+#if TARGET_OS_IOS
+    private let _pip:RCTPictureInPicture = RCTPictureInPicture(self.onPictureInPictureStatusChanged, self.onRestoreUserInterfaceForPictureInPictureStop)
+#endif
+
+    // Events
+    @objc var onVideoLoadStart: RCTDirectEventBlock?
+    @objc var onVideoLoad: RCTDirectEventBlock?
+    @objc var onVideoBuffer: RCTDirectEventBlock?
+    @objc var onVideoError: RCTDirectEventBlock?
+    @objc var onVideoProgress: RCTDirectEventBlock?
+    @objc var onBandwidthUpdate: RCTDirectEventBlock?
+    @objc var onVideoSeek: RCTDirectEventBlock?
+    @objc var onVideoEnd: RCTDirectEventBlock?
+    @objc var onTimedMetadata: RCTDirectEventBlock?
+    @objc var onVideoAudioBecomingNoisy: RCTDirectEventBlock?
+    @objc var onVideoFullscreenPlayerWillPresent: RCTDirectEventBlock?
+    @objc var onVideoFullscreenPlayerDidPresent: RCTDirectEventBlock?
+    @objc var onVideoFullscreenPlayerWillDismiss: RCTDirectEventBlock?
+    @objc var onVideoFullscreenPlayerDidDismiss: RCTDirectEventBlock?
+    @objc var onReadyForDisplay: RCTDirectEventBlock?
+    @objc var onPlaybackStalled: RCTDirectEventBlock?
+    @objc var onPlaybackResume: RCTDirectEventBlock?
+    @objc var onPlaybackRateChange: RCTDirectEventBlock?
+    @objc var onVideoExternalPlaybackChange: RCTDirectEventBlock?
+    @objc var onPictureInPictureStatusChanged: RCTDirectEventBlock?
+    @objc var onRestoreUserInterfaceForPictureInPictureStop: RCTDirectEventBlock?
+    @objc var onGetLicense: RCTDirectEventBlock?
+    @objc var onReceiveAdEvent: RCTDirectEventBlock?
+
+    init(eventDispatcher:RCTEventDispatcher!) {
+        super.init(frame: CGRect(x: 0, y: 0, width: 100, height: 100))
+#if USE_GOOGLE_IMA
+        _imaAdsManager = RCTIMAAdsManager(video: self)
+#endif
+
+        _eventDispatcher = eventDispatcher
+
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(applicationWillResignActive(notification:)),
+            name: UIApplication.willResignActiveNotification,
+            object: nil
+        )
+
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(applicationDidEnterBackground(notification:)),
+            name: UIApplication.didEnterBackgroundNotification,
+            object: nil
+        )
+
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(applicationWillEnterForeground(notification:)),
+            name: UIApplication.willEnterForegroundNotification,
+            object: nil
+        )
+
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(audioRouteChanged(notification:)),
+            name: AVAudioSession.routeChangeNotification,
+            object: nil
+        )
+        _playerObserver._handlers = self
+#if canImport(RCTVideoCache)
+        _videoCache.playerItemPrepareText = playerItemPrepareText
+#endif
+    }
+
+    required init?(coder aDecoder: NSCoder) {
+        super.init(coder: aDecoder)
+#if USE_GOOGLE_IMA
+        _imaAdsManager = RCTIMAAdsManager(video: self)
+#endif
+    }
+
+    deinit {
+        NotificationCenter.default.removeObserver(self)
+        self.removePlayerLayer()
+        _playerObserver.clearPlayer()
+    }
+
+    // MARK: - App lifecycle handlers
+
+    @objc func applicationWillResignActive(notification:NSNotification!) {
+        if _playInBackground || _playWhenInactive || _paused {return}
+
+        _player?.pause()
+        _player?.rate = 0.0
+    }
+
+    @objc func applicationDidEnterBackground(notification:NSNotification!) {
+        if _playInBackground {
+            // Needed to play sound in background. See https://developer.apple.com/library/ios/qa/qa1668/_index.html
+            _playerLayer?.player = nil
+            _playerViewController?.player = nil
+        }
+    }
+
+    @objc func applicationWillEnterForeground(notification:NSNotification!) {
+        self.applyModifiers()
+        if _playInBackground {
+            _playerLayer?.player = _player
+            _playerViewController?.player = _player
+        }
+    }
+
+    // MARK: - Audio events
+
+    @objc func audioRouteChanged(notification:NSNotification!) {
+        if let userInfo = notification.userInfo {
+            let reason:AVAudioSession.RouteChangeReason! = userInfo[AVAudioSessionRouteChangeReasonKey] as? AVAudioSession.RouteChangeReason
+            //            let previousRoute:NSNumber! = userInfo[AVAudioSessionRouteChangePreviousRouteKey] as? NSNumber
+            if reason == .oldDeviceUnavailable, let onVideoAudioBecomingNoisy = onVideoAudioBecomingNoisy {
+                onVideoAudioBecomingNoisy(["target": reactTag as Any])
+            }
+        }
+    }
+
+    // MARK: - Progress
+
+    func sendProgressUpdate() {
+        if let video = _player?.currentItem,
+           video == nil || video.status != AVPlayerItem.Status.readyToPlay {
+            return
+        }
+
+        let playerDuration:CMTime = RCTVideoUtils.playerItemDuration(_player)
+        if CMTIME_IS_INVALID(playerDuration) {
+            return
+        }
+
+        var currentTime = _player?.currentTime()
+        if (currentTime != nil && _source?.startTime != nil) {
+            currentTime = CMTimeSubtract(currentTime!, CMTimeMake(value: _source?.startTime ?? 0, timescale: 1000))
+        }
+        let currentPlaybackTime = _player?.currentItem?.currentDate()
+        let duration = CMTimeGetSeconds(playerDuration)
+        let currentTimeSecs = CMTimeGetSeconds(currentTime ?? .zero)
+
+        NotificationCenter.default.post(name: NSNotification.Name("RCTVideo_progress"), object: nil, userInfo: [
+            "progress": NSNumber(value: currentTimeSecs / duration)
+        ])
+
+        if currentTimeSecs >= 0 {
+#if USE_GOOGLE_IMA
+            if !_didRequestAds && currentTimeSecs >= 0.0001 && _adTagUrl != nil {
+                _imaAdsManager.requestAds()
+                _didRequestAds = true
+            }
+#endif
+            onVideoProgress?([
+                "currentTime": NSNumber(value: Float(currentTimeSecs)),
+                "playableDuration": RCTVideoUtils.calculatePlayableDuration(_player, withSource: _source),
+                "atValue": NSNumber(value: currentTime?.value ?? .zero),
+                "currentPlaybackTime": NSNumber(value: NSNumber(value: floor(currentPlaybackTime?.timeIntervalSince1970 ?? 0 * 1000)).int64Value),
+                "target": reactTag,
+                "seekableDuration": RCTVideoUtils.calculateSeekableDuration(_player)
+            ])
+        }
+    }
+
+    // MARK: - Player and source
+    @objc
+    func setSrc(_ source:NSDictionary!) {
+        DispatchQueue.global(qos: .default).async { [weak self] in
+            guard let self = self else {return}
+            self._source = VideoSource(source)
+            if (self._source?.uri == nil || self._source?.uri == "") {
+                self._player?.replaceCurrentItem(with: nil)
+                return;
+            }
+            self.removePlayerLayer()
+            self._playerObserver.player = nil
+            self._resouceLoaderDelegate = nil
+            self._playerObserver.playerItem = nil
+
+            // perform on next run loop, otherwise other passed react-props may not be set
+            RCTVideoUtils.delay()
+                .then{ [weak self] in
+                    guard let self = self else {throw NSError(domain: "", code: 0, userInfo: nil)}
+                    guard let source = self._source else {
+                        DebugLog("The source not exist")
+                        throw NSError(domain: "", code: 0, userInfo: nil)
+                    }
+                    if let uri = source.uri, uri.starts(with: "ph://") {
+                        return Promise {
+                            RCTVideoUtils.preparePHAsset(uri: uri).then { asset in
+                                return self.playerItemPrepareText(asset:asset, assetOptions:nil)
+                            }
+                        }
+                    }
+                    guard let assetResult = RCTVideoUtils.prepareAsset(source: source),
+                        let asset = assetResult.asset,
+                        let assetOptions = assetResult.assetOptions else {
+                        DebugLog("Could not find video URL in source '\(self._source)'")
+                        throw NSError(domain: "", code: 0, userInfo: nil)
+                    }
+
+    #if canImport(RCTVideoCache)
+                    if self._videoCache.shouldCache(source:source, textTracks:self._textTracks) {
+                        return self._videoCache.playerItemForSourceUsingCache(uri: source.uri, assetOptions:assetOptions)
+                    }
+    #endif
+
+                    if self._drm != nil || self._localSourceEncryptionKeyScheme != nil {
+                        self._resouceLoaderDelegate = RCTResourceLoaderDelegate(
+                            asset: asset,
+                            drm: self._drm,
+                            localSourceEncryptionKeyScheme: self._localSourceEncryptionKeyScheme,
+                            onVideoError: self.onVideoError,
+                            onGetLicense: self.onGetLicense,
+                            reactTag: self.reactTag
+                        )
+                    }
+                    return Promise{self.playerItemPrepareText(asset: asset, assetOptions:assetOptions)}
+                }.then{[weak self] (playerItem:AVPlayerItem!) in
+                    guard let self = self else {throw  NSError(domain: "", code: 0, userInfo: nil)}
+
+                    self._player?.pause()
+                    self._playerItem = playerItem
+                    self._playerObserver.playerItem = self._playerItem
+                    self.setPreferredForwardBufferDuration(self._preferredForwardBufferDuration)
+                    self.setPlaybackRange(playerItem, withVideoStart: self._source?.startTime, withVideoEnd: self._source?.endTime)
+                    self.setFilter(self._filterName)
+                    if let maxBitRate = self._maxBitRate {
+                        self._playerItem?.preferredPeakBitRate = Double(maxBitRate)
+                    }
+
+                    self._player = self._player ?? AVPlayer()
+                    self._player?.replaceCurrentItem(with: playerItem)
+                    self._playerObserver.player = self._player
+                    self.applyModifiers()
+                    self._player?.actionAtItemEnd = .none
+
+                    if #available(iOS 10.0, *) {
+                        self.setAutomaticallyWaitsToMinimizeStalling(self._automaticallyWaitsToMinimizeStalling)
+                    }
+
+#if USE_GOOGLE_IMA
+                    if self._adTagUrl != nil {
+                        // Set up your content playhead and contentComplete callback.
+                        self._contentPlayhead = IMAAVPlayerContentPlayhead(avPlayer: self._player!)
+
+                        self._imaAdsManager.setUpAdsLoader()
+                    }
+#endif
+                    //Perform on next run loop, otherwise onVideoLoadStart is nil
+                    self.onVideoLoadStart?([
+                        "src": [
+                            "uri": self._source?.uri ?? NSNull(),
+                            "type": self._source?.type ?? NSNull(),
+                            "isNetwork": NSNumber(value: self._source?.isNetwork ?? false)
+                        ],
+                        "drm": self._drm?.json ?? NSNull(),
+                        "target": self.reactTag
+                    ])
+                }.catch{_ in }
+            self._videoLoadStarted = true
+        }
+    }
+
+    @objc
+    func setDrm(_ drm:NSDictionary) {
+        _drm = DRMParams(drm)
+    }
+    
+    @objc
+    func setVideoOptions(_ videoOptions:NSDictionary) {
+        _videoOptions = videoOptions;
+        print("videoOptions ",videoOptions);
+    }
+
+    @objc
+    func setLocalSourceEncryptionKeyScheme(_ keyScheme:String) {
+        _localSourceEncryptionKeyScheme = keyScheme
+    }
+
+    func playerItemPrepareText(asset:AVAsset!, assetOptions:NSDictionary?) -> AVPlayerItem {
+        if (_textTracks == nil) || _textTracks?.count==0 {
+            return AVPlayerItem(asset: asset)
+        }
+
+        // AVPlayer can't airplay AVMutableCompositions
+        _allowsExternalPlayback = false
+        let mixComposition = RCTVideoUtils.generateMixComposition(asset)
+        let validTextTracks = RCTVideoUtils.getValidTextTracks(
+            asset:asset,
+            assetOptions:assetOptions,
+            mixComposition:mixComposition,
+            textTracks:_textTracks)
+        if validTextTracks.count != _textTracks?.count {
+            setTextTracks(validTextTracks)
+        }
+
+        return AVPlayerItem(asset: mixComposition)
+    }
+
+    // MARK: - Prop setters
+
+    @objc
+    func setResizeMode(_ mode: String?) {
+        if _controls {
+            _playerViewController?.videoGravity = AVLayerVideoGravity(rawValue: mode ?? "")
+        } else {
+            _playerLayer?.videoGravity = AVLayerVideoGravity(rawValue: mode ?? "")
+        }
+        _resizeMode = mode
+    }
+
+    @objc
+    func setPlayInBackground(_ playInBackground:Bool) {
+        _playInBackground = playInBackground
+    }
+
+    @objc
+    func setPreventsDisplaySleepDuringVideoPlayback(_ preventsDisplaySleepDuringVideoPlayback:Bool) {
+        _preventsDisplaySleepDuringVideoPlayback = preventsDisplaySleepDuringVideoPlayback
+        self.applyModifiers()
+    }
+
+    @objc
+    func setAllowsExternalPlayback(_ allowsExternalPlayback:Bool) {
+        _allowsExternalPlayback = allowsExternalPlayback
+        _player?.allowsExternalPlayback = _allowsExternalPlayback
+    }
+
+    @objc
+    func setPlayWhenInactive(_ playWhenInactive:Bool) {
+        _playWhenInactive = playWhenInactive
+    }
+
+    @objc
+    func setPictureInPicture(_ pictureInPicture:Bool) {
+#if TARGET_OS_IOS
+        _pip.setPictureInPicture(pictureInPicture)
+#endif
+    }
+
+    @objc
+    func setRestoreUserInterfaceForPIPStopCompletionHandler(_ restore:Bool) {
+#if TARGET_OS_IOS
+        _pip.setRestoreUserInterfaceForPIPStopCompletionHandler(restore)
+#endif
+    }
+
+    @objc
+    func setIgnoreSilentSwitch(_ ignoreSilentSwitch:String?) {
+        _ignoreSilentSwitch = ignoreSilentSwitch
+        RCTPlayerOperations.configureAudio(ignoreSilentSwitch:_ignoreSilentSwitch, mixWithOthers:_mixWithOthers)
+        applyModifiers()
+    }
+
+    @objc
+    func setMixWithOthers(_ mixWithOthers:String?) {
+        _mixWithOthers = mixWithOthers
+        applyModifiers()
+    }
+
+    @objc
+    func setPaused(_ paused:Bool) {
+        if paused {
+            if _adPlaying {
+#if USE_GOOGLE_IMA
+                _imaAdsManager.getAdsManager()?.pause()
+#endif
+            } else {
+                _player?.pause()
+                _player?.rate = 0.0
+            }
+        } else {
+            RCTPlayerOperations.configureAudio(ignoreSilentSwitch:_ignoreSilentSwitch, mixWithOthers:_mixWithOthers)
+
+            if _adPlaying {
+#if USE_GOOGLE_IMA
+                _imaAdsManager.getAdsManager()?.resume()
+#endif
+            } else {
+                if #available(iOS 10.0, *), !_automaticallyWaitsToMinimizeStalling {
+                    _player?.playImmediately(atRate: _rate)
+                } else {
+                    _player?.play()
+                    _player?.rate = _rate
+                }
+                _player?.rate = _rate
+            }
+        }
+
+        _paused = paused
+    }
+
+    @objc
+    func setSeek(_ info:NSDictionary!) {
+        let seekTime:NSNumber! = info["time"] as! NSNumber
+        let seekTolerance:NSNumber! = info["tolerance"] as! NSNumber
+        let item:AVPlayerItem? = _player?.currentItem
+        guard item != nil, let player = _player, let item = item, item.status == AVPlayerItem.Status.readyToPlay else {
+            _pendingSeek = true
+            _pendingSeekTime = seekTime.floatValue
+            return
+        }
+        let wasPaused = _paused
+
+        RCTPlayerOperations.seek(
+            player:player,
+            playerItem:item,
+            paused:wasPaused,
+            seekTime:seekTime.floatValue,
+            seekTolerance:seekTolerance.floatValue)
+            .then{ [weak self] (finished:Bool) in
+                guard let self = self else { return }
+
+                self._playerObserver.addTimeObserverIfNotSet()
+                if !wasPaused {
+                    self.setPaused(false)
+                }
+                self.onVideoSeek?(["currentTime": NSNumber(value: Float(CMTimeGetSeconds(item.currentTime()))),
+                                   "seekTime": seekTime,
+                                   "target": self.reactTag])
+            }.catch{_ in }
+
+        _pendingSeek = false
+    }
+
+    @objc
+    func setRate(_ rate:Float) {
+        _rate = rate
+        applyModifiers()
+    }
+
+    @objc
+    func isMuted() -> Bool {
+        return _muted
+    }
+
+    @objc
+    func setMuted(_ muted:Bool) {
+        _muted = muted
+        applyModifiers()
+    }
+
+    @objc
+    func setVolume(_ volume:Float) {
+        _volume = volume
+        applyModifiers()
+    }
+
+    @objc
+    func setMaxBitRate(_ maxBitRate:Float) {
+        _maxBitRate = maxBitRate
+        _playerItem?.preferredPeakBitRate = Double(maxBitRate)
+    }
+
+    @objc
+    func setPreferredForwardBufferDuration(_ preferredForwardBufferDuration:Float) {
+        _preferredForwardBufferDuration = preferredForwardBufferDuration
+        if #available(iOS 10.0, *) {
+            _playerItem?.preferredForwardBufferDuration = TimeInterval(preferredForwardBufferDuration)
+        } else {
+            // Fallback on earlier versions
+        }
+    }
+
+    @objc
+    func setAutomaticallyWaitsToMinimizeStalling(_ waits:Bool) {
+        _automaticallyWaitsToMinimizeStalling = waits
+        if #available(iOS 10.0, *) {
+            _player?.automaticallyWaitsToMinimizeStalling = waits
+        } else {
+            // Fallback on earlier versions
+        }
+    }
+    
+    func setPlaybackRange(_ item:AVPlayerItem!, withVideoStart videoStart:Int64?, withVideoEnd videoEnd:Int64?) {
+        if (videoStart != nil) {
+            let start = CMTimeMake(value: videoStart!, timescale: 1000)
+            item.reversePlaybackEndTime = start
+            _pendingSeekTime = Float(CMTimeGetSeconds(start))
+            _pendingSeek = true
+        }
+        if (videoEnd != nil) {
+            item.forwardPlaybackEndTime = CMTimeMake(value: videoEnd!, timescale: 1000)
+        }
+    }
+
+
+    func applyModifiers() {
+        if let video = _player?.currentItem,
+            video == nil || video.status != AVPlayerItem.Status.readyToPlay {
+            return
+        }
+        if _muted {
+            if !_controls {
+                _player?.volume = 0
+            }
+            _player?.isMuted = true
+        } else {
+            _player?.volume = _volume
+            _player?.isMuted = false
+        }
+
+        if #available(iOS 12.0, *) {
+            _player?.preventsDisplaySleepDuringVideoPlayback = _preventsDisplaySleepDuringVideoPlayback
+        } else {
+            // Fallback on earlier versions
+        }
+
+        if let _maxBitRate = _maxBitRate {
+            setMaxBitRate(_maxBitRate)
+        }
+
+        setSelectedAudioTrack(_selectedAudioTrackCriteria)
+        setSelectedTextTrack(_selectedTextTrackCriteria)
+        setResizeMode(_resizeMode)
+        setRepeat(_repeat)
+        setControls(_controls)
+        setPaused(_paused)
+        setAllowsExternalPlayback(_allowsExternalPlayback)
+    }
+
+    @objc
+    func setRepeat(_ `repeat`: Bool) {
+        _repeat = `repeat`
+    }
+
+
+
+    @objc
+    func setSelectedAudioTrack(_ selectedAudioTrack:NSDictionary?) {
+        setSelectedAudioTrack(SelectedTrackCriteria(selectedAudioTrack))
+    }
+
+    func setSelectedAudioTrack(_ selectedAudioTrack:SelectedTrackCriteria?) {
+        _selectedAudioTrackCriteria = selectedAudioTrack
+        RCTPlayerOperations.setMediaSelectionTrackForCharacteristic(player:_player, characteristic: AVMediaCharacteristic.audible,
+                                                                    criteria:_selectedAudioTrackCriteria)
+    }
+
+    @objc
+    func setSelectedTextTrack(_ selectedTextTrack:NSDictionary?) {
+        setSelectedTextTrack(SelectedTrackCriteria(selectedTextTrack))
+    }
+
+    func setSelectedTextTrack(_ selectedTextTrack:SelectedTrackCriteria?) {
+        _selectedTextTrackCriteria = selectedTextTrack
+        if (_textTracks != nil) { // sideloaded text tracks
+            RCTPlayerOperations.setSideloadedText(player:_player, textTracks:_textTracks, criteria:_selectedTextTrackCriteria)
+        } else { // text tracks included in the HLS playlist
+            RCTPlayerOperations.setMediaSelectionTrackForCharacteristic(player:_player, characteristic: AVMediaCharacteristic.legible,
+                                                                        criteria:_selectedTextTrackCriteria)
+        }
+    }
+
+    @objc
+    func setTextTracks(_ textTracks:[NSDictionary]?) {
+        setTextTracks(textTracks?.map { TextTrack($0) })
+    }
+
+    func setTextTracks(_ textTracks:[TextTrack]?) {
+        _textTracks = textTracks
+
+        // in case textTracks was set after selectedTextTrack
+        if (_selectedTextTrackCriteria != nil) {setSelectedTextTrack(_selectedTextTrackCriteria)}
+    }
+
+    @objc
+    func setFullscreen(_ fullscreen:Bool) {
+        if fullscreen && !_fullscreenPlayerPresented && _player != nil {
+            // Ensure player view controller is not null
+            if _playerViewController == nil && _controls {
+                self.usePlayerViewController()
+            }
+
+            // Set presentation style to fullscreen
+            _playerViewController?.modalPresentationStyle = .fullScreen
+
+            // Find the nearest view controller
+            var viewController:UIViewController! = self.firstAvailableUIViewController()
+            if (viewController == nil) {
+                let keyWindow:UIWindow! = UIApplication.shared.keyWindow
+                viewController = keyWindow.rootViewController
+                if viewController.children.count > 0
+                {
+                    viewController = viewController.children.last
+                }
+            }
+            if viewController != nil {
+                _presentingViewController = viewController
+
+                self.onVideoFullscreenPlayerWillPresent?(["target": reactTag as Any])
+
+                if let playerViewController = _playerViewController {
+                    if(_controls) {
+                        // prevents crash https://github.com/react-native-video/react-native-video/issues/3040
+                        self._playerViewController?.removeFromParent()
+                    }
+
+                    viewController.present(playerViewController, animated:true, completion:{ [weak self] in
+                        guard let self = self else {return}
+                        self._playerViewController?.showsPlaybackControls = self._controls
+                        self._fullscreenPlayerPresented = fullscreen
+                        self._playerViewController?.autorotate = self._fullscreenAutorotate
+
+                        self.onVideoFullscreenPlayerDidPresent?(["target": self.reactTag])
+
+                    })
+                }
+            }
+        } else if !fullscreen && _fullscreenPlayerPresented, let _playerViewController = _playerViewController {
+            self.videoPlayerViewControllerWillDismiss(playerViewController: _playerViewController)
+            _presentingViewController?.dismiss(animated: true, completion:{[weak self] in
+                self?.videoPlayerViewControllerDidDismiss(playerViewController: _playerViewController)
+            })
+        }
+    }
+
+    @objc
+    func setFullscreenAutorotate(_ autorotate:Bool) {
+        _fullscreenAutorotate = autorotate
+        if _fullscreenPlayerPresented {
+            _playerViewController?.autorotate = autorotate
+        }
+    }
+
+    @objc
+    func setFullscreenOrientation(_ orientation:String?) {
+        _fullscreenOrientation = orientation
+        if _fullscreenPlayerPresented {
+            _playerViewController?.preferredOrientation = orientation
+        }
+    }
+
+    func usePlayerViewController() {
+        guard let _player = _player, let _playerItem = _playerItem else { return }
+
+        if _playerViewController == nil {
+            _playerViewController = createPlayerViewController(player:_player, withPlayerItem:_playerItem)
+        }
+        // to prevent video from being animated when resizeMode is 'cover'
+        // resize mode must be set before subview is added
+        setResizeMode(_resizeMode)
+
+        guard let _playerViewController = _playerViewController else { return }
+
+        if _controls {
+            let viewController:UIViewController! = self.reactViewController()
+            viewController?.addChild(_playerViewController)
+            self.addSubview(_playerViewController.view)
+        }
+
+        _playerObserver.playerViewController = _playerViewController
+    }
+
+    func createPlayerViewController(player:AVPlayer, withPlayerItem playerItem:AVPlayerItem) -> RCTVideoPlayerViewController {
+        let viewController = RCTVideoPlayerViewController()
+        viewController.showsPlaybackControls = self._controls
+        viewController.rctDelegate = self
+        viewController.preferredOrientation = _fullscreenOrientation
+
+        viewController.view.frame = self.bounds
+        viewController.player = player
+        return viewController
+    }
+
+    func usePlayerLayer() {
+        if let _player = _player {
+            _playerLayer = AVPlayerLayer(player: _player)
+            _playerLayer?.frame = self.bounds
+            _playerLayer?.needsDisplayOnBoundsChange = true
+
+            // to prevent video from being animated when resizeMode is 'cover'
+            // resize mode must be set before layer is added
+            setResizeMode(_resizeMode)
+            _playerObserver.playerLayer = _playerLayer
+
+            if let _playerLayer = _playerLayer {
+                self.layer.addSublayer(_playerLayer)
+            }
+            self.layer.needsDisplayOnBoundsChange = true
+#if TARGET_OS_IOS
+            _pip.setupPipController(_playerLayer)
+#endif
+        }
+    }
+
+    @objc
+    func setControls(_ controls:Bool) {
+        if _controls != controls || ((_playerLayer == nil) && (_playerViewController == nil))
+        {
+            _controls = controls
+            if _controls
+            {
+                self.removePlayerLayer()
+                self.usePlayerViewController()
+            }
+            else
+            {
+                _playerViewController?.view.removeFromSuperview()
+                _playerViewController?.removeFromParent()
+                _playerViewController = nil
+                _playerObserver.playerViewController = nil
+                self.usePlayerLayer()
+            }
+        }
+    }
+
+    @objc
+    func setProgressUpdateInterval(_ progressUpdateInterval:Float) {
+        _playerObserver.replaceTimeObserverIfSet(Float64(progressUpdateInterval))
+    }
+
+    func removePlayerLayer() {
+        _playerLayer?.removeFromSuperlayer()
+        _playerLayer = nil
+        _playerObserver.playerLayer = nil
+    }
+
+    // MARK: - RCTVideoPlayerViewControllerDelegate
+
+    func videoPlayerViewControllerWillDismiss(playerViewController:AVPlayerViewController) {
+        if _playerViewController == playerViewController && _fullscreenPlayerPresented, let onVideoFullscreenPlayerWillDismiss = onVideoFullscreenPlayerWillDismiss {
+            _playerObserver.removePlayerViewControllerObservers()
+            onVideoFullscreenPlayerWillDismiss(["target": reactTag as Any])
+        }
+    }
+
+
+    func videoPlayerViewControllerDidDismiss(playerViewController:AVPlayerViewController) {
+        if _playerViewController == playerViewController && _fullscreenPlayerPresented {
+            _fullscreenPlayerPresented = false
+            _presentingViewController = nil
+            _playerViewController = nil
+            _playerObserver.playerViewController = nil
+            self.applyModifiers()
+
+            onVideoFullscreenPlayerDidDismiss?(["target": reactTag as Any])
+        }
+    }
+
+    @objc
+    func setFilter(_ filterName:String!) {
+        _filterName = filterName
+
+        if !_filterEnabled {
+            return
+        } else if let uri = _source?.uri, uri.contains("m3u8") {
+            return // filters don't work for HLS... return
+        } else if _playerItem?.asset == nil {
+            return
+        }
+
+        let filter:CIFilter! = CIFilter(name: filterName)
+        if #available(iOS 9.0, *), let _playerItem = _playerItem {
+            self._playerItem?.videoComposition = AVVideoComposition(
+                asset: _playerItem.asset,
+                applyingCIFiltersWithHandler: { (request:AVAsynchronousCIImageFilteringRequest) in
+                    if filter == nil {
+                        request.finish(with: request.sourceImage, context:nil)
+                    } else {
+                        let image:CIImage! = request.sourceImage.clampedToExtent()
+                        filter.setValue(image, forKey:kCIInputImageKey)
+                        let output:CIImage! = filter.outputImage?.cropped(to: request.sourceImage.extent)
+                        request.finish(with: output, context:nil)
+                    }
+                })
+        } else {
+            // Fallback on earlier versions
+        }
+    }
+
+    @objc
+    func setFilterEnabled(_ filterEnabled:Bool) {
+        _filterEnabled = filterEnabled
+    }
+
+    // MARK: - RCTIMAAdsManager
+
+    func getAdTagUrl() -> String? {
+        return _adTagUrl
+    }
+
+    @objc
+    func setAdTagUrl(_ adTagUrl:String!) {
+        _adTagUrl = adTagUrl
+    }
+#if USE_GOOGLE_IMA
+    func getContentPlayhead() -> IMAAVPlayerContentPlayhead? {
+        return _contentPlayhead
+    }
+#endif
+    func setAdPlaying(_ adPlaying:Bool) {
+        _adPlaying = adPlaying
+    }
+
+    // MARK: - React View Management
+
+    func insertReactSubview(view:UIView!, atIndex:Int) {
+        if _controls {
+            view.frame = self.bounds
+            _playerViewController?.contentOverlayView?.insertSubview(view, at:atIndex)
+        } else {
+            RCTLogError("video cannot have any subviews")
+        }
+        return
+    }
+
+    func removeReactSubview(subview:UIView!) {
+        if _controls {
+            subview.removeFromSuperview()
+        } else {
+            RCTLog("video cannot have any subviews")
+        }
+        return
+    }
+
+    override func layoutSubviews() {
+        super.layoutSubviews()
+        if _controls, let _playerViewController = _playerViewController {
+            _playerViewController.view.frame = bounds
+
+            // also adjust all subviews of contentOverlayView
+            for subview in _playerViewController.contentOverlayView?.subviews ?? [] {
+                subview.frame = bounds
+            }
+        } else {
+            CATransaction.begin()
+            CATransaction.setAnimationDuration(0)
+            _playerLayer?.frame = bounds
+            CATransaction.commit()
+        }
+    }
+
+    // MARK: - Lifecycle
+
+    override func removeFromSuperview() {
+        _player?.pause()
+        _player = nil
+        _resouceLoaderDelegate = nil
+        _playerObserver.clearPlayer()
+
+        self.removePlayerLayer()
+
+        if let _playerViewController = _playerViewController {
+            _playerViewController.view.removeFromSuperview()
+            _playerViewController.removeFromParent()
+            _playerViewController.rctDelegate = nil
+            _playerViewController.player = nil
+            self._playerViewController = nil
+            _playerObserver.playerViewController = nil
+        }
+
+        _eventDispatcher = nil
+        NotificationCenter.default.removeObserver(self)
+
+        super.removeFromSuperview()
+    }
+
+    // MARK: - Export
+
+    @objc
+    func save(options:NSDictionary!, resolve: @escaping RCTPromiseResolveBlock, reject:@escaping RCTPromiseRejectBlock) {
+        RCTVideoSave.save(
+            options:options,
+            resolve:resolve,
+            reject:reject,
+            playerItem:_playerItem
+        )
+    }
+
+    func setLicenseResult(_ license:String!) {
+        _resouceLoaderDelegate?.setLicenseResult(license)
+    }
+
+    func setLicenseResultError(_ error:String!) {
+        _resouceLoaderDelegate?.setLicenseResultError(error)
+    }
+
+    // MARK: - RCTPlayerObserverHandler
+
+    func handleTimeUpdate(time:CMTime) {
+        sendProgressUpdate()
+    }
+
+    func handleReadyForDisplay(changeObject: Any, change:NSKeyValueObservedChange<Bool>) {
+        onReadyForDisplay?([
+            "target": reactTag
+        ])
+    }
+
+    // When timeMetadata is read the event onTimedMetadata is triggered
+    func handleTimeMetadataChange(playerItem:AVPlayerItem, change:NSKeyValueObservedChange<[AVMetadataItem]?>) {
+        guard let newValue = change.newValue, let _items = newValue, _items.count > 0 else {
+            return
+        }
+
+        var metadata: [[String:String?]?] = []
+        for item in _items {
+            let value = item.value as? String
+            let identifier = item.identifier?.rawValue
+
+            if let value = value {
+                metadata.append(["value":value, "identifier":identifier])
+            }
+        }
+
+        onTimedMetadata?([
+            "target": reactTag,
+            "metadata": metadata
+        ])
+    }
+
+    // Handle player item status change.
+    func handlePlayerItemStatusChange(playerItem:AVPlayerItem, change:NSKeyValueObservedChange<AVPlayerItem.Status>) {
+        guard let _playerItem = _playerItem else {
+            return
+        }
+
+        if _playerItem.status == .readyToPlay {
+            handleReadyToPlay()
+        } else if _playerItem.status == .failed {
+            handlePlaybackFailed()
+        }
+    }
+
+    func handleReadyToPlay() {
+        guard let _playerItem = _playerItem else { return }
+        var duration:Float = Float(CMTimeGetSeconds(_playerItem.asset.duration))
+
+        if duration.isNaN {
+            duration = 0.0
+        }
+
+        var width: Float? = nil
+        var height: Float? = nil
+        var orientation = "undefined"
+
+        if _playerItem.asset.tracks(withMediaType: AVMediaType.video).count > 0 {
+            let videoTrack = _playerItem.asset.tracks(withMediaType: .video)[0]
+            width = Float(videoTrack.naturalSize.width)
+            height = Float(videoTrack.naturalSize.height)
+            let preferredTransform = videoTrack.preferredTransform
+
+            if (videoTrack.naturalSize.width == preferredTransform.tx
+                && videoTrack.naturalSize.height == preferredTransform.ty)
+                || (preferredTransform.tx == 0 && preferredTransform.ty == 0)
+            {
+                orientation = "landscape"
+            } else {
+                orientation = "portrait"
+            }
+        } else if _playerItem.presentationSize.height != 0.0 {
+            width = Float(_playerItem.presentationSize.width)
+            height = Float(_playerItem.presentationSize.height)
+            orientation = _playerItem.presentationSize.width > _playerItem.presentationSize.height ? "landscape" : "portrait"
+        }
+
+        if _pendingSeek {
+            setSeek([
+                "time": NSNumber(value: _pendingSeekTime),
+                "tolerance": NSNumber(value: 100)
+            ])
+            _pendingSeek = false
+        }
+
+        if _videoLoadStarted {
+            let audioTracks = RCTVideoUtils.getAudioTrackInfo(_player)
+            let textTracks = RCTVideoUtils.getTextTrackInfo(_player).map(\.json)
+            onVideoLoad?(["duration": NSNumber(value: duration),
+                          "currentTime": NSNumber(value: Float(CMTimeGetSeconds(_playerItem.currentTime()))),
+                          "canPlayReverse": NSNumber(value: _playerItem.canPlayReverse),
+                          "canPlayFastForward": NSNumber(value: _playerItem.canPlayFastForward),
+                          "canPlaySlowForward": NSNumber(value: _playerItem.canPlaySlowForward),
+                          "canPlaySlowReverse": NSNumber(value: _playerItem.canPlaySlowReverse),
+                          "canStepBackward": NSNumber(value: _playerItem.canStepBackward),
+                          "canStepForward": NSNumber(value: _playerItem.canStepForward),
+                          "naturalSize": [
+                            "width": width != nil ? NSNumber(value: width!) : "undefinded",
+                            "height": width != nil ? NSNumber(value: height!) : "undefinded",
+                            "orientation": orientation
+                          ],
+                          "audioTracks": audioTracks,
+                          "textTracks": textTracks,
+                          "target": reactTag as Any])
+        }
+        _videoLoadStarted = false
+        _playerObserver.attachPlayerEventListeners()
+        applyModifiers()
+    }
+
+    func handlePlaybackFailed() {
+        guard let _playerItem = _playerItem else { return }
+        onVideoError?(
+            [
+                "error": [
+                    "code": NSNumber(value: (_playerItem.error! as NSError).code),
+                    "localizedDescription": _playerItem.error?.localizedDescription == nil ? "" : _playerItem.error?.localizedDescription,
+                    "localizedFailureReason": ((_playerItem.error! as NSError).localizedFailureReason == nil ? "" : (_playerItem.error! as NSError).localizedFailureReason) ?? "",
+                    "localizedRecoverySuggestion": ((_playerItem.error! as NSError).localizedRecoverySuggestion == nil ? "" : (_playerItem.error! as NSError).localizedRecoverySuggestion) ?? "",
+                    "domain": (_playerItem.error as! NSError).domain
+                ],
+                "target": reactTag
+            ])
+    }
+
+    func handlePlaybackBufferKeyEmpty(playerItem:AVPlayerItem, change:NSKeyValueObservedChange<Bool>) {
+        _playerBufferEmpty = true
+        onVideoBuffer?(["isBuffering": true, "target": reactTag as Any])
+    }
+
+    // Continue playing (or not if paused) after being paused due to hitting an unbuffered zone.
+    func handlePlaybackLikelyToKeepUp(playerItem:AVPlayerItem, change:NSKeyValueObservedChange<Bool>) {
+        if (!(_controls || _fullscreenPlayerPresented) || _playerBufferEmpty) && ((_playerItem?.isPlaybackLikelyToKeepUp) != nil) {
+            setPaused(_paused)
+        }
+        _playerBufferEmpty = false
+        onVideoBuffer?(["isBuffering": false, "target": reactTag as Any])
+    }
+
+    func handlePlaybackRateChange(player: AVPlayer, change: NSKeyValueObservedChange<Float>) {
+        guard let _player = _player else { return }
+        onPlaybackRateChange?(["playbackRate": NSNumber(value: _player.rate),
+                               "target": reactTag as Any])
+        if _playbackStalled && _player.rate > 0 {
+            onPlaybackResume?(["playbackRate": NSNumber(value: _player.rate),
+                               "target": reactTag as Any])
+            _playbackStalled = false
+        }
+    }
+
+    func handleExternalPlaybackActiveChange(player: AVPlayer, change: NSKeyValueObservedChange<Bool>) {
+        guard let _player = _player else { return }
+        onVideoExternalPlaybackChange?(["isExternalPlaybackActive": NSNumber(value: _player.isExternalPlaybackActive),
+                                        "target": reactTag as Any])
+    }
+
+    func handleViewControllerOverlayViewFrameChange(overlayView:UIView, change:NSKeyValueObservedChange<CGRect>) {
+        let oldRect = change.oldValue
+        let newRect = change.newValue
+        if !oldRect!.equalTo(newRect!) {
+            // https://github.com/react-native-video/react-native-video/issues/3085#issuecomment-1557293391
+            if newRect!.equalTo(UIScreen.main.bounds) {
+                RCTLog("in fullscreen")
+                if (!_fullscreenUncontrolPlayerPresented) {
+                    _fullscreenUncontrolPlayerPresented = true;
+
+                    self.onVideoFullscreenPlayerWillPresent?(["target": self.reactTag as Any])
+                    self.onVideoFullscreenPlayerDidPresent?(["target": self.reactTag as Any])
+                }
+            } else {
+                NSLog("not fullscreen")
+                if (_fullscreenUncontrolPlayerPresented) {
+                    _fullscreenUncontrolPlayerPresented = false;
+
+                    self.onVideoFullscreenPlayerWillDismiss?(["target": self.reactTag as Any])
+                    self.onVideoFullscreenPlayerDidDismiss?(["target": self.reactTag as Any])
+                }
+            }
+
+            self.reactViewController().view.frame = UIScreen.main.bounds
+            self.reactViewController().view.setNeedsLayout()
+        }
+    }
+
+    @objc func handleDidFailToFinishPlaying(notification:NSNotification!) {
+        let error:NSError! = notification.userInfo?[AVPlayerItemFailedToPlayToEndTimeErrorKey] as? NSError
+        onVideoError?(
+            [
+                "error": [
+                    "code": NSNumber(value: (error as NSError).code),
+                    "localizedDescription": error.localizedDescription ?? "",
+                    "localizedFailureReason": (error as NSError).localizedFailureReason ?? "",
+                    "localizedRecoverySuggestion": (error as NSError).localizedRecoverySuggestion ?? "",
+                    "domain": (error as NSError).domain
+                ],
+                "target": reactTag
+            ])
+    }
+
+    @objc func handlePlaybackStalled(notification:NSNotification!) {
+        onPlaybackStalled?(["target": reactTag as Any])
+        _playbackStalled = true
+    }
+
+    @objc func handlePlayerItemDidReachEnd(notification:NSNotification!) {
+        onVideoEnd?(["target": reactTag as Any])
+#if USE_GOOGLE_IMA
+        if notification.object as? AVPlayerItem == _player?.currentItem {
+            _imaAdsManager.getAdsLoader()?.contentComplete()
+        }
+#endif
+        if _repeat {
+            let item:AVPlayerItem! = notification.object as? AVPlayerItem
+            item.seek(to: CMTime.zero, completionHandler: nil)
+            self.applyModifiers()
+        } else {
+            self.setPaused(true);
+            _playerObserver.removePlayerTimeObserver()
+        }
+    }
+
+    //unused
+    //    @objc func handleAVPlayerAccess(notification:NSNotification!) {
+    //        let accessLog:AVPlayerItemAccessLog! = (notification.object as! AVPlayerItem).accessLog()
+    //        let lastEvent:AVPlayerItemAccessLogEvent! = accessLog.events.last
+    //
+    //        /* TODO: get this working
+    //         if (self.onBandwidthUpdate) {
+    //         self.onBandwidthUpdate(@{@"bitrate": [NSNumber numberWithFloat:lastEvent.observedBitrate]});
+    //         }
+    //         */
+    //    }
+}
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoManager.h b/node_modules/react-native-video/ios/Video/RCTVideoManager.h
deleted file mode 100644
index b3bfccb..0000000
--- a/node_modules/react-native-video/ios/Video/RCTVideoManager.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#import <React/RCTViewManager.h>
-#import <React/RCTBridgeModule.h>
-
-@interface RCTVideoManager : RCTViewManager <RCTBridgeModule>
-
-@end
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoManager.m b/node_modules/react-native-video/ios/Video/RCTVideoManager.m
index 000a9e8..178f03d 100644
--- a/node_modules/react-native-video/ios/Video/RCTVideoManager.m
+++ b/node_modules/react-native-video/ios/Video/RCTVideoManager.m
@@ -1,25 +1,12 @@
-#import "RCTVideoManager.h"
-#import "RCTVideo.h"
 #import <React/RCTBridge.h>
-#import <React/RCTUIManager.h>
-#import <AVFoundation/AVFoundation.h>
+#import "React/RCTViewManager.h"
 
-@implementation RCTVideoManager
-
-RCT_EXPORT_MODULE();
-
-- (UIView *)view
-{
-  return [[RCTVideo alloc] initWithEventDispatcher:self.bridge.eventDispatcher];
-}
-
-- (dispatch_queue_t)methodQueue
-{
-    return self.bridge.uiManager.methodQueue;
-}
+@interface RCT_EXTERN_MODULE(RCTVideoManager, RCTViewManager)
 
 RCT_EXPORT_VIEW_PROPERTY(src, NSDictionary);
 RCT_EXPORT_VIEW_PROPERTY(drm, NSDictionary);
+RCT_EXPORT_VIEW_PROPERTY(videoOptions, NSDictionary);
+RCT_EXPORT_VIEW_PROPERTY(adTagUrl, NSString);
 RCT_EXPORT_VIEW_PROPERTY(maxBitRate, float);
 RCT_EXPORT_VIEW_PROPERTY(resizeMode, NSString);
 RCT_EXPORT_VIEW_PROPERTY(repeat, BOOL);
@@ -41,7 +28,6 @@ RCT_EXPORT_VIEW_PROPERTY(ignoreSilentSwitch, NSString);
 RCT_EXPORT_VIEW_PROPERTY(mixWithOthers, NSString);
 RCT_EXPORT_VIEW_PROPERTY(rate, float);
 RCT_EXPORT_VIEW_PROPERTY(seek, NSDictionary);
-RCT_EXPORT_VIEW_PROPERTY(currentTime, float);
 RCT_EXPORT_VIEW_PROPERTY(fullscreen, BOOL);
 RCT_EXPORT_VIEW_PROPERTY(fullscreenAutorotate, BOOL);
 RCT_EXPORT_VIEW_PROPERTY(fullscreenOrientation, NSString);
@@ -49,6 +35,8 @@ RCT_EXPORT_VIEW_PROPERTY(filter, NSString);
 RCT_EXPORT_VIEW_PROPERTY(filterEnabled, BOOL);
 RCT_EXPORT_VIEW_PROPERTY(progressUpdateInterval, float);
 RCT_EXPORT_VIEW_PROPERTY(restoreUserInterfaceForPIPStopCompletionHandler, BOOL);
+RCT_EXPORT_VIEW_PROPERTY(localSourceEncryptionKeyScheme, NSString);
+
 /* Should support: onLoadStart, onLoad, and onError to stay consistent with Image */
 RCT_EXPORT_VIEW_PROPERTY(onVideoLoadStart, RCTDirectEventBlock);
 RCT_EXPORT_VIEW_PROPERTY(onVideoLoad, RCTDirectEventBlock);
@@ -70,64 +58,19 @@ RCT_EXPORT_VIEW_PROPERTY(onPlaybackResume, RCTDirectEventBlock);
 RCT_EXPORT_VIEW_PROPERTY(onPlaybackRateChange, RCTDirectEventBlock);
 RCT_EXPORT_VIEW_PROPERTY(onVideoExternalPlaybackChange, RCTDirectEventBlock);
 RCT_EXPORT_VIEW_PROPERTY(onGetLicense, RCTDirectEventBlock);
-RCT_REMAP_METHOD(save,
-        options:(NSDictionary *)options
+RCT_EXPORT_VIEW_PROPERTY(onPictureInPictureStatusChanged, RCTDirectEventBlock);
+RCT_EXPORT_VIEW_PROPERTY(onRestoreUserInterfaceForPictureInPictureStop, RCTDirectEventBlock);
+RCT_EXPORT_VIEW_PROPERTY(onReceiveAdEvent, RCTDirectEventBlock);
+
+RCT_EXTERN_METHOD(save:(NSDictionary *)options
         reactTag:(nonnull NSNumber *)reactTag
         resolver:(RCTPromiseResolveBlock)resolve
         rejecter:(RCTPromiseRejectBlock)reject)
-{
-    [self.bridge.uiManager prependUIBlock:^(__unused RCTUIManager *uiManager, NSDictionary<NSNumber *, RCTVideo *> *viewRegistry) {
-        RCTVideo *view = viewRegistry[reactTag];
-        if (![view isKindOfClass:[RCTVideo class]]) {
-            RCTLogError(@"Invalid view returned from registry, expecting RCTVideo, got: %@", view);
-        } else {
-            [view save:options resolve:resolve reject:reject];
-        }
-    }];
-};
-RCT_REMAP_METHOD(setLicenseResult,
-         license:(NSString *)license
+
+RCT_EXTERN_METHOD(setLicenseResult:(NSString *)license
          reactTag:(nonnull NSNumber *)reactTag)
-{
-    [self.bridge.uiManager prependUIBlock:^(__unused RCTUIManager *uiManager, NSDictionary<NSNumber *, RCTVideo *> *viewRegistry) {
-        RCTVideo *view = viewRegistry[reactTag];
-        if (![view isKindOfClass:[RCTVideo class]]) {
-            RCTLogError(@"Invalid view returned from registry, expecting RCTVideo, got: %@", view);
-        } else {
-            [view setLicenseResult:license];
-        }
-    }];
-};
 
-RCT_REMAP_METHOD(setLicenseResultError,
-                 error:(NSString *)error
+RCT_EXTERN_METHOD(setLicenseResultError(NSString *)error
                  reactTag:(nonnull NSNumber *)reactTag)
-{
-    [self.bridge.uiManager prependUIBlock:^(__unused RCTUIManager *uiManager, NSDictionary<NSNumber *, RCTVideo *> *viewRegistry) {
-        RCTVideo *view = viewRegistry[reactTag];
-        if (![view isKindOfClass:[RCTVideo class]]) {
-            RCTLogError(@"Invalid view returned from registry, expecting RCTVideo, got: %@", view);
-        } else {
-            [view setLicenseResultError:error];
-        }
-    }];
-};
-RCT_EXPORT_VIEW_PROPERTY(onPictureInPictureStatusChanged, RCTDirectEventBlock);
-RCT_EXPORT_VIEW_PROPERTY(onRestoreUserInterfaceForPictureInPictureStop, RCTDirectEventBlock);
-
-- (NSDictionary *)constantsToExport
-{
-  return @{
-    @"ScaleNone": AVLayerVideoGravityResizeAspect,
-    @"ScaleToFill": AVLayerVideoGravityResize,
-    @"ScaleAspectFit": AVLayerVideoGravityResizeAspect,
-    @"ScaleAspectFill": AVLayerVideoGravityResizeAspectFill
-  };
-}
-
-+ (BOOL)requiresMainQueueSetup
-{
-    return YES;
-}
 
 @end
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoManager.swift b/node_modules/react-native-video/ios/Video/RCTVideoManager.swift
new file mode 100644
index 0000000..d1c73de
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/RCTVideoManager.swift
@@ -0,0 +1,63 @@
+import AVFoundation
+import React
+
+@objc(RCTVideoManager)
+class RCTVideoManager: RCTViewManager {
+    
+    override func view() -> UIView {
+        return RCTVideo(eventDispatcher: bridge.eventDispatcher() as! RCTEventDispatcher)
+    }
+    
+    func methodQueue() -> DispatchQueue {
+        return bridge.uiManager.methodQueue
+    }
+    
+    @objc(save:reactTag:resolver:rejecter:)
+    func save(options: NSDictionary, reactTag: NSNumber, resolve: @escaping RCTPromiseResolveBlock,reject: @escaping RCTPromiseRejectBlock) -> Void {
+        bridge.uiManager.prependUIBlock({_ , viewRegistry in
+            let view = viewRegistry?[reactTag]
+            if !(view is RCTVideo) {
+                RCTLogError("Invalid view returned from registry, expecting RCTVideo, got: %@", String(describing: view))
+            } else if let view = view as? RCTVideo {
+                view.save(options: options, resolve: resolve, reject: reject)
+            }
+        })
+    }
+    
+    @objc(setLicenseResult:reactTag:)
+    func setLicenseResult(license: NSString, reactTag: NSNumber) -> Void {
+        bridge.uiManager.prependUIBlock({_ , viewRegistry in
+            let view = viewRegistry?[reactTag]
+            if !(view is RCTVideo) {
+                RCTLogError("Invalid view returned from registry, expecting RCTVideo, got: %@", String(describing: view))
+            } else if let view = view as? RCTVideo {
+                view.setLicenseResult(license as String)
+            }
+        })
+    }
+    
+    @objc(setLicenseResultError:reactTag:)
+    func setLicenseResultError(error: NSString, reactTag: NSNumber) -> Void {
+        bridge.uiManager.prependUIBlock({_ , viewRegistry in
+            let view = viewRegistry?[reactTag]
+            if !(view is RCTVideo) {
+                RCTLogError("Invalid view returned from registry, expecting RCTVideo, got: %@", String(describing: view))
+            } else if let view = view as? RCTVideo {
+                view.setLicenseResultError(error as String)
+            }
+        })
+    }
+    
+    override func constantsToExport() -> [AnyHashable : Any]? {
+        return [
+            "ScaleNone": AVLayerVideoGravity.resizeAspect,
+            "ScaleToFill": AVLayerVideoGravity.resize,
+            "ScaleAspectFit": AVLayerVideoGravity.resizeAspect,
+            "ScaleAspectFill": AVLayerVideoGravity.resizeAspectFill
+        ]
+    }
+
+    override class func requiresMainQueueSetup() -> Bool {
+        return true
+    }
+}
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewController.h b/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewController.h
deleted file mode 100644
index ed9ebdd..0000000
--- a/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewController.h
+++ /dev/null
@@ -1,20 +0,0 @@
-//
-//  RCTVideoPlayerViewController.h
-//  RCTVideo
-//
-//  Created by Stanisław Chmiela on 31.03.2016.
-//  Copyright © 2016 Facebook. All rights reserved.
-//
-
-#import <AVKit/AVKit.h>
-#import "RCTVideo.h"
-#import "RCTVideoPlayerViewControllerDelegate.h"
-
-@interface RCTVideoPlayerViewController : AVPlayerViewController
-@property (nonatomic, weak) id<RCTVideoPlayerViewControllerDelegate> rctDelegate;
-
-// Optional paramters
-@property (nonatomic, weak) NSString* preferredOrientation;
-@property (nonatomic) BOOL autorotate;
-
-@end
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewController.m b/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewController.m
deleted file mode 100644
index 548a06c..0000000
--- a/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewController.m
+++ /dev/null
@@ -1,43 +0,0 @@
-#import "RCTVideoPlayerViewController.h"
-
-@interface RCTVideoPlayerViewController ()
-
-@end
-
-@implementation RCTVideoPlayerViewController
-
-- (BOOL)shouldAutorotate {
-
-  if (self.autorotate || self.preferredOrientation.lowercaseString == nil || [self.preferredOrientation.lowercaseString isEqualToString:@"all"])
-    return YES;
-  
-  return NO;
-}
-
-- (void)viewDidDisappear:(BOOL)animated
-{
-  [super viewDidDisappear:animated];
-  [_rctDelegate videoPlayerViewControllerWillDismiss:self];
-  [_rctDelegate videoPlayerViewControllerDidDismiss:self];
-}
-
-#if !TARGET_OS_TV
-- (UIInterfaceOrientationMask)supportedInterfaceOrientations {
-  return UIInterfaceOrientationMaskAll;
-}
-
-- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {
-  if ([self.preferredOrientation.lowercaseString isEqualToString:@"landscape"]) {
-    return UIInterfaceOrientationLandscapeRight;
-  }
-  else if ([self.preferredOrientation.lowercaseString isEqualToString:@"portrait"]) {
-    return UIInterfaceOrientationPortrait;
-  }
-  else { // default case
-    UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;
-    return orientation;
-  }
-}
-#endif
-
-@end
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewController.swift b/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewController.swift
new file mode 100644
index 0000000..1abbc38
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewController.swift
@@ -0,0 +1,45 @@
+import AVKit
+
+class RCTVideoPlayerViewController: AVPlayerViewController {
+    
+    weak var rctDelegate: RCTVideoPlayerViewControllerDelegate?
+    
+    // Optional paramters
+    var preferredOrientation:String?
+    var autorotate:Bool?
+    
+    func shouldAutorotate() -> Bool {
+
+        if autorotate! || preferredOrientation == nil || (preferredOrientation!.lowercased() == "all") {
+            return true
+        }
+
+        return false
+    }
+
+    override func viewDidDisappear(_ animated: Bool) {
+        super.viewDidDisappear(animated)
+        
+        rctDelegate?.videoPlayerViewControllerWillDismiss(playerViewController: self)
+        rctDelegate?.videoPlayerViewControllerDidDismiss(playerViewController: self)
+    }
+
+    #if !TARGET_OS_TV
+
+    func supportedInterfaceOrientations() -> UIInterfaceOrientationMask {
+        return .all
+    }
+
+    func preferredInterfaceOrientationForPresentation() -> UIInterfaceOrientation {
+        if preferredOrientation?.lowercased() == "landscape" {
+            return .landscapeRight
+        } else if preferredOrientation?.lowercased() == "portrait" {
+            return .portrait
+        } else {
+            // default case
+            let orientation = UIApplication.shared.statusBarOrientation
+            return orientation
+        }
+    }
+    #endif
+}
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewControllerDelegate.h b/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewControllerDelegate.h
deleted file mode 100644
index e84b3f5..0000000
--- a/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewControllerDelegate.h
+++ /dev/null
@@ -1,7 +0,0 @@
-#import <Foundation/Foundation.h>
-#import "AVKit/AVKit.h"
-
-@protocol RCTVideoPlayerViewControllerDelegate <NSObject>
-- (void)videoPlayerViewControllerWillDismiss:(AVPlayerViewController *)playerViewController;
-- (void)videoPlayerViewControllerDidDismiss:(AVPlayerViewController *)playerViewController;
-@end
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewControllerDelegate.swift b/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewControllerDelegate.swift
new file mode 100644
index 0000000..6635975
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/RCTVideoPlayerViewControllerDelegate.swift
@@ -0,0 +1,7 @@
+import Foundation
+import AVKit
+
+protocol RCTVideoPlayerViewControllerDelegate : NSObject {
+    func videoPlayerViewControllerWillDismiss(playerViewController:AVPlayerViewController)
+    func videoPlayerViewControllerDidDismiss(playerViewController:AVPlayerViewController)
+}
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoSwiftLog/RCTVideoSwiftLog.h b/node_modules/react-native-video/ios/Video/RCTVideoSwiftLog/RCTVideoSwiftLog.h
new file mode 100644
index 0000000..f9978dc
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/RCTVideoSwiftLog/RCTVideoSwiftLog.h
@@ -0,0 +1,11 @@
+#import <Foundation/Foundation.h>
+
+@interface RCTVideoSwiftLog : NSObject
+
++ (void)error:(NSString * _Nonnull)message file:(NSString * _Nonnull)file line:(NSUInteger)line;
++ (void)warn:(NSString * _Nonnull)message file:(NSString * _Nonnull)file line:(NSUInteger)line;
++ (void)info:(NSString * _Nonnull)message file:(NSString * _Nonnull)file line:(NSUInteger)line;
++ (void)log:(NSString * _Nonnull)message file:(NSString * _Nonnull)file line:(NSUInteger)line;
++ (void)trace:(NSString * _Nonnull)message file:(NSString * _Nonnull)file line:(NSUInteger)line;
+
+@end
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoSwiftLog/RCTVideoSwiftLog.m b/node_modules/react-native-video/ios/Video/RCTVideoSwiftLog/RCTVideoSwiftLog.m
new file mode 100644
index 0000000..61a38b1
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/RCTVideoSwiftLog/RCTVideoSwiftLog.m
@@ -0,0 +1,32 @@
+#import <React/RCTLog.h>
+
+#import "RCTVideoSwiftLog.h"
+
+@implementation RCTVideoSwiftLog
+
++ (void)info:(NSString *)message file:(NSString *)file line:(NSUInteger)line
+{
+    _RCTLogNativeInternal(RCTLogLevelInfo, file.UTF8String, (int)line, @"%@", message);
+}
+
++ (void)warn:(NSString *)message file:(NSString *)file line:(NSUInteger)line
+{
+    _RCTLogNativeInternal(RCTLogLevelWarning, file.UTF8String, (int)line, @"%@", message);
+}
+
++ (void)error:(NSString *)message file:(NSString *)file line:(NSUInteger)line
+{
+    _RCTLogNativeInternal(RCTLogLevelError, file.UTF8String, (int)line, @"%@", message);
+}
+
++ (void)log:(NSString *)message file:(NSString *)file line:(NSUInteger)line
+{
+    _RCTLogNativeInternal(RCTLogLevelInfo, file.UTF8String, (int)line, @"%@", message);
+}
+
++ (void)trace:(NSString *)message file:(NSString *)file line:(NSUInteger)line
+{
+    _RCTLogNativeInternal(RCTLogLevelTrace, file.UTF8String, (int)line, @"%@", message);
+}
+
+@end
diff --git a/node_modules/react-native-video/ios/Video/RCTVideoSwiftLog/RCTVideoSwiftLog.swift b/node_modules/react-native-video/ios/Video/RCTVideoSwiftLog/RCTVideoSwiftLog.swift
new file mode 100644
index 0000000..0e0e169
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/RCTVideoSwiftLog/RCTVideoSwiftLog.swift
@@ -0,0 +1,55 @@
+//
+//  RCTLog.swift
+//  WebViewExample
+//
+//  Created by Jimmy Dee on 4/5/17.
+//  Copyright © 2017 Branch Metrics. All rights reserved.
+//
+
+/*
+ * Under at least some conditions, output from NSLog has been unavailable in the RNBranch module.
+ * Hence that module uses the RCTLog macros from <React/RCTLog.h>. The React logger is nicer than
+ * NSLog anyway, since it provides log levels with runtime filtering, file and line context and
+ * an identifier for the thread that logged the message.
+ *
+ * This wrapper lets you use functions with the same name in Swift. For example:
+ *
+ * RCTLogInfo("application launched")
+ *
+ * generates
+ *
+ * 2017-04-06 12:31:09.611 [info][tid:main][AppDelegate.swift:18] application launched
+ *
+ * This is currently part of this sample app. There may be some issues integrating it into an
+ * Objective-C library, either react-native-branch or react-native itself, but it may find its
+ * way into one or the other eventually. Feel free to reuse it as desired.
+ */
+
+let logHeader: String = "RNV:"
+
+func RCTLogError(_ message: String, _ file: String=#file, _ line: UInt=#line) {
+    RCTVideoSwiftLog.error(logHeader + message, file: file, line: line)
+}
+
+func RCTLogWarn(_ message: String, _ file: String=#file, _ line: UInt=#line) {
+    RCTVideoSwiftLog.warn(logHeader + message, file: file, line: line)
+}
+
+func RCTLogInfo(_ message: String, _ file: String=#file, _ line: UInt=#line) {
+    RCTVideoSwiftLog.info(logHeader + message, file: file, line: line)
+}
+
+func RCTLog(_ message: String, _ file: String=#file, _ line: UInt=#line) {
+    RCTVideoSwiftLog.log(logHeader + message, file: file, line: line)
+}
+
+func RCTLogTrace(_ message: String, _ file: String=#file, _ line: UInt=#line) {
+    RCTVideoSwiftLog.trace(logHeader + message, file: file, line: line)
+}
+
+func DebugLog(_ message: String) {
+#if DEBUG
+    print(logHeader + message)
+#endif
+}
+
diff --git a/node_modules/react-native-video/ios/Video/UIView+FindUIViewController.h b/node_modules/react-native-video/ios/Video/UIView+FindUIViewController.h
deleted file mode 100644
index 0921426..0000000
--- a/node_modules/react-native-video/ios/Video/UIView+FindUIViewController.h
+++ /dev/null
@@ -1,15 +0,0 @@
-//
-//  UIView+FindUIViewController.h
-//  RCTVideo
-//
-//  Created by Stanisław Chmiela on 31.03.2016.
-//  Copyright © 2016 Facebook. All rights reserved.
-//
-//  Source: http://stackoverflow.com/a/3732812/1123156
-
-#import <UIKit/UIKit.h>
-
-@interface UIView (FindUIViewController)
-- (UIViewController *) firstAvailableUIViewController;
-- (id) traverseResponderChainForUIViewController;
-@end
diff --git a/node_modules/react-native-video/ios/Video/UIView+FindUIViewController.m b/node_modules/react-native-video/ios/Video/UIView+FindUIViewController.m
deleted file mode 100644
index c29c742..0000000
--- a/node_modules/react-native-video/ios/Video/UIView+FindUIViewController.m
+++ /dev/null
@@ -1,21 +0,0 @@
-//  Source: http://stackoverflow.com/a/3732812/1123156
-
-#import "UIView+FindUIViewController.h"
-
-@implementation UIView (FindUIViewController)
-- (UIViewController *) firstAvailableUIViewController {
-    // convenience function for casting and to "mask" the recursive function
-    return (UIViewController *)[self traverseResponderChainForUIViewController];
-}
-
-- (id) traverseResponderChainForUIViewController {
-    id nextResponder = [self nextResponder];
-    if ([nextResponder isKindOfClass:[UIViewController class]]) {
-        return nextResponder;
-    } else if ([nextResponder isKindOfClass:[UIView class]]) {
-        return [nextResponder traverseResponderChainForUIViewController];
-    } else {
-        return nil;
-    }
-}
-@end
diff --git a/node_modules/react-native-video/ios/Video/UIView+FindUIViewController.swift b/node_modules/react-native-video/ios/Video/UIView+FindUIViewController.swift
new file mode 100644
index 0000000..2947e1e
--- /dev/null
+++ b/node_modules/react-native-video/ios/Video/UIView+FindUIViewController.swift
@@ -0,0 +1,18 @@
+//  Source: http://stackoverflow.com/a/3732812/1123156
+
+extension UIView {
+    func firstAvailableUIViewController() -> UIViewController? {
+        // convenience function for casting and to "mask" the recursive function
+        return traverseResponderChainForUIViewController()
+    }
+
+    func traverseResponderChainForUIViewController() -> UIViewController? {
+        if let nextUIViewController = next as? UIViewController {
+            return nextUIViewController
+        } else if let nextUIView = next as? UIView {
+            return nextUIView.traverseResponderChainForUIViewController()
+        } else {
+            return nil
+        }
+    }
+}
diff --git a/node_modules/react-native-video/ios/VideoCaching/RCTVideoCache.m b/node_modules/react-native-video/ios/VideoCaching/RCTVideoCache.m
index 1a2b83a..05ad65d 100644
--- a/node_modules/react-native-video/ios/VideoCaching/RCTVideoCache.m
+++ b/node_modules/react-native-video/ios/VideoCaching/RCTVideoCache.m
@@ -30,7 +30,7 @@
     options.useDirectorySeparation = NO;
 #ifdef DEBUG
     options.debugOutput = ^(NSString *string) {
-      NSLog(@"Video Cache: %@", string);
+      RCTLog(@"Video Cache: %@", string);
     };
 #endif
     [self createTemporaryPath];
@@ -48,7 +48,7 @@
                                                                  error:&error];
 #ifdef DEBUG
   if (!success || error) {
-    NSLog(@"Error while! %@", error);
+    RCTLog(@"Error while! %@", error);
   }
 #endif
 }
@@ -64,7 +64,7 @@
   [self.videoCache storeData:data forKey:key locked:NO withCallback:^(SPTPersistentCacheResponse * _Nonnull response) {
     if (response.error) {
 #ifdef DEBUG
-      NSLog(@"An error occured while saving the video into the cache: %@", [response.error localizedDescription]);
+      RCTLog(@"An error occured while saving the video into the cache: %@", [response.error localizedDescription]);
 #endif
       handler(NO);
       return;
diff --git a/node_modules/react-native-video/ios/VideoCaching/RCTVideoCachingHandler.swift b/node_modules/react-native-video/ios/VideoCaching/RCTVideoCachingHandler.swift
new file mode 100644
index 0000000..5f6ffb7
--- /dev/null
+++ b/node_modules/react-native-video/ios/VideoCaching/RCTVideoCachingHandler.swift
@@ -0,0 +1,87 @@
+import Foundation
+import AVFoundation
+import DVAssetLoaderDelegate
+import Promises
+
+class RCTVideoCachingHandler: NSObject, DVAssetLoaderDelegatesDelegate {
+    
+    private var _videoCache:RCTVideoCache! = RCTVideoCache.sharedInstance()
+    var playerItemPrepareText: ((AVAsset?, NSDictionary?) -> AVPlayerItem)?
+    
+    override init() {
+        super.init()
+    }
+    
+    func shouldCache(source: VideoSource, textTracks:[TextTrack]?) -> Bool {
+        if source.isNetwork && source.shouldCache && ((textTracks == nil) || (textTracks!.count == 0)) {
+            /* The DVURLAsset created by cache doesn't have a tracksWithMediaType property, so trying
+             * to bring in the text track code will crash. I suspect this is because the asset hasn't fully loaded.
+             * Until this is fixed, we need to bypass caching when text tracks are specified.
+             */
+            DebugLog("Caching is not supported for uri '\(source.uri)' because text tracks are not compatible with the cache. Checkout https://github.com/react-native-community/react-native-video/blob/master/docs/caching.md")
+            return true
+        }
+        return false
+    }
+    
+    func playerItemForSourceUsingCache(uri:String!, assetOptions options:NSDictionary!) -> Promise<AVPlayerItem?> {
+        let url = URL(string: uri)
+        return getItemForUri(uri)
+        .then{ [weak self] (videoCacheStatus:RCTVideoCacheStatus,cachedAsset:AVAsset?) -> AVPlayerItem in
+            guard let self = self, let playerItemPrepareText = self.playerItemPrepareText else {throw  NSError(domain: "", code: 0, userInfo: nil)}
+            switch (videoCacheStatus) {
+            case .missingFileExtension:
+                DebugLog("Could not generate cache key for uri '\(uri)'. It is currently not supported to cache urls that do not include a file extension. The video file will not be cached. Checkout https://github.com/react-native-community/react-native-video/blob/master/docs/caching.md")
+                let asset:AVURLAsset! = AVURLAsset(url: url!, options:options as! [String : Any])
+                return playerItemPrepareText(asset, options)
+                
+            case .unsupportedFileExtension:
+                DebugLog("Could not generate cache key for uri '\(uri)'. The file extension of that uri is currently not supported. The video file will not be cached. Checkout https://github.com/react-native-community/react-native-video/blob/master/docs/caching.md")
+                let asset:AVURLAsset! = AVURLAsset(url: url!, options:options as! [String : Any])
+                return playerItemPrepareText(asset, options)
+                
+            default:
+                if let cachedAsset = cachedAsset {
+                    DebugLog("Playing back uri '\(uri)' from cache")
+                    // See note in playerItemForSource about not being able to support text tracks & caching
+                    return AVPlayerItem(asset: cachedAsset)
+                }
+            }
+            
+            let asset:DVURLAsset! = DVURLAsset(url:url, options:options as! [String : Any], networkTimeout:10000)
+            asset.loaderDelegate = self
+            
+            /* More granular code to have control over the DVURLAsset
+             let resourceLoaderDelegate = DVAssetLoaderDelegate(url: url)
+             resourceLoaderDelegate.delegate = self
+             let components = NSURLComponents(url: url, resolvingAgainstBaseURL: false)
+             components?.scheme = DVAssetLoaderDelegate.scheme()
+             var asset: AVURLAsset? = nil
+             if let url = components?.url {
+             asset = AVURLAsset(url: url, options: options)
+             }
+             asset?.resourceLoader.setDelegate(resourceLoaderDelegate, queue: DispatchQueue.main)
+             */
+            
+            return AVPlayerItem(asset: asset)
+        }
+    }
+
+    func getItemForUri(_ uri:String) ->  Promise<(videoCacheStatus:RCTVideoCacheStatus,cachedAsset:AVAsset?)> {
+        return Promise<(videoCacheStatus:RCTVideoCacheStatus,cachedAsset:AVAsset?)> { fulfill, reject in
+            self._videoCache.getItemForUri(uri, withCallback:{ (videoCacheStatus:RCTVideoCacheStatus,cachedAsset:AVAsset?) in
+                fulfill((videoCacheStatus, cachedAsset))
+            })
+        }
+    }
+    
+    // MARK: - DVAssetLoaderDelegate
+    
+    func dvAssetLoaderDelegate(loaderDelegate:DVAssetLoaderDelegate!, didLoadData data:NSData!, forURL url:NSURL!) {
+        _videoCache.storeItem(data as Data?, forUri:url.absoluteString, withCallback:{ (success:Bool) in
+            DebugLog("Cache data stored successfully 🎉")
+        })
+    }
+    
+}
+
diff --git a/node_modules/react-native-video/react-native-video.podspec b/node_modules/react-native-video/react-native-video.podspec
index 7013f95..45710b3 100644
--- a/node_modules/react-native-video/react-native-video.podspec
+++ b/node_modules/react-native-video/react-native-video.podspec
@@ -9,15 +9,25 @@ Pod::Spec.new do |s|
   s.description    = package['description']
   s.license        = package['license']
   s.author         = package['author']
-  s.homepage       = 'https://github.com/react-native-community/react-native-video'
-  s.source       = { :git => "https://github.com/react-native-community/react-native-video.git", :tag => "#{s.version}" }
+  s.homepage       = 'https://github.com/react-native-video/react-native-video'
+  s.source       = { :git => "https://github.com/react-native-video/react-native-video.git", :tag => "v#{s.version}" }
 
-  s.ios.deployment_target = "8.0"
+  s.ios.deployment_target = "9.0"
   s.tvos.deployment_target = "9.0"
 
   s.subspec "Video" do |ss|
-    ss.source_files  = "ios/Video/*.{h,m}"
-    s.static_framework = true
+    ss.source_files  = "ios/Video/**/*.{h,m,swift}"
+    ss.dependency "PromisesSwift"
+
+    if defined?($RNVideoUseGoogleIMA)
+      Pod::UI.puts "RNVideo: enable IMA SDK"
+
+      ss.ios.dependency 'GoogleAds-IMA-iOS-SDK', '~> 3.18.1'
+      ss.tvos.dependency 'GoogleAds-IMA-tvOS-SDK', '~> 4.2'
+      ss.pod_target_xcconfig = {
+        'OTHER_SWIFT_FLAGS' => '$(inherited) -D USE_GOOGLE_IMA'
+      }
+    end
   end
 
   s.subspec "VideoCaching" do |ss|
@@ -25,14 +35,15 @@ Pod::Spec.new do |s|
     ss.dependency "SPTPersistentCache", "~> 1.1.0"
     ss.dependency "DVAssetLoaderDelegate", "~> 0.3.1"
 
-    ss.source_files = "ios/VideoCaching/**/*.{h,m}"
-    s.static_framework = true
+    ss.source_files = "ios/VideoCaching/**/*.{h,m,swift}"
   end
 
   s.dependency "React-Core"
 
   s.default_subspec = "Video"
 
+  s.static_framework = true
+
   s.xcconfig = {
     'OTHER_LDFLAGS': '-ObjC',
   }
diff --git a/node_modules/react-native-video/windows/.npmignore b/node_modules/react-native-video/windows/.npmignore
deleted file mode 100644
index e6def50..0000000
--- a/node_modules/react-native-video/windows/.npmignore
+++ /dev/null
@@ -1,9 +0,0 @@
-
-# Make sure we don't publish build artifacts to NPM
-ARM/
-Debug/
-x64/
-x86/
-bin/
-obj/
-.vs/
diff --git a/node_modules/react-native-video/windows/ReactNativeVideoCPP.sln b/node_modules/react-native-video/windows/ReactNativeVideoCPP.sln
index 3c3f4db..940cdf4 100644
--- a/node_modules/react-native-video/windows/ReactNativeVideoCPP.sln
+++ b/node_modules/react-native-video/windows/ReactNativeVideoCPP.sln
@@ -45,158 +45,119 @@ Global
 		..\node_modules\react-native-windows\Shared\Shared.vcxitems*{f7d32bd0-2749-483e-9a0d-1635ef7e3136}*SharedItemsImports = 4
 	EndGlobalSection
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|ARM = Debug|ARM
 		Debug|ARM64 = Debug|ARM64
 		Debug|x64 = Debug|x64
 		Debug|x86 = Debug|x86
-		Release|ARM = Release|ARM
 		Release|ARM64 = Release|ARM64
 		Release|x64 = Release|x64
 		Release|x86 = Release|x86
-		WinUI3|ARM = WinUI3|ARM
 		WinUI3|ARM64 = WinUI3|ARM64
 		WinUI3|x64 = WinUI3|x64
 		WinUI3|x86 = WinUI3|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|ARM.ActiveCfg = Debug|ARM
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|ARM.Build.0 = Debug|ARM
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|ARM64.Build.0 = Debug|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|x64.ActiveCfg = Debug|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|x64.Build.0 = Debug|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|x86.ActiveCfg = Debug|Win32
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|x86.Build.0 = Debug|Win32
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|ARM.ActiveCfg = Release|ARM
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|ARM.Build.0 = Release|ARM
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|ARM64.ActiveCfg = Release|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|ARM64.Build.0 = Release|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|x64.ActiveCfg = Release|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|x64.Build.0 = Release|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|x86.ActiveCfg = Release|Win32
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|x86.Build.0 = Release|Win32
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|ARM.Build.0 = Release|ARM
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|x64.ActiveCfg = Release|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|x64.Build.0 = Release|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|x86.ActiveCfg = Release|Win32
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|x86.Build.0 = Release|Win32
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM.ActiveCfg = Debug|ARM
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM.Build.0 = Debug|ARM
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM64.Build.0 = Debug|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x64.ActiveCfg = Debug|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x64.Build.0 = Debug|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x86.ActiveCfg = Debug|Win32
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x86.Build.0 = Debug|Win32
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM.ActiveCfg = Release|ARM
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM.Build.0 = Release|ARM
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM64.ActiveCfg = Release|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM64.Build.0 = Release|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x64.ActiveCfg = Release|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x64.Build.0 = Release|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x86.ActiveCfg = Release|Win32
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x86.Build.0 = Release|Win32
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|ARM.Build.0 = Release|ARM
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|x64.ActiveCfg = Release|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|x64.Build.0 = Release|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|x86.ActiveCfg = Release|Win32
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|x86.Build.0 = Release|Win32
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM.ActiveCfg = Debug|ARM
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM.Build.0 = Debug|ARM
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM64.Build.0 = Debug|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x64.ActiveCfg = Debug|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x64.Build.0 = Debug|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x86.ActiveCfg = Debug|Win32
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x86.Build.0 = Debug|Win32
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM.ActiveCfg = Release|ARM
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM.Build.0 = Release|ARM
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM64.ActiveCfg = Release|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM64.Build.0 = Release|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x64.ActiveCfg = Release|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x64.Build.0 = Release|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x86.ActiveCfg = Release|Win32
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x86.Build.0 = Release|Win32
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|ARM.Build.0 = Release|ARM
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|x64.ActiveCfg = Release|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|x64.Build.0 = Release|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|x86.ActiveCfg = Release|Win32
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|x86.Build.0 = Release|Win32
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM.ActiveCfg = Debug|ARM
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM.Build.0 = Debug|ARM
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM64.Build.0 = Debug|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x64.ActiveCfg = Debug|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x64.Build.0 = Debug|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x86.ActiveCfg = Debug|Win32
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x86.Build.0 = Debug|Win32
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM.ActiveCfg = Release|ARM
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM.Build.0 = Release|ARM
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM64.ActiveCfg = Release|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM64.Build.0 = Release|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x64.ActiveCfg = Release|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x64.Build.0 = Release|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x86.ActiveCfg = Release|Win32
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x86.Build.0 = Release|Win32
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|ARM.Build.0 = Release|ARM
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|x64.ActiveCfg = Release|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|x64.Build.0 = Release|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|x86.ActiveCfg = Release|Win32
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|x86.Build.0 = Release|Win32
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM.ActiveCfg = Debug|ARM
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM.Build.0 = Debug|ARM
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM64.Build.0 = Debug|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x64.ActiveCfg = Debug|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x64.Build.0 = Debug|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x86.ActiveCfg = Debug|Win32
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x86.Build.0 = Debug|Win32
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM.ActiveCfg = Release|ARM
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM.Build.0 = Release|ARM
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM64.ActiveCfg = Release|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM64.Build.0 = Release|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x64.ActiveCfg = Release|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x64.Build.0 = Release|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x86.ActiveCfg = Release|Win32
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x86.Build.0 = Release|Win32
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|ARM.Build.0 = Release|ARM
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|x64.ActiveCfg = Release|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|x64.Build.0 = Release|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|x86.ActiveCfg = Release|Win32
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|x86.Build.0 = Release|Win32
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM.ActiveCfg = Debug|ARM
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM.Build.0 = Debug|ARM
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM64.Build.0 = Debug|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x64.ActiveCfg = Debug|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x64.Build.0 = Debug|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x86.ActiveCfg = Debug|Win32
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x86.Build.0 = Debug|Win32
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM.ActiveCfg = Release|ARM
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM.Build.0 = Release|ARM
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM64.ActiveCfg = Release|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM64.Build.0 = Release|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x64.ActiveCfg = Release|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x64.Build.0 = Release|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x86.ActiveCfg = Release|Win32
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x86.Build.0 = Release|Win32
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|ARM.Build.0 = Release|ARM
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|x64.ActiveCfg = Release|x64
diff --git a/node_modules/react-native-video/windows/ReactNativeVideoCPP/ReactNativeVideoCPP.vcxproj b/node_modules/react-native-video/windows/ReactNativeVideoCPP/ReactNativeVideoCPP.vcxproj
index 83bddbf..c0cc10e 100644
--- a/node_modules/react-native-video/windows/ReactNativeVideoCPP/ReactNativeVideoCPP.vcxproj
+++ b/node_modules/react-native-video/windows/ReactNativeVideoCPP/ReactNativeVideoCPP.vcxproj
@@ -13,7 +13,7 @@
     <AppContainerApplication>true</AppContainerApplication>
     <ApplicationType>Windows Store</ApplicationType>
     <ApplicationTypeRevision>10.0</ApplicationTypeRevision>
-    <WindowsTargetPlatformVersion Condition=" '$(WindowsTargetPlatformVersion)' == '' ">10.0.18362.0</WindowsTargetPlatformVersion>
+    <WindowsTargetPlatformVersion Condition=" '$(WindowsTargetPlatformVersion)' == '' ">10.0</WindowsTargetPlatformVersion>
     <WindowsTargetPlatformMinVersion>10.0.16299.0</WindowsTargetPlatformMinVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -21,10 +21,6 @@
     <ReactNativeWindowsDir Condition="'$(ReactNativeWindowsDir)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(SolutionDir), 'node_modules\react-native-windows\package.json'))\node_modules\react-native-windows\</ReactNativeWindowsDir>
   </PropertyGroup>
   <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|ARM">
-      <Configuration>Debug</Configuration>
-      <Platform>ARM</Platform>
-    </ProjectConfiguration>
     <ProjectConfiguration Include="Debug|ARM64">
       <Configuration>Debug</Configuration>
       <Platform>ARM64</Platform>
@@ -37,10 +33,6 @@
       <Configuration>Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|ARM">
-      <Configuration>Release</Configuration>
-      <Platform>ARM</Platform>
-    </ProjectConfiguration>
     <ProjectConfiguration Include="Release|ARM64">
       <Configuration>Release</Configuration>
       <Platform>ARM64</Platform>
diff --git a/node_modules/react-native-video/windows/ReactNativeVideoCPP61.sln b/node_modules/react-native-video/windows/ReactNativeVideoCPP61.sln
index 043183d..b8cc040 100644
--- a/node_modules/react-native-video/windows/ReactNativeVideoCPP61.sln
+++ b/node_modules/react-native-video/windows/ReactNativeVideoCPP61.sln
@@ -53,121 +53,91 @@ Global
 		..\node_modules\react-native-windows\Shared\Shared.vcxitems*{f7d32bd0-2749-483e-9a0d-1635ef7e3136}*SharedItemsImports = 4
 	EndGlobalSection
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|ARM = Debug|ARM
 		Debug|ARM64 = Debug|ARM64
 		Debug|x64 = Debug|x64
 		Debug|x86 = Debug|x86
-		Release|ARM = Release|ARM
 		Release|ARM64 = Release|ARM64
 		Release|x64 = Release|x64
 		Release|x86 = Release|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM.ActiveCfg = Debug|ARM
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM.Build.0 = Debug|ARM
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM64.Build.0 = Debug|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x64.ActiveCfg = Debug|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x64.Build.0 = Debug|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x86.ActiveCfg = Debug|Win32
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x86.Build.0 = Debug|Win32
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM.ActiveCfg = Release|ARM
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM.Build.0 = Release|ARM
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM64.ActiveCfg = Release|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM64.Build.0 = Release|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x64.ActiveCfg = Release|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x64.Build.0 = Release|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x86.ActiveCfg = Release|Win32
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x86.Build.0 = Release|Win32
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM.ActiveCfg = Debug|ARM
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM.Build.0 = Debug|ARM
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM64.Build.0 = Debug|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x64.ActiveCfg = Debug|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x64.Build.0 = Debug|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x86.ActiveCfg = Debug|Win32
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x86.Build.0 = Debug|Win32
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM.ActiveCfg = Release|ARM
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM.Build.0 = Release|ARM
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM64.ActiveCfg = Release|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM64.Build.0 = Release|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x64.ActiveCfg = Release|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x64.Build.0 = Release|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x86.ActiveCfg = Release|Win32
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x86.Build.0 = Release|Win32
-		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|ARM.ActiveCfg = Debug|ARM
-		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|ARM.Build.0 = Debug|ARM
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|ARM64.Build.0 = Debug|ARM64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|x64.ActiveCfg = Debug|x64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|x64.Build.0 = Debug|x64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|x86.ActiveCfg = Debug|Win32
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|x86.Build.0 = Debug|Win32
-		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|ARM.ActiveCfg = Release|ARM
-		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|ARM.Build.0 = Release|ARM
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|ARM64.ActiveCfg = Release|ARM64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|ARM64.Build.0 = Release|ARM64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|x64.ActiveCfg = Release|x64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|x64.Build.0 = Release|x64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|x86.ActiveCfg = Release|Win32
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|x86.Build.0 = Release|Win32
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM.ActiveCfg = Debug|ARM
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM.Build.0 = Debug|ARM
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM64.Build.0 = Debug|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x64.ActiveCfg = Debug|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x64.Build.0 = Debug|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x86.ActiveCfg = Debug|Win32
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x86.Build.0 = Debug|Win32
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM.ActiveCfg = Release|ARM
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM.Build.0 = Release|ARM
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM64.ActiveCfg = Release|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM64.Build.0 = Release|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x64.ActiveCfg = Release|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x64.Build.0 = Release|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x86.ActiveCfg = Release|Win32
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x86.Build.0 = Release|Win32
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM.ActiveCfg = Debug|ARM
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM.Build.0 = Debug|ARM
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM64.Build.0 = Debug|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x64.ActiveCfg = Debug|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x64.Build.0 = Debug|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x86.ActiveCfg = Debug|Win32
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x86.Build.0 = Debug|Win32
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM.ActiveCfg = Release|ARM
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM.Build.0 = Release|ARM
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM64.ActiveCfg = Release|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM64.Build.0 = Release|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x64.ActiveCfg = Release|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x64.Build.0 = Release|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x86.ActiveCfg = Release|Win32
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x86.Build.0 = Release|Win32
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM.ActiveCfg = Debug|ARM
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM.Build.0 = Debug|ARM
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM64.Build.0 = Debug|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x64.ActiveCfg = Debug|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x64.Build.0 = Debug|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x86.ActiveCfg = Debug|Win32
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x86.Build.0 = Debug|Win32
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM.ActiveCfg = Release|ARM
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM.Build.0 = Release|ARM
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM64.ActiveCfg = Release|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM64.Build.0 = Release|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x64.ActiveCfg = Release|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x64.Build.0 = Release|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x86.ActiveCfg = Release|Win32
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x86.Build.0 = Release|Win32
-		{765365E4-9553-4900-9F69-E26D4309C8DA}.Debug|ARM.ActiveCfg = Debug|ARM
-		{765365E4-9553-4900-9F69-E26D4309C8DA}.Debug|ARM.Build.0 = Debug|ARM
 		{765365E4-9553-4900-9F69-E26D4309C8DA}.Debug|ARM64.ActiveCfg = Debug|Win32
 		{765365E4-9553-4900-9F69-E26D4309C8DA}.Debug|x64.ActiveCfg = Debug|x64
 		{765365E4-9553-4900-9F69-E26D4309C8DA}.Debug|x64.Build.0 = Debug|x64
 		{765365E4-9553-4900-9F69-E26D4309C8DA}.Debug|x86.ActiveCfg = Debug|Win32
 		{765365E4-9553-4900-9F69-E26D4309C8DA}.Debug|x86.Build.0 = Debug|Win32
-		{765365E4-9553-4900-9F69-E26D4309C8DA}.Release|ARM.ActiveCfg = Release|ARM
-		{765365E4-9553-4900-9F69-E26D4309C8DA}.Release|ARM.Build.0 = Release|ARM
 		{765365E4-9553-4900-9F69-E26D4309C8DA}.Release|ARM64.ActiveCfg = Release|Win32
 		{765365E4-9553-4900-9F69-E26D4309C8DA}.Release|x64.ActiveCfg = Release|x64
 		{765365E4-9553-4900-9F69-E26D4309C8DA}.Release|x64.Build.0 = Release|x64
diff --git a/node_modules/react-native-video/windows/ReactNativeVideoCPP61/ReactNativeVideoCPP61.vcxproj b/node_modules/react-native-video/windows/ReactNativeVideoCPP61/ReactNativeVideoCPP61.vcxproj
index 90c7430..588c0bc 100644
--- a/node_modules/react-native-video/windows/ReactNativeVideoCPP61/ReactNativeVideoCPP61.vcxproj
+++ b/node_modules/react-native-video/windows/ReactNativeVideoCPP61/ReactNativeVideoCPP61.vcxproj
@@ -21,10 +21,6 @@
     <ReactNativeWindowsDir Condition="'$(ReactNativeWindowsDir)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(SolutionDir), 'node_modules\react-native-windows\package.json'))\node_modules\react-native-windows\</ReactNativeWindowsDir>
   </PropertyGroup>
   <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|ARM">
-      <Configuration>Debug</Configuration>
-      <Platform>ARM</Platform>
-    </ProjectConfiguration>
     <ProjectConfiguration Include="Debug|ARM64">
       <Configuration>Debug</Configuration>
       <Platform>ARM64</Platform>
@@ -37,10 +33,6 @@
       <Configuration>Debug</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|ARM">
-      <Configuration>Release</Configuration>
-      <Platform>ARM</Platform>
-    </ProjectConfiguration>
     <ProjectConfiguration Include="Release|ARM64">
       <Configuration>Release</Configuration>
       <Platform>ARM64</Platform>
diff --git a/node_modules/react-native-video/windows/ReactNativeVideoCPP62.sln b/node_modules/react-native-video/windows/ReactNativeVideoCPP62.sln
index 4ab5516..bac50f4 100644
--- a/node_modules/react-native-video/windows/ReactNativeVideoCPP62.sln
+++ b/node_modules/react-native-video/windows/ReactNativeVideoCPP62.sln
@@ -48,182 +48,137 @@ Global
 		..\node_modules\react-native-windows\Shared\Shared.vcxitems*{f7d32bd0-2749-483e-9a0d-1635ef7e3136}*SharedItemsImports = 4
 	EndGlobalSection
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|ARM = Debug|ARM
 		Debug|ARM64 = Debug|ARM64
 		Debug|x64 = Debug|x64
 		Debug|x86 = Debug|x86
-		Release|ARM = Release|ARM
 		Release|ARM64 = Release|ARM64
 		Release|x64 = Release|x64
 		Release|x86 = Release|x86
-		WinUI3|ARM = WinUI3|ARM
 		WinUI3|ARM64 = WinUI3|ARM64
 		WinUI3|x64 = WinUI3|x64
 		WinUI3|x86 = WinUI3|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|ARM.ActiveCfg = Debug|ARM
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|ARM.Build.0 = Debug|ARM
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|ARM64.Build.0 = Debug|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|x64.ActiveCfg = Debug|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|x64.Build.0 = Debug|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|x86.ActiveCfg = Debug|Win32
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Debug|x86.Build.0 = Debug|Win32
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|ARM.ActiveCfg = Release|ARM
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|ARM.Build.0 = Release|ARM
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|ARM64.ActiveCfg = Release|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|ARM64.Build.0 = Release|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|x64.ActiveCfg = Release|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|x64.Build.0 = Release|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|x86.ActiveCfg = Release|Win32
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.Release|x86.Build.0 = Release|Win32
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|ARM.Build.0 = Release|ARM
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|x64.ActiveCfg = Release|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|x64.Build.0 = Release|x64
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|x86.ActiveCfg = Release|Win32
 		{0D1E54D3-4BE1-4DAF-98BF-124C28C85014}.WinUI3|x86.Build.0 = Release|Win32
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM.ActiveCfg = Debug|ARM
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM.Build.0 = Debug|ARM
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|ARM64.Build.0 = Debug|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x64.ActiveCfg = Debug|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x64.Build.0 = Debug|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x86.ActiveCfg = Debug|Win32
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Debug|x86.Build.0 = Debug|Win32
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM.ActiveCfg = Release|ARM
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM.Build.0 = Release|ARM
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM64.ActiveCfg = Release|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|ARM64.Build.0 = Release|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x64.ActiveCfg = Release|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x64.Build.0 = Release|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x86.ActiveCfg = Release|Win32
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.Release|x86.Build.0 = Release|Win32
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|ARM.Build.0 = Release|ARM
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|x64.ActiveCfg = Release|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|x64.Build.0 = Release|x64
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|x86.ActiveCfg = Release|Win32
 		{FCA38F3C-7C73-4C47-BE4E-32F77FA8538D}.WinUI3|x86.Build.0 = Release|Win32
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM.ActiveCfg = Debug|ARM
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM.Build.0 = Debug|ARM
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|ARM64.Build.0 = Debug|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x64.ActiveCfg = Debug|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x64.Build.0 = Debug|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x86.ActiveCfg = Debug|Win32
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Debug|x86.Build.0 = Debug|Win32
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM.ActiveCfg = Release|ARM
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM.Build.0 = Release|ARM
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM64.ActiveCfg = Release|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|ARM64.Build.0 = Release|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x64.ActiveCfg = Release|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x64.Build.0 = Release|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x86.ActiveCfg = Release|Win32
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.Release|x86.Build.0 = Release|Win32
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|ARM.Build.0 = Release|ARM
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|x64.ActiveCfg = Release|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|x64.Build.0 = Release|x64
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|x86.ActiveCfg = Release|Win32
 		{A990658C-CE31-4BCC-976F-0FC6B1AF693D}.WinUI3|x86.Build.0 = Release|Win32
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM.ActiveCfg = Debug|ARM
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM.Build.0 = Debug|ARM
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|ARM64.Build.0 = Debug|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x64.ActiveCfg = Debug|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x64.Build.0 = Debug|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x86.ActiveCfg = Debug|Win32
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Debug|x86.Build.0 = Debug|Win32
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM.ActiveCfg = Release|ARM
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM.Build.0 = Release|ARM
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM64.ActiveCfg = Release|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|ARM64.Build.0 = Release|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x64.ActiveCfg = Release|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x64.Build.0 = Release|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x86.ActiveCfg = Release|Win32
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.Release|x86.Build.0 = Release|Win32
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|ARM.Build.0 = Release|ARM
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|x64.ActiveCfg = Release|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|x64.Build.0 = Release|x64
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|x86.ActiveCfg = Release|Win32
 		{A62D504A-16B8-41D2-9F19-E2E86019E5E4}.WinUI3|x86.Build.0 = Release|Win32
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM.ActiveCfg = Debug|ARM
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM.Build.0 = Debug|ARM
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|ARM64.Build.0 = Debug|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x64.ActiveCfg = Debug|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x64.Build.0 = Debug|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x86.ActiveCfg = Debug|Win32
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Debug|x86.Build.0 = Debug|Win32
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM.ActiveCfg = Release|ARM
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM.Build.0 = Release|ARM
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM64.ActiveCfg = Release|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|ARM64.Build.0 = Release|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x64.ActiveCfg = Release|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x64.Build.0 = Release|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x86.ActiveCfg = Release|Win32
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.Release|x86.Build.0 = Release|Win32
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|ARM.Build.0 = Release|ARM
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|x64.ActiveCfg = Release|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|x64.Build.0 = Release|x64
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|x86.ActiveCfg = Release|Win32
 		{F7D32BD0-2749-483E-9A0D-1635EF7E3136}.WinUI3|x86.Build.0 = Release|Win32
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM.ActiveCfg = Debug|ARM
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM.Build.0 = Debug|ARM
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|ARM64.Build.0 = Debug|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x64.ActiveCfg = Debug|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x64.Build.0 = Debug|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x86.ActiveCfg = Debug|Win32
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Debug|x86.Build.0 = Debug|Win32
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM.ActiveCfg = Release|ARM
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM.Build.0 = Release|ARM
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM64.ActiveCfg = Release|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|ARM64.Build.0 = Release|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x64.ActiveCfg = Release|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x64.Build.0 = Release|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x86.ActiveCfg = Release|Win32
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.Release|x86.Build.0 = Release|Win32
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|ARM.ActiveCfg = Release|ARM
-		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|ARM.Build.0 = Release|ARM
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|ARM64.ActiveCfg = Release|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|ARM64.Build.0 = Release|ARM64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|x64.ActiveCfg = Release|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|x64.Build.0 = Release|x64
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|x86.ActiveCfg = Release|Win32
 		{A9D95A91-4DB7-4F72-BEB6-FE8A5C89BFBD}.WinUI3|x86.Build.0 = Release|Win32
-		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|ARM.ActiveCfg = Debug|ARM
-		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|ARM.Build.0 = Debug|ARM
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|ARM64.ActiveCfg = Debug|ARM64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|ARM64.Build.0 = Debug|ARM64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|x64.ActiveCfg = Debug|x64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|x64.Build.0 = Debug|x64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|x86.ActiveCfg = Debug|Win32
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Debug|x86.Build.0 = Debug|Win32
-		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|ARM.ActiveCfg = Release|ARM
-		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|ARM.Build.0 = Release|ARM
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|ARM64.ActiveCfg = Release|ARM64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|ARM64.Build.0 = Release|ARM64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|x64.ActiveCfg = Release|x64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|x64.Build.0 = Release|x64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|x86.ActiveCfg = Release|Win32
 		{11C084A3-A57C-4296-A679-CAC17B603144}.Release|x86.Build.0 = Release|Win32
-		{11C084A3-A57C-4296-A679-CAC17B603144}.WinUI3|ARM.ActiveCfg = WinUI3|ARM
-		{11C084A3-A57C-4296-A679-CAC17B603144}.WinUI3|ARM.Build.0 = WinUI3|ARM
 		{11C084A3-A57C-4296-A679-CAC17B603144}.WinUI3|ARM64.ActiveCfg = WinUI3|ARM64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.WinUI3|ARM64.Build.0 = WinUI3|ARM64
 		{11C084A3-A57C-4296-A679-CAC17B603144}.WinUI3|x64.ActiveCfg = WinUI3|x64
